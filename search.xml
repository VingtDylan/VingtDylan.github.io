<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 406]]></title>
    <url>%2Fp%2F59fb.html</url>
    <content type="text"><![CDATA[406. 根据身高重建队列难度: medium 假设有打乱顺序的一群人站成一个队列。 每个人由一个整数对(h, k)表示，其中h是这个人的身高，k是排在这个人前面且身高大于或等于h的人数。 编写一个算法来重建这个队列。 注意：总人数少于1100人。 示例 12345输入:[[7,0], [4,4], [7,1], [5,0], [6,1], [5,2]]输出:[[5,0], [7,0], [5,2], [6,1], [4,4], [7,1]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/queue-reconstruction-by-height著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码 从高到矮，次序从小到大排序 根据次序insert 123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; reconstructQueue(vector&lt;vector&lt;int&gt;&gt;&amp; people) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(people.begin(),people.end(),[&amp;](vector&lt;int&gt; a,vector&lt;int&gt; b)&#123; return a[0] &gt; b[0] || (a[0] == b[0] &amp;&amp; a[1] &lt; b[1]); &#125;); //for(auto p : people)cout&lt;&lt;p[0]&lt;&lt;p[1]&lt;&lt;endl; for(auto p : people)res.insert(res.begin() + p[1], p); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 97]]></title>
    <url>%2Fp%2F69ae.html</url>
    <content type="text"><![CDATA[97. 交错字符串难度: hard 给定三个字符串 s1, s2, s3, 验证 s3 是否是由 s1 和 s2 交错组成的。 示例 1: 12输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;输出: true 示例 2: 12输入: s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbbaccc&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/interleaving-string/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819class Solution &#123;public: bool isInterleave(string s1, string s2, string s3) &#123; int s1_size = s1.size(); int s2_size = s2.size(); int s3_size = s3.size(); if(s1_size + s2_size != s3_size)return false; vector&lt;bool&gt; f(s2_size + 1, false); f[0] = true; for(int i = 0; i &lt;= s1_size; i++)&#123; for(int j = 0; j &lt;= s2_size; j++)&#123; int p = i + j - 1; if(i &gt; 0)f[j] = f[j] &amp; (s1[i - 1] == s3[p]); if(j &gt; 0)f[j] = f[j] | (f[j - 1] &amp;&amp; s2[j - 1] == s3[p]); &#125; &#125; return f[s2_size]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 35]]></title>
    <url>%2Fp%2F829.html</url>
    <content type="text"><![CDATA[35. 搜索插入位置难度: easy 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。 你可以假设数组中无重复元素。 示例 1: 12输入: [1,3,5,6], 5输出: 2 示例 2: 12输入: [1,3,5,6], 2输出: 1 示例 3: 12输入: [1,3,5,6], 7输出: 4 示例 4: 12输入: [1,3,5,6], 0输出: 0 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/search-insert-position/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left = 0, right = nums.size() - 1; int mid; while(left &lt; right)&#123; mid = left + (right - left) / 2; if(nums[mid] == target)return mid; if(nums[mid] &gt; target)right = mid; else left = mid + 1; &#125; if(left == nums.size() - 1 &amp;&amp; nums[left] &lt; target)return nums.size(); return left; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 785]]></title>
    <url>%2Fp%2F984c.html</url>
    <content type="text"><![CDATA[785. 判断二分图难度: medium 给定一个无向图graph，当这个图为二分图时返回true。 如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。 graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。 1234567891011121314151617181920示例 1:输入: [[1,3], [0,2], [1,3], [0,2]]输出: true解释: 无向图如下:0----1| || |3----2我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。示例 2:输入: [[1,2,3], [0,2], [0,1,3], [0,2]]输出: false解释: 无向图如下:0----1| \ || \ |3----2我们不能将节点分割成两个独立的子集。 注意: graph 的长度范围为 [1, 100]。 graph[i] 中的元素的范围为 [0, graph.length - 1]。 graph[i] 不会包含 i 或者有重复的值。 图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/is-graph-bipartite/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 96]]></title>
    <url>%2Fp%2Fa96f.html</url>
    <content type="text"><![CDATA[96. 不同的二叉搜索树难度: medium 给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011class Solution &#123;public: int numTrees(int n) &#123; vector&lt;int&gt; res(n + 1, 0); res[0] = 1, res[1] = 1; for(int i = 2; i &lt;= n; i++) for(int j = 0; j &lt;= i - 1; j++) res[i] += res[j] * res[i - 1 - j]; return res[n]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 120]]></title>
    <url>%2Fp%2F3a6a.html</url>
    <content type="text"><![CDATA[120. 三角形最小路径和难度: medium 给定一个三角形，找出自顶向下的最小路径和。每一步只能移动到下一行中相邻的结点上。 相邻的结点 在这里指的是 下标 与 上一层结点下标 相同或者等于 上一层结点下标 + 1 的两个结点。 例如，给定三角形： 123456[ [2], [3,4], [6,5,7], [4,1,8,3]] 自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。 说明 如果你可以只使用 O(n) 的额外空间（n 为三角形的总行数）来解决这个问题，那么你的算法会很加分。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/triangle/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112class Solution &#123;public: int minimumTotal(vector&lt;vector&lt;int&gt;&gt;&amp; triangle) &#123; vector&lt;int&gt; dp(triangle.back()); for(int i = (int)triangle.size() - 2; i &gt;= 0; i--)&#123; for(int j = 0; j &lt;= i; j++)&#123; dp[j] = min(dp[j], dp[j + 1]) + triangle[i][j]; &#125; &#125; return dp[0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 350]]></title>
    <url>%2Fp%2Fcac9.html</url>
    <content type="text"><![CDATA[350. 两个数组的交集 II难度: easy 给定两个数组，编写一个函数来计算它们的交集。 示例 1： 12输入：nums1 = [1,2,2,1], nums2 = [2,2]输出：[2,2] 示例 2: 12输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]输出：[4,9] 说明： 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 我们可以不考虑输出结果的顺序。 \进阶\：** 如果给定的数组已经排好序呢？你将如何优化你的算法？ 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ 如果 nums2 的元素存储在磁盘上，磁盘内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: vector&lt;int&gt; intersect(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; unordered_map&lt;int,int&gt; mp; for(int num : nums1)mp[num]++; vector&lt;int&gt; res; for(int num : nums2)&#123; if(mp.count(num) &amp;&amp; mp[num] &gt; 0)&#123; res.push_back(num); mp[num]--; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 174]]></title>
    <url>%2Fp%2Fa968.html</url>
    <content type="text"><![CDATA[174. 地下城游戏难度: hard 一些恶魔抓住了公主（P）并将她关在了地下城的右下角。地下城是由 M x N 个房间组成的二维网格。我们英勇的骑士（K）最初被安置在左上角的房间里，他必须穿过地下城并通过对抗恶魔来拯救公主。 骑士的初始健康点数为一个正整数。如果他的健康点数在某一时刻降至 0 或以下，他会立即死亡。 有些房间由恶魔守卫，因此骑士在进入这些房间时会失去健康点数（若房间里的值为负整数，则表示骑士将损失健康点数）；其他房间要么是空的（房间里的值为 0），要么包含增加骑士健康点数的魔法球（若房间里的值为正整数，则表示骑士将增加健康点数）。 为了尽快到达公主，骑士决定每次只向右或向下移动一步。 编写一个函数来计算确保骑士能够拯救到公主所需的最低初始健康点数。 例如，考虑到如下布局的地下城，如果骑士遵循最佳路径 右 -&gt; 右 -&gt; 下 -&gt; 下，则骑士的初始健康点数至少为 7。 -2 (K) -3 3 -5 -10 1 10 30 -5 (P) 说明: 骑士的健康点数没有上限。 任何房间都可能对骑士的健康点数造成威胁，也可能增加骑士的健康点数，包括骑士进入的左上角房间以及公主被监禁的右下角房间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/dungeon-game/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: int calculateMinimumHP(vector&lt;vector&lt;int&gt;&gt;&amp; dungeon) &#123; int n = dungeon.size(), m = dungeon[0].size(); vector&lt;vector&lt;int&gt;&gt; dp(n + 1, vector&lt;int&gt;(m + 1, INT_MAX)); dp[n][m - 1] = dp[n - 1][m] = 1; for (int i = n - 1; i &gt;= 0; --i) &#123; for (int j = m - 1; j &gt;= 0; --j) &#123; int minn = min(dp[i + 1][j], dp[i][j + 1]); dp[i][j] = max(minn - dungeon[i][j], 1); &#125; &#125; return dp[0][0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>动态规划</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 832]]></title>
    <url>%2Fp%2F693a.html</url>
    <content type="text"><![CDATA[832. 翻转图像难度: easy 给定一个二进制矩阵 A，我们想先水平翻转图像，然后反转图像并返回结果。 水平翻转图片就是将图片的每一行都进行翻转，即逆序。例如，水平翻转 [1, 1, 0] 的结果是 [0, 1, 1]。 反转图片的意思是图片中的 0 全部被 1 替换， 1 全部被 0 替换。例如，反转 [0, 1, 1] 的结果是 [1, 0, 0]。 示例 1: 1234输入: [[1,1,0],[1,0,1],[0,0,0]]输出: [[1,0,0],[0,1,0],[1,1,1]]解释: 首先翻转每一行: [[0,1,1],[1,0,1],[0,0,0]]； 然后反转图片: [[1,0,0],[0,1,0],[1,1,1]] 示例 2: 1234输入: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]]输出: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]]解释: 首先翻转每一行: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]； 然后反转图片: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] 说明: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/flipping-an-image/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; flipAndInvertImage(vector&lt;vector&lt;int&gt;&gt;&amp; A) &#123; int m = A.size(), n = A[0].size(); for(int i = 0; i &lt; m; i++)&#123; int l = 0, r = n - 1; while(l &lt; r)swap(A[i][l++],A[i][r--]); &#125; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; A[i][j] = 1 - A[i][j]; &#125; &#125; return A; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 917]]></title>
    <url>%2Fp%2Fcaaa.html</url>
    <content type="text"><![CDATA[917. 仅仅反转字母难度: easy 给定一个字符串 S，返回 “反转后的” 字符串，其中不是字母的字符都保留在原地，而所有字母的位置发生反转。 示例 1： 12输入：&quot;ab-cd&quot;输出：&quot;dc-ba&quot; 示例 2： 12输入：&quot;a-bC-dEf-ghIj&quot;输出：&quot;j-Ih-gfE-dCba&quot; 示例 3： 12输入：&quot;Test1ng-Leet=code-Q!&quot;输出：&quot;Qedo1ct-eeLg=ntse-T!&quot; 提示： S.length &lt;= 100 33 &lt;= S[i].ASCIIcode &lt;= 122 S 中不包含 \ or &quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-only-letters/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: string reverseOnlyLetters(string S) &#123; int l = 0, r = S.size() - 1; while(l &lt; r)&#123; while(!isalpha(S[l]) &amp;&amp; l &lt; r)l++; while(!isalpha(S[r]) &amp;&amp; l &lt; r)r--; if(l &lt; r)&#123; swap(S[l],S[r]); l++,r--; &#125; &#125; return S; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 922]]></title>
    <url>%2Fp%2F396a.html</url>
    <content type="text"><![CDATA[922. 按奇偶排序数组 II难度: easy 给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。 对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。 你可以返回任何满足上述条件的数组作为答案。 示例： 123输入：[4,2,5,7]输出：[4,5,2,7]解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。 提示： 2 &lt;= A.length &lt;= 20000 A.length % 2 == 0 0 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sort-array-by-parity-ii/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213class Solution &#123;public: vector&lt;int&gt; sortArrayByParityII(vector&lt;int&gt;&amp; A) &#123; int odd = 1, even = 0; for(int even = 0; even &lt; A.size(); even += 2)&#123; if(A[even] &amp; 1)&#123; while(A[odd] &amp; 1)odd += 2; swap(A[odd],A[even]); &#125; &#125; return A; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 976]]></title>
    <url>%2Fp%2Faa68.html</url>
    <content type="text"><![CDATA[976. 三角形的最大周长难度: easy 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。 如果不能形成任何面积不为零的三角形，返回 0。 示例 1： 12输入：[2,1,2]输出：5 示例 2： 12输入：[1,2,1]输出：0 示例 3： 12输入：[3,2,3,4]输出：10 示例 4： 12输入：[3,6,2,3]输出：8 提示： 3 &lt;= A.length &lt;= 10000 1 &lt;= A[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-perimeter-triangle/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910class Solution &#123;public: int largestPerimeter(vector&lt;int&gt;&amp; A) &#123; sort(A.begin(),A.end()); for(int i = A.size() - 3; i &gt;= 0; i--)&#123; if(A[i] + A[i + 1] &gt; A[i + 2])return A[i] + A[i + 1] + A[i + 2]; &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 315]]></title>
    <url>%2Fp%2F90b.html</url>
    <content type="text"><![CDATA[315. 计算右侧小于当前元素的个数难度: hard 给定一个整数数组 nums，按要求返回一个新数组 counts。数组 counts有该性质： counts[i] 的值是 nums[i] 右侧小于 nums[i] 的元素的数量。 示例： 1234567输入：[5,2,6,1]输出：[2,1,1,0] 解释：5 的右侧有 2 个更小的元素 (2 和 1)2 的右侧仅有 1 个更小的元素 (1)6 的右侧有 1 个更小的元素 (1)1 的右侧有 0 个更小的元素 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536class Solution &#123;public: vector&lt;pair&lt;int, int&gt;&gt; a; vector&lt;pair&lt;int, int&gt;&gt; b; vector&lt;int&gt; ans; vector&lt;int&gt; countSmaller(vector&lt;int&gt;&amp; nums) &#123; if (nums.empty()) return &#123;&#125;; int n = nums.size(); ans = vector&lt;int&gt;(n); b = vector&lt;pair&lt;int, int&gt;&gt; (n); for (int i = 0; i &lt; n; i++) a.push_back(&#123;nums[i], i&#125;); merge_sort(a, 0, n - 1); return ans; &#125; void merge_sort(vector&lt;pair&lt;int, int&gt;&gt;&amp; a, int l, int r) &#123; if (l == r) return; int mid = l + r &gt;&gt; 1; merge_sort(a, l, mid); merge_sort(a, mid + 1, r); int i = l, j = mid + 1, k = 0; while(i &lt;= mid &amp;&amp; j &lt;= r)&#123; if (a[i].first &lt;= a[j].first) &#123; b[k++] = a[i]; ans[a[i++].second] += j - mid - 1; &#125; else b[k++] = a[j++]; &#125; while (i &lt;= mid) &#123; ans[a[i].second] += r - mid; b[k++] = a[i++]; &#125; while (j &lt;= r) b[k++] = a[j++]; for (int i = 0; i &lt; k; i++) a[l + i] = b[i]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>二分查找</tag>
        <tag>排序</tag>
        <tag>分治算法</tag>
        <tag>树状数组</tag>
        <tag>线段树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 766]]></title>
    <url>%2Fp%2Ff908.html</url>
    <content type="text"><![CDATA[766. 托普利茨矩阵难度: easy 如果矩阵上每一条由左上到右下的对角线上的元素都相同，那么这个矩阵是托普利茨矩阵 。 给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。 示例 1: 1234567891011输入: matrix = [ [1,2,3,4], [5,1,2,3], [9,5,1,2]]输出: True解释:在上述矩阵中, 其对角线为:&quot;[9]&quot;, &quot;[5, 5]&quot;, &quot;[1, 1, 1]&quot;, &quot;[2, 2, 2]&quot;, &quot;[3, 3]&quot;, &quot;[4]&quot;。各条对角线上的所有元素均相同, 因此答案是True。 示例 2: 12345678输入:matrix = [ [1,2], [2,2]]输出: False解释: 对角线&quot;[1, 2]&quot;上的元素不同。 说明: matrix 是一个包含整数的二维数组。 matrix 的行数和列数均在 [1, 20]范围内。 matrix[i][j] 包含的整数在 [0, 99]范围内。 进阶: 如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？ 如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/toeplitz-matrix/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: bool isToeplitzMatrix(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; unordered_map&lt;int,int&gt; mp; int m = matrix.size(), n = matrix[0].size(); for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; int key = j - i; if(mp.count(key) &amp;&amp; mp[key] != matrix[i][j])return false; else mp[key] = matrix[i][j]; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 747]]></title>
    <url>%2Fp%2F59c8.html</url>
    <content type="text"><![CDATA[747. 至少是其他数字两倍的最大数难度: easy 在一个给定的数组nums中，总是存在一个最大元素 。 查找数组中的最大元素是否至少是数组中每个其他数字的两倍。 如果是，则返回最大元素的索引，否则返回-1。 示例 1: 1234输入: nums = [3, 6, 1, 0]输出: 1解释: 6是最大的整数, 对于数组中的其他整数,6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1. 示例 2 123输入: nums = [1, 2, 3, 4]输出: -1解释: 4没有超过3的两倍大, 所以我们返回 -1. 提示: nums 的长度范围在[1, 50]. 每个 nums[i] 的整数范围在 [0, 100]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-number-at-least-twice-of-others/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819class Solution &#123;public: int dominantIndex(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() == 1)return 0; int temp = nums[0]; int index; for(int i = 0; i &lt; nums.size(); i++)&#123; if(nums[i] &gt; temp)&#123; index = i; temp = nums[i]; &#125; &#125; for(int i = 0; i &lt; nums.size(); i++)&#123; if(i == index)continue; if(nums[i] * 2 &gt; temp)return -1; &#125; return index; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 744]]></title>
    <url>%2Fp%2F5888.html</url>
    <content type="text"><![CDATA[744. 寻找比目标字母大的最小字母难度: easy 给你一个排序后的字符列表 letters ，列表中只包含小写英文字母。另给出一个目标字母 target，请你寻找在这一有序列表里比目标字母大的最小字母。 在比较时，字母是依序循环出现的。举个例子： 如果目标字母 target = &#39;z&#39; 并且字符列表为 letters = [&#39;a&#39;, &#39;b&#39;]，则答案返回 &#39;a&#39; 示例： 1234567891011121314151617181920212223242526272829输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;a&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;c&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;d&quot;输出: &quot;f&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;g&quot;输出: &quot;j&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;j&quot;输出: &quot;c&quot;输入:letters = [&quot;c&quot;, &quot;f&quot;, &quot;j&quot;]target = &quot;k&quot;输出: &quot;c&quot; 提示： letters长度范围在[2, 10000]区间内。 letters 仅由小写字母组成，最少包含两个不同的字母。 目标字母target 是一个小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-smallest-letter-greater-than-target/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213class Solution &#123;public: char nextGreatestLetter(vector&lt;char&gt;&amp; letters, char target) &#123; if(letters.back() &lt;= target)return letters[0]; int l = 0, r = letters.size() - 1; while(l &lt; r)&#123; int m = l + (r - l &gt;&gt; 1); if(letters[m] &gt; target)r = m; else l = m + 1; &#125; return letters[l]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 309]]></title>
    <url>%2Fp%2F9c0a.html</url>
    <content type="text"><![CDATA[309. 最佳买卖股票时机含冷冻期难度: medium 给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。 设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例: 123输入: [1,2,3,0,2]输出: 3 解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718class Solution &#123;public: int maxProfit(vector&lt;int&gt;&amp; prices) &#123; if (prices.empty()) return 0; int n = prices.size(); // f[ ][0] 拥有股票 // f[ ][1] 无股票，不在冷冻期 // f[ ][2] 无股票，在冷冻期 vector&lt;vector&lt;int&gt;&gt; f(n, vector&lt;int&gt;(3)); f[0][0] = -prices[0]; for (int i = 1; i &lt; n; ++i) &#123; f[i][0] = max(f[i - 1][0],f[i - 1][1] - prices[i]); f[i][1] = max(f[i - 1][1], f[i - 1][2]); f[i][2] = f[i - 1][0] + prices[i]; &#125; return max(f[n - 1][1], f[n - 1][2]); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 693]]></title>
    <url>%2Fp%2Fca9c.html</url>
    <content type="text"><![CDATA[693. 交替位二进制数难度: easy 给定一个正整数，检查他是否为交替位二进制数：换句话说，就是他的二进制数相邻的两个位数永不相等。 示例 1: 1234输入: 5输出: True解释:5的二进制数是: 101 示例 2: 1234输入: 7输出: False解释:7的二进制数是: 111 示例 3: 1234输入: 11输出: False解释:11的二进制数是: 1011 示例 4: 1234输入: 10输出: True解释:10的二进制数是: 1010 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567class Solution &#123;public: bool hasAlternatingBits(int n) &#123; if(n == 1)return true; return ((n &amp; 1) != ((n &gt;&gt; 1) &amp; 1)) &amp;&amp; hasAlternatingBits(n &gt;&gt; 1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 784]]></title>
    <url>%2Fp%2F588d.html</url>
    <content type="text"><![CDATA[784. 字母大小写全排列难度: easy 给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。 123456789示例:输入: S = &quot;a1b2&quot;输出: [&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]输入: S = &quot;3z4&quot;输出: [&quot;3z4&quot;, &quot;3Z4&quot;]输入: S = &quot;12345&quot;输出: [&quot;12345&quot;] 注意： S 的长度不超过12。 S 仅由数字和字母组成。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-case-permutation/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 1234567891011121314151617181920class Solution &#123;public: vector&lt;string&gt; ans; vector&lt;string&gt; letterCasePermutation(string S) &#123; dfs(S, 0); return ans; &#125; void dfs(string &amp;S, int index)&#123; if(index == S.size())&#123; ans.push_back(S); return; &#125; dfs(S, index + 1); if(isalpha(S[index]))&#123; S[index] = S[index] ^ 32; dfs(S, index + 1); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯算法</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题 17.13]]></title>
    <url>%2Fp%2Fa05.html</url>
    <content type="text"><![CDATA[面试题 17.13. 恢复空格难度: medium 哦，不！你不小心把一个长篇文章中的空格、标点都删掉了，并且大写也弄成了小写。像句子&quot;I reset the computer. It still didn’t boot!&quot;已经变成了&quot;iresetthecomputeritstilldidntboot&quot;。在处理标点符号和大小写之前，你得先把它断成词语。当然了，你有一本厚厚的词典dictionary，不过，有些词没在词典里。假设文章用sentence表示，设计一个算法，把文章断开，要求未识别的字符最少，返回未识别的字符数。 注意：本题相对原题稍作改动，只需返回未识别的字符数 示例： 12345输入：dictionary = [&quot;looked&quot;,&quot;just&quot;,&quot;like&quot;,&quot;her&quot;,&quot;brother&quot;]sentence = &quot;jesslookedjustliketimherbrother&quot;输出： 7解释： 断句后为&quot;jess looked just like tim her brother&quot;，共7个未识别字符。 提示： 0 &lt;= len(sentence) &lt;= 1000 dictionary中总字符数不超过 150000。 你可以认为dictionary和sentence中只包含小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/re-space-lcci/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>程序员面试金典</tag>
        <tag>记忆化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题 16.11]]></title>
    <url>%2Fp%2F3785.html</url>
    <content type="text"><![CDATA[面试题 16.11. 跳水板难度: easy 你正在使用一堆木板建造跳水板。有两种类型的木板，其中长度较短的木板长度为shorter，长度较长的木板长度为longer。你必须正好使用k块木板。编写一个方法，生成跳水板所有可能的长度。 返回的长度需要从小到大排列。 示例 1 1234567输入：shorter = 1longer = 2k = 3输出： [3,4,5,6]解释：可以使用 3 次 shorter，得到结果 3；使用 2 次 shorter 和 1 次 longer，得到结果 4 。以此类推，得到最终结果。 提示： 0 &lt; shorter &lt;= longer 0 &lt;= k &lt;= 100000 来源：力扣（LeetCode）链接 https://leetcode-cn.com/problems/diving-board-lcci/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213class Solution &#123;public: vector&lt;int&gt; divingBoard(int shorter, int longer, int k) &#123; if(k == 0)return vector&lt;int&gt;&#123;&#125;;//看不懂k = 0有啥意义 set&lt;int&gt; s; for(int i = 0; i &lt;= k; i++)&#123; s.insert(shorter * i + longer * (k - i)); &#125; vector&lt;int&gt; res; for(set&lt;int&gt;::iterator iter = s.begin(); iter != s.end(); iter++) res.push_back(*iter); return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>程序员面试金典</tag>
        <tag>记忆化</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1200]]></title>
    <url>%2Fp%2F3bba.html</url>
    <content type="text"><![CDATA[1200. 最小绝对差难度: easy 给你个整数数组 arr，其中每个元素都 不相同。 请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。 示例 1： 12输入：arr = [4,2,1,3]输出：[[1,2],[2,3],[3,4]] 示例 2： 12输入：arr = [1,3,6,10,15]输出：[[1,3]] 示例 3： 12输入：arr = [3,8,-10,23,19,-4,-14,27]输出：[[-14,-10],[19,23],[23,27]] 提示： 2 &lt;= arr.length &lt;= 10^5 -10^6 &lt;= arr[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-absolute-difference/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; minimumAbsDifference(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(),arr.end()); map&lt;int,vector&lt;vector&lt;int&gt;&gt;&gt; mp; int len = arr.size(); for(int i = 1; i &lt; len; i++)&#123; mp[arr[i] - arr[i - 1]].push_back(&#123;arr[i - 1], arr[i]&#125;); &#125; return mp.begin()-&gt;second; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1217]]></title>
    <url>%2Fp%2F69fa.html</url>
    <content type="text"><![CDATA[1217. 玩筹码难度: easy 数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。 你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）： 将第 i 个筹码向左或者右移动 2 个单位，代价为 0。 将第 i 个筹码向左或者右移动 1 个单位，代价为 1。 最开始的时候，同一位置上也可能放着两个或者更多的筹码。 返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。 示例 1： 123输入：chips = [1,2,3]输出：1解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。 示例 2： 123输入：chips = [2,2,2,3,3]输出：2解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。 提示： 1 &lt;= chips.length &lt;= 100 1 &lt;= chips[i] &lt;= 10^9 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/play-with-chips/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678class Solution &#123;public: int minCostToMoveChips(vector&lt;int&gt;&amp; chips) &#123; vector&lt;int&gt; num(2,0); for(int chip : chips)num[chip % 2]++; return min(num[0],num[1]); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>数学</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1207]]></title>
    <url>%2Fp%2Ff9fb.html</url>
    <content type="text"><![CDATA[1207. 独一无二的出现次数难度: easy 给你一个整数数组 arr，请你帮忙统计数组中每个数的出现次数。 如果每个数的出现次数都是独一无二的，就返回 true；否则返回 false。 示例 1： 123输入：arr = [1,2,2,1,1,3]输出：true解释：在该数组中，1 出现了 3 次，2 出现了 2 次，3 只出现了 1 次。没有两个数的出现次数相同。 示例 2： 12输入：arr = [1,2]输出：false 示例 3： 12输入：arr = [-3,0,1,-3,1,1,1,-3,10,0]输出：true 提示： 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-number-of-occurrences/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213class Solution &#123;public: bool uniqueOccurrences(vector&lt;int&gt;&amp; arr) &#123; unordered_map&lt;int,int&gt; mp; unordered_set&lt;int&gt; s; for(int a : arr)mp[a]++; for(auto m : mp)&#123; if(s.find(m.second) != s.end())return false; else s.insert(m.second); &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1464]]></title>
    <url>%2Fp%2F5958.html</url>
    <content type="text"><![CDATA[1464. 数组中两元素的最大乘积难度： easy 给你一个整数数组 nums，请你选择数组的两个不同下标 i 和 j，使 (nums[i]-1)*(nums[j]-1) 取得最大值。 请你计算并返回该式的最大值。 示例 1： 123输入：nums = [3,4,5,2]输出：12 解释：如果选择下标 i=1 和 j=2（下标从 0 开始），则可以获得最大值，(nums[1]-1)*(nums[2]-1) = (4-1)*(5-1) = 3*4 = 12 。 示例 2： 123输入：nums = [1,5,4,5]输出：16解释：选择下标 i=1 和 j=3（下标从 0 开始），则可以获得最大值 (5-1)*(5-1) = 16 。 示例 3： 12输入：nums = [3,7]输出：12 提示： 2 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 10^3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; sort(nums.begin(),nums.end(),greater&lt;int&gt;()); return (nums[0] - 1) * (nums[1] - 1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1480]]></title>
    <url>%2Fp%2Ffa5d.html</url>
    <content type="text"><![CDATA[1480. 一维数组的动态和难度：easy 给你一个数组 nums 。数组「动态和」的计算公式为：runningSum[i] = sum(nums[0]…nums[i]) 。 请返回 nums 的动态和。 示例 1： 123输入：nums = [1,2,3,4]输出：[1,3,6,10]解释：动态和计算过程为 [1, 1+2, 1+2+3, 1+2+3+4] 。 示例 2： 123输入：nums = [1,1,1,1,1]输出：[1,2,3,4,5]解释：动态和计算过程为 [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1] 。 示例 3： 12输入：nums = [3,1,2,10,1]输出：[3,4,6,16,17] 提示： 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/running-sum-of-1d-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112class Solution &#123;public: vector&lt;int&gt; runningSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res; int sum = 0; for(int num : nums)&#123; sum += num; res.push_back(sum); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1486]]></title>
    <url>%2Fp%2Ff8dd.html</url>
    <content type="text"><![CDATA[1486. 数组异或操作难度：easy 给你两个整数，n 和 start 。 数组 nums 定义为：nums[i] = start + 2*i（下标从 0 开始）且 n == nums.length 。 请返回 nums 中所有元素按位异或（XOR）后得到的结果。 示例 1： 1234输入：n = 5, start = 0输出：8解释：数组 nums 为 [0, 2, 4, 6, 8]，其中 (0 ^ 2 ^ 4 ^ 6 ^ 8) = 8 。 &quot;^&quot; 为按位异或 XOR 运算符。 示例 2： 123输入：n = 4, start = 3输出：8解释：数组 nums 为 [3, 5, 7, 9]，其中 (3 ^ 5 ^ 7 ^ 9) = 8. 示例 3： 12输入：n = 1, start = 7输出：7 示例 4： 12输入：n = 10, start = 5输出：2 提示： 1 &lt;= n &lt;= 1000 0 &lt;= start &lt;= 1000 n == nums.length 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/xor-operation-in-an-array/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910class Solution &#123;public: int xorOperation(int n, int start) &#123; int res = 0; for(int i &#123;0&#125;; i &lt; n; i++)&#123; res ^= (start + 2 * i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 11.期望个数统计]]></title>
    <url>%2Fp%2Fa23d.html</url>
    <content type="text"><![CDATA[LCP 11. 期望个数统计难度: easy 某互联网公司一年一度的春招开始了，一共有 n 名面试者入选。每名面试者都会提交一份简历，公司会根据提供的简历资料产生一个预估的能力值，数值越大代表越有可能通过面试。 小 A 和小 B 负责审核面试者，他们均有所有面试者的简历，并且将各自根据面试者能力值从大到小的顺序浏览。由于简历事先被打乱过，能力值相同的简历的出现顺序是从它们的全排列中等可能地取一个。现在给定 n 名面试者的能力值 scores，设 X 代表小 A 和小 B 的浏览顺序中出现在同一位置的简历数，求 X 的期望。 提示：离散的非负随机变量的期望计算公式为 。在本题中，由于 X 的取值为 0 到 n之间，期望计算公式可以是 。 示例 1： 输入：scores = [1,2,3] 输出：3 解释：由于面试者能力值互不相同，小 A 和小 B 的浏览顺序一定是相同的。X的期望是 3 。 示例 2： 输入：scores = [1,1] 输出：1 解释：设两位面试者的编号为 0, 1。由于他们的能力值都是 1，小 A 和小 B 的浏览顺序都为从全排列 [[0,1],[1,0]] 中等可能地取一个。如果小 A 和小 B 的浏览顺序都是 [0,1] 或者 [1,0] ，那么出现在同一位置的简历数为 2 ，否则是 0 。所以 X 的期望是 (2+0+2+0) * 1/4 = 1 示例 3： 输入：scores = [1,1,2] 输出：2 限制： 1 &lt;= scores.length &lt;= 10^5 0 &lt;= scores[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/qi-wang-ge-shu-tong-ji著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910class Solution &#123;public: int expectNumber(vector&lt;int&gt;&amp; scores) &#123; set&lt;int&gt; s; for(int score : scores)&#123; s.insert(score); &#125; return s.size(); &#125;&#125;;]]></content>
      <categories>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 07.传递信息]]></title>
    <url>%2Fp%2Fce4d.html</url>
    <content type="text"><![CDATA[LCP 07. 传递信息难度: easy 小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下： 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。每轮信息必须需要传递给另一个人，且信息可重复经过同一个人给定总玩家数 n，以及按 [玩家编号,对应可传递玩家编号] 关系组成的二维数组 relation。返回信息从小 A (编号 0 ) 经过 k 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。 示例 1： 输入：n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3 输出：3 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0-&gt;2-&gt;0-&gt;4， 0-&gt;2-&gt;1-&gt;4， 0-&gt;2-&gt;3-&gt;4。 示例 2： 输入：n = 3, relation = [[0,2],[2,1]], k = 2 输出：0 解释：信息不能从小 A 处经过 2 轮传递到编号 2 限制： $2 &lt;= n &lt;= 10$$1 &lt;= k &lt;= 5$$1 &lt;= relation.length &lt;= 90, 且 relation[i].length == 2$$0 &lt;= relation[i][0],relation[i][1] &lt; n, relation[i][0] != relation[i][1]$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/chuan-di-xin-xi/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011class Solution &#123;public: int numWays(int n, vector&lt;vector&lt;int&gt;&gt;&amp; relation, int k) &#123; vector&lt;vector&lt;int&gt;&gt; dp(6,vector&lt;int&gt;(11,0)); dp[0][0] = 1; for(int i = 0; i &lt; k; i++) for(auto r : relation) dp[i + 1][r[1]] += dp[i][r[0]]; return dp[k][n - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LCP</tag>
        <tag>mark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 06.拿硬币]]></title>
    <url>%2Fp%2F1614.html</url>
    <content type="text"><![CDATA[LCP 06. 拿硬币难度: easy 桌上有 n 堆力扣币，每堆的数量保存在数组 coins 中。我们每次可以选择任意一堆，拿走其中的一枚或者两枚，求拿完所有力扣币的最少次数。 示例 1： 输入：[4,2,1] 输出：4 解释：第一堆力扣币最少需要拿 2 次，第二堆最少需要拿 1 次，第三堆最少需要拿 1 次，总共 4 次即可拿完。 示例 2： 输入：[2,3,10] 输出：8 限制： 1 &lt;= n &lt;= 4 1 &lt;= coins[i] &lt;= 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/na-ying-bi/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910class Solution &#123;public: int minCount(vector&lt;int&gt;&amp; coins) &#123; int s = 0; for(int c : coins)&#123; s += (c + 1) / 2; &#125; return s; &#125;&#125;;]]></content>
      <categories>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LCP 02.分式化简]]></title>
    <url>%2Fp%2F8022.html</url>
    <content type="text"><![CDATA[LCP 02. 分式化简难度: easy 有一个同学在学习分式。他需要将一个连分数化成最简分数，你能帮助他吗？ 连分数是形如上图的分式。在本题中，所有系数都是大于等于0的整数。 输入的cont代表连分数的系数（cont[0]代表上图的a0，以此类推）。返回一个长度为2的数组[n, m]，使得连分数的值等于n / m，且n, m最大公约数为1。 示例 1： 123输入：cont = [3, 2, 0, 2]输出：[13, 4]解释：原连分数等价于3 + (1 / (2 + (1 / (0 + 1 / 2))))。注意[26, 8], [-13, -4]都不是正确答案。 示例 2： 123输入：cont = [0, 0, 3]输出：[3, 1]解释：如果答案是整数，令分母为1即可。 限制： cont[i] &gt;= 0 1 &lt;= cont的长度 &lt;= 10 cont最后一个元素不等于0 答案的n, m的取值都能被32位int整型存下（即不超过2 ^ 31 - 1）。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/deep-dark-fraction著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021class Solution &#123;public: vector&lt;int&gt; fraction(vector&lt;int&gt;&amp; cont) &#123; int x = cont.back(), y = 1; int len = cont.size(); int temp; for(int i = len - 2; i &gt;= 0; i--)&#123; temp = x; x = cont[i] * x + y; y = temp; &#125; int gcdxy = gcd(x,y); x = x / gcdxy; y = y / gcdxy; return &#123;x,y&#125;; &#125; int gcd(int x,int y)&#123; return y == 0 ? x : gcd(y, x % y); &#125;&#125;;]]></content>
      <categories>
        <category>LCP</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>LCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 112]]></title>
    <url>%2Fp%2Fbeb.html</url>
    <content type="text"><![CDATA[112. 路径总和难度: easy 给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。 说明: 叶子节点是指没有子节点的节点。 示例:给定如下二叉树，以及目标和 sum = 22， 1234567 5 / \ 4 8 / / \ 11 13 4 / \ \7 2 1 返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5-&gt;4-&gt;11-&gt;2。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool hasPathSum(TreeNode* root, int sum) &#123; if(!root)return false; if(!root-&gt;left &amp;&amp; !root-&gt;right &amp;&amp; root-&gt;val == sum)return true; return hasPathSum(root-&gt;left,sum - root-&gt;val) || hasPathSum(root-&gt;right,sum - root-&gt;val); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1502]]></title>
    <url>%2Fp%2F3b8a.html</url>
    <content type="text"><![CDATA[1502. 判断能否形成等差数列难度: easy 给你一个数字数组 arr 。 如果一个数列中，任意相邻两项的差总等于同一个常数，那么这个数列就称为 等差数列 。 如果可以重新排列数组形成等差数列，请返回 true ；否则，返回 false。 示例 1： 123输入：arr = [3,5,1]输出：true解释：对数组重新排序得到 [1,3,5] 或者 [5,3,1] ，任意相邻两项的差分别为 2 或 -2 ，可以形成等差数列。 示例 2： 123输入：arr = [1,2,4]输出：false解释：无法通过重新排序得到等差数列。 提示： 2 &lt;= arr.length &lt;= 1000 -10^6 &lt;= arr[i] &lt;= 10^6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/can-make-arithmetic-progression-from-sequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011class Solution &#123;public: bool canMakeArithmeticProgression(vector&lt;int&gt;&amp; arr) &#123; sort(arr.begin(),arr.end()); int diff = arr[1] - arr[0]; for(int i = 2; i &lt; arr.size(); i++)&#123; if(arr[i] - arr[i - 1] != diff)return false; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1496]]></title>
    <url>%2Fp%2F68dc.html</url>
    <content type="text"><![CDATA[1496. 判断路径是否相交难度: easy 给你一个字符串 path，其中 path[i] 的值可以是 &#39;N&#39;、&#39;S&#39;、&#39;E&#39; 或者 &#39;W&#39;，分别表示向北、向南、向东、向西移动一个单位。 机器人从二维平面上的原点 (0, 0) 处开始出发，按 path 所指示的路径行走。 如果路径在任何位置上出现相交的情况，也就是走到之前已经走过的位置，请返回 True ；否则，返回 False 。 示例 1： 123输入：path = &quot;NES&quot;输出：false 解释：该路径没有在任何位置相交。 示例 2： 123输入：path = &quot;NESWW&quot;输出：true解释：该路径经过原点两次。 提示： 1 &lt;= path.length &lt;= 10^4 path 仅由 {&#39;N&#39;, &#39;S&#39;, &#39;E&#39;, &#39;W} 中的字符组成 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/path-crossing著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819class Solution &#123;public: bool isPathCrossing(string path) &#123; set&lt;pair&lt;int,int&gt;&gt; s; s.insert(&#123;0,0&#125;); int x = 0, y = 0; for(char c : path)&#123; switch(c)&#123; case 'N' : y++; break; case 'S' : y--; break; case 'W' : x--; break; case 'E' : x++; break; &#125; if(s.find(&#123;x,y&#125;) != s.end())return true; else s.insert(&#123;x,y&#125;); &#125; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1491]]></title>
    <url>%2Fp%2Faa9d.html</url>
    <content type="text"><![CDATA[1491. 去掉最低工资和最高工资后的工资平均值难度: easy 给你一个整数数组 salary ，数组里每个数都是 唯一 的，其中 salary[i] 是第 i 个员工的工资。 请你返回去掉最低工资和最高工资以后，剩下员工工资的平均值。 示例 1： 1234输入：salary = [4000,3000,1000,2000]输出：2500.00000解释：最低工资和最高工资分别是 1000 和 4000 。去掉最低工资和最高工资以后的平均工资是 (2000+3000)/2= 2500 示例 2： 1234输入：salary = [1000,2000,3000]输出：2000.00000解释：最低工资和最高工资分别是 1000 和 3000 。去掉最低工资和最高工资以后的平均工资是 (2000)/1= 2000 示例 3： 12输入：salary = [6000,5000,4000,3000,2000,1000]输出：3500.00000 示例 4： 12输入：salary = [8000,9000,2000,3000,6000,1000]输出：4750.00000 提示： 3 &lt;= salary.length &lt;= 100 10^3 &lt;= salary[i] &lt;= 10^6 salary[i] 是唯一的。 与真实值误差在 10^-5 以内的结果都将视为正确答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/average-salary-excluding-the-minimum-and-maximum-salary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213class Solution &#123;public: double average(vector&lt;int&gt;&amp; salary) &#123; double sum = 0; int maxx = salary[0], minn = salary[0]; for(int s : salary)&#123; maxx = maxx &lt; s ? s : maxx; minn = minn &gt; s ? s : minn; sum += s; &#125; return (sum - maxx - minn) / (salary.size() * 1.0 - 2); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 36]]></title>
    <url>%2Fp%2F969.html</url>
    <content type="text"><![CDATA[36. 有效的数独难度: medium 判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。 数字 1-9 在每一行只能出现一次。 数字 1-9 在每一列只能出现一次。 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。 上图是一个部分填充的有效的数独。 数独部分空格内已填入了数字，空白格用 &#39;.&#39; 表示。 示例 1: 12345678910111213输入:[ [&quot;5&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: true 示例 2: 123456789101112131415输入:[ [&quot;8&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;,&quot;9&quot;,&quot;5&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;9&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;], [&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;3&quot;], [&quot;4&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;3&quot;,&quot;.&quot;,&quot;.&quot;,&quot;1&quot;], [&quot;7&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;6&quot;], [&quot;.&quot;,&quot;6&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;2&quot;,&quot;8&quot;,&quot;.&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;4&quot;,&quot;1&quot;,&quot;9&quot;,&quot;.&quot;,&quot;.&quot;,&quot;5&quot;], [&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;.&quot;,&quot;8&quot;,&quot;.&quot;,&quot;.&quot;,&quot;7&quot;,&quot;9&quot;]]输出: false解释: 除了第一行的第一个数字从 5 改为 8 以外，空格内其他数字均与 示例1 相同。 但由于位于左上角的 3x3 宫内有两个 8 存在, 因此这个数独是无效的。 说明: 一个有效的数独（部分已被填充）不一定是可解的。 只需要根据以上规则，验证已经填入的数字是否有效即可。 给定数独序列只包含数字 1-9 和字符 &#39;.&#39; 。 给定数独永远是 9x9 形式的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-sudoku著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445class Solution &#123;public: bool isValidSudoku(vector&lt;vector&lt;char&gt;&gt;&amp; board) &#123; unordered_set&lt;int&gt; s; int temp; for(int i = 0; i &lt; 9; i++)&#123; s.clear(); for(int j = 0; j &lt; 9; j++)&#123; if(board[i][j] &gt;= '0' &amp;&amp; board[i][j] &lt;= '9')&#123; temp = board[i][j] - '0'; if(s.find(temp) != s.end())return false; else s.insert(temp); &#125; &#125; &#125; for(int i = 0; i &lt; 9; i++)&#123; s.clear(); for(int j = 0; j &lt; 9; j++)&#123; if(board[j][i] &gt;= '0' &amp;&amp; board[j][i] &lt;= '9')&#123; temp = board[j][i] - '0'; if(s.find(temp) != s.end())return false; else s.insert(temp); &#125; &#125; &#125; int tx,ty; for(int i = 0; i &lt; 3; i++)&#123; for(int j = 0; j &lt; 3; j++)&#123; s.clear(); for(int ki = 0; ki &lt; 3; ki++)&#123; for(int kj = 0; kj &lt; 3; kj++)&#123; tx = i * 3 + ki; ty = j * 3 + kj; if(board[tx][ty] &gt;= '0' &amp;&amp; board[tx][ty] &lt;= '9')&#123; temp = board[tx][ty] - '0'; if(s.find(temp) != s.end())return false; else s.insert(temp); &#125; &#125; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 63]]></title>
    <url>%2Fp%2F5aaa.html</url>
    <content type="text"><![CDATA[63. 不同路径 II难度: medium 一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。 机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。 现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？ 网格中的障碍物和空位置分别用 1 和 0 来表示。 说明：*m 和 n* 的值均不超过 100。 示例 1: 123456789101112输入:[ [0,0,0], [0,1,0], [0,0,0]]输出: 2解释:3x3 网格的正中间有一个障碍物。从左上角到右下角一共有 2 条不同的路径：1. 向右 -&gt; 向右 -&gt; 向下 -&gt; 向下2. 向下 -&gt; 向下 -&gt; 向右 -&gt; 向右 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-paths-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324class Solution &#123;public: int uniquePathsWithObstacles(vector&lt;vector&lt;int&gt;&gt;&amp; obstacleGrid) &#123; if(obstacleGrid.empty() || obstacleGrid[0].empty())return 0; int m = obstacleGrid.size(), n = obstacleGrid[0].size(); vector&lt;vector&lt;int&gt;&gt; f(m + 1, vector&lt;int&gt;(n + 1,0)); f[0][0] = obstacleGrid[0][0] == 0 ? 1 : 0; for(int i = 1; i &lt; n; i++)&#123; if(!obstacleGrid[0][i])f[0][i] = f[0][i - 1]; else f[0][i] = 0; &#125; for(int i = 1; i &lt; m; i++)&#123; if(!obstacleGrid[i][0])f[i][0] = f[i - 1][0]; else f[i][0] = 0; &#125; for(int i = 1; i &lt; m; i++)&#123; for(int j = 1; j &lt; n; j++)&#123; if(!obstacleGrid[i][j])f[i][j] = f[i - 1][j] + f[i][j - 1]; else f[i][j] = 0; &#125; &#125; return f[m - 1][n - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 44]]></title>
    <url>%2Fp%2Ff8ea.html</url>
    <content type="text"><![CDATA[44. 通配符匹配难度: hard 给定一个字符串 (s) 和一个字符模式 (p) ，实现一个支持 &#39;?&#39; 和 &#39;*&#39; 的通配符匹配。 12&apos;?&apos; 可以匹配任何单个字符。&apos;*&apos; 可以匹配任意字符串（包括空字符串）。 两个字符串完全匹配才算匹配成功。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 ? 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;*&quot;输出: true解释: &apos;*&apos; 可以匹配任意字符串。 示例 3: 12345输入:s = &quot;cb&quot;p = &quot;?a&quot;输出: false解释: &apos;?&apos; 可以匹配 &apos;c&apos;, 但第二个 &apos;a&apos; 无法匹配 &apos;b&apos;。 示例 4: 12345输入:s = &quot;adceb&quot;p = &quot;*a*b&quot;输出: true解释: 第一个 &apos;*&apos; 可以匹配空字符串, 第二个 &apos;*&apos; 可以匹配字符串 &quot;dce&quot;. 示例 5: 1234输入:s = &quot;acdcb&quot;p = &quot;a*c?b&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/wildcard-matching著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处 AC代码123456789101112131415161718192021class Solution &#123;public: bool isMatch(string s, string p) &#123; int slen = s.size(); int plen = p.size(); vector&lt;vector&lt;bool&gt;&gt; dp(slen + 1, vector&lt;bool&gt;(plen + 1, false)); dp[0][0] = true; for(int i = 1; i &lt;= plen; i++)&#123; if(p[i - 1] == '*')dp[0][i] = dp[0][i - 1]; &#125; for(int i = 1; i &lt;= slen; i++)&#123; for(int j = 1; j &lt;= plen; j++)&#123; if(p[j - 1] == '*') dp[i][j] = dp[i - 1][j] || dp[i][j - 1]; else dp[i][j] = dp[i - 1][j - 1] &amp;&amp; (s[i - 1] == p[j - 1] || p[j - 1] == '?'); &#125; &#125; return dp[slen][plen]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>回溯算法</tag>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 32]]></title>
    <url>%2Fp%2Fca68.html</url>
    <content type="text"><![CDATA[32. 最长有效括号难度: hard 给定一个只包含 &#39;(&#39; 和 &#39;)&#39; 的字符串，找出最长的包含有效括号的子串的长度。 示例 1: 123输入: &quot;(()&quot;输出: 2解释: 最长有效括号子串为 &quot;()&quot; 示例 2: 123输入: &quot;)()())&quot;输出: 4解释: 最长有效括号子串为 &quot;()()&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-valid-parentheses著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码子串$\neq$字序列 123456789101112131415161718class Solution &#123;public: int longestValidParentheses(string s) &#123; int sum = 0; s = ')' + s; vector&lt;int&gt; dp(s.length(),0); for(int i = 1; i &lt; s.length(); i++)&#123; if(s[i] == ')')&#123; if(s[i - 1 - dp[i-1]] == '(')&#123; dp[i] = dp[i-1] + 2; dp[i] += dp[i - dp[i]]; &#125; &#125; sum = max(sum,dp[i]); &#125; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 108]]></title>
    <url>%2Fp%2F9c6a.html</url>
    <content type="text"><![CDATA[108. 将有序数组转换为二叉搜索树难度: easy 将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。 本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。 示例: 123456789给定有序数组: [-10,-3,0,5,9],一个可能的答案是：[0,-3,9,-10,null,5]，它可以表示下面这个高度平衡二叉搜索树： 0 / \ -3 9 / / -10 5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) &#123; return Process(nums,0,nums.size() - 1); &#125; TreeNode* Process(vector&lt;int&gt;&amp; nums, int left,int right)&#123; if(left &gt; right)return NULL; int mid = left + (right - left) / 2; TreeNode* middle = new TreeNode(nums[mid]); middle-&gt;left = Process(nums,left,mid - 1); middle-&gt;right = Process(nums,mid + 1,right); return middle; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 215]]></title>
    <url>%2Fp%2Fc95a.html</url>
    <content type="text"><![CDATA[215. 数组中的第K个最大元素难度: medium 在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。 示例 1: 12输入: [3,2,1,5,6,4] 和 k = 2输出: 5 示例 2: 12输入: [3,2,3,1,2,4,5,5,6] 和 k = 4输出: 4 说明: 你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/kth-largest-element-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456class Solution &#123;public: int findKthLargest(vector&lt;int&gt;&amp; nums, int k) &#123; return sort(nums.begin(), nums.end(), greater&lt;int&gt;()), nums[k - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>堆</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 209]]></title>
    <url>%2Fp%2F5c5b.html</url>
    <content type="text"><![CDATA[209. 长度最小的子数组难度: medium 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的连续子数组，并返回其长度。如果不存在符合条件的连续子数组，返回 0。 示例: 123输入: s = 7, nums = [2,3,1,2,4,3]输出: 2解释: 子数组 [4,3] 是该条件下的长度最小的连续子数组。 进阶: 如果你已经完成了O(n) 时间复杂度的解法, 请尝试 O(n log n) 时间复杂度的解法。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819class Solution &#123;public: int minSubArrayLen(int s, vector&lt;int&gt;&amp; nums) &#123; int len = nums.size(); int left = 0, right = 0; int res = len + 1; int sum = 0; while(right &lt; len)&#123; while(sum &lt; s &amp;&amp; right &lt; len)&#123; sum += nums[right++]; &#125; while(sum &gt;= s)&#123; res = min(res, right - left); sum -= nums[left++]; &#125; &#125; return res == len + 1 ? 0 : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 41]]></title>
    <url>%2Fp%2Ffb2a.html</url>
    <content type="text"><![CDATA[41. 缺失的第一个正数难度: hard 给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。 示例 1: 12输入: [1,2,0]输出: 3 示例 2: 12输入: [3,4,-1,1]输出: 2 示例 3: 12输入: [7,8,9,11,12]输出: 1 提示： 你的算法的时间复杂度应为O(n)，并且只能使用常数级别的额外空间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/first-missing-positive著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路$Position_i$放元素$i +1$,第一次通过swap换位置，第二次遍历找到缺失值。 12345678910111213141516class Solution &#123;public: int firstMissingPositive(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); for(int i = 0; i &lt; n; i++)&#123; while(nums[i] &gt; 0 &amp;&amp; nums[i] &lt;= n &amp;&amp; nums[nums[i] - 1] != nums[i])&#123; swap(nums[nums[i] - 1],nums[i]); &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; if(nums[i] != i + 1) return i + 1; &#125; return n + 1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题 02.01]]></title>
    <url>%2Fp%2F57b8.html</url>
    <content type="text"><![CDATA[面试题 02.01. 移除重复节点难度: easy 编写代码，移除未排序链表中的重复节点。保留最开始出现的节点。 示例1: 12输入：[1, 2, 3, 3, 2, 1]输出：[1, 2, 3] 示例2: 12输入：[1, 1, 1, 1, 2]输出：[1, 2] 提示： 链表长度在[0, 20000]范围内。 链表元素在[0, 20000]范围内。 进阶： 如果不得使用临时缓冲区，该怎么解决？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/remove-duplicate-node-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码基础题 123456789101112131415161718192021222324252627/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* removeDuplicateNodes(ListNode* head) &#123; unordered_set&lt;int&gt; s; ListNode *cur = new ListNode(-1); ListNode *dummy = cur; while(head)&#123; if(s.find(head-&gt;val) == s.end())&#123; cur-&gt;next = head; cur = cur-&gt;next; s.insert(head-&gt;val); &#125;else&#123; cur-&gt;next = NULL; &#125; head = head-&gt;next; &#125; return dummy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>程序员面试金典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 139]]></title>
    <url>%2Fp%2Facab.html</url>
    <content type="text"><![CDATA[139. 单词拆分难度: medium 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。 示例 1： 123输入: s = &quot;leetcode&quot;, wordDict = [&quot;leet&quot;, &quot;code&quot;]输出: true解释: 返回 true 因为 &quot;leetcode&quot; 可以被拆分成 &quot;leet code&quot;。 示例 2： 1234输入: s = &quot;applepenapple&quot;, wordDict = [&quot;apple&quot;, &quot;pen&quot;]输出: true解释: 返回 true 因为 &quot;applepenapple&quot; 可以被拆分成 &quot;apple pen apple&quot;。 注意你可以重复使用字典中的单词。 示例 3： 12输入: s = &quot;catsandog&quot;, wordDict = [&quot;cats&quot;, &quot;dog&quot;, &quot;sand&quot;, &quot;and&quot;, &quot;cat&quot;]输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-break/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718class Solution &#123;public: bool wordBreak(string s, vector&lt;string&gt;&amp; wordDict) &#123; unordered_set&lt;string&gt; Dict; for(string word : wordDict)Dict.insert(word); vector&lt;bool&gt; dp(s.size() + 1); dp[0] = true; for(int i = 0; i &lt;= s.size(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(dp[j] &amp;&amp; Dict.find(s.substr(j, i - j)) != Dict.end()) &#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.size()]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 16]]></title>
    <url>%2Fp%2F6968.html</url>
    <content type="text"><![CDATA[16. 最接近的三数之和难度: medium 给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。 示例： 123输入：nums = [-1,2,1,-4], target = 1输出：2解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。 提示： 3 &lt;= nums.length &lt;= 10^3 -10^3 &lt;= nums[i] &lt;= 10^3 -10^4 &lt;= target &lt;= 10^4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum-closest著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920212223242526class Solution &#123;public: int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123; sort(nums.begin(),nums.end()); int closest = nums[0] + nums[1] + nums[2]; int diff = abs(closest - target); for(int i = 0; i &lt; nums.size() - 2; i++)&#123; if(nums[i] * 3 &gt; target)&#123; return min(closest, nums[i] + nums[i + 1] + nums[i + 2]); &#125; int left = i + 1, right = nums.size() - 1; while(left &lt; right)&#123; int sum = nums[i] + nums[left] + nums[right]; if(sum &lt; target)left++; else if(sum &gt; target) right--; else return sum; int subdiff = abs(sum - target); if(subdiff &lt; diff)&#123; diff = subdiff; closest = sum; &#125; &#125; &#125; return closest; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 67]]></title>
    <url>%2Fp%2F99ab.html</url>
    <content type="text"><![CDATA[67. 二进制求和难度: easy 给你两个二进制字符串，返回它们的和（用二进制表示）。 输入为 非空 字符串且只包含数字 1 和 0。 示例 1: 12输入: a = &quot;11&quot;, b = &quot;1&quot;输出: &quot;100&quot; 示例 2: 12输入: a = &quot;1010&quot;, b = &quot;1011&quot;输出: &quot;10101&quot; 提示： 每个字符串仅由字符 &#39;0&#39; 或 &#39;1&#39; 组成。 1 &lt;= a.length, b.length &lt;= 10^4 字符串如果不是 &quot;0&quot; ，就都不含前导零。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/add-binary著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617class Solution &#123;public: string addBinary(string a, string b) &#123; string res = ""; int alen = a.size() - 1; int blen = b.size() - 1; int carry = 0; while(alen &gt;= 0 || blen &gt;= 0)&#123; int as = alen &gt;= 0 ? a[alen--] - '0' : 0; int bs = blen &gt;= 0 ? b[blen--] - '0' : 0; int s = as + bs + carry; res = to_string(s % 2) + res; carry = s / 2; &#125; return carry &gt; 0 ? '1' + res : res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>数字</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题 16.18]]></title>
    <url>%2Fp%2F3145.html</url>
    <content type="text"><![CDATA[面试题 16.18. 模式匹配难度: medium 你有两个字符串，即pattern和value。 pattern字符串由字母&quot;a&quot;和&quot;b&quot;组成，用于描述字符串中的模式。例如，字符串&quot;catcatgocatgo&quot;匹配模式&quot;aabab&quot;（其中&quot;cat&quot;是&quot;a&quot;，&quot;go&quot;是&quot;b&quot;），该字符串也匹配像&quot;a&quot;、&quot;ab&quot;和&quot;b&quot;这样的模式。但需注意&quot;a&quot;和&quot;b&quot;不能同时表示相同的字符串。编写一个方法判断value字符串是否匹配pattern字符串。 示例 1： 12输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatdog&quot;输出： true 示例 2： 12输入： pattern = &quot;abba&quot;, value = &quot;dogcatcatfish&quot;输出： false 示例 3： 12输入： pattern = &quot;aaaa&quot;, value = &quot;dogcatcatdog&quot;输出： false 示例 4： 123输入： pattern = &quot;abba&quot;, value = &quot;dogdogdogdog&quot;输出： true解释： &quot;a&quot;=&quot;dogdog&quot;,b=&quot;&quot;，反之也符合规则 提示： 0 &lt;= len(pattern) &lt;= 1000 0 &lt;= len(value) &lt;= 1000 你可以假设pattern只包含字母&quot;a&quot;和&quot;b&quot;，value仅包含小写字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/pattern-matching-lcci著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码难度一般吧，就是细节好多。。。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980class Solution &#123;public: bool patternMatching(string pattern, string value) &#123; int vlen = value.size(); int a = 0, b = 0; for(char p : pattern)&#123; if(p == 'a')a++; else if(p == 'b')b++; &#125; if(!a &amp;&amp; !b)&#123; if(value != "") return false; else return true; &#125; else if(!a || !b)&#123; if(value == "")return true; a = max(a,b); return checkAB(value,a); &#125; else&#123; if(value.size() != 0 &amp;&amp; checkAB(value,a)) return true; if(value.size() != 0 &amp;&amp; checkAB(value,b)) return true; int ka = 1, kb = 1; for(;ka * a &lt; vlen;)&#123; if((vlen - ka * a) % b)&#123; ka++; continue; &#125; kb = (vlen - ka * a) / b; if(check(ka,kb,pattern,value)) return true; ka++; &#125; &#125; return false; &#125; bool checkAB(string val, int c)&#123; if(val.size() % c)return false; int k = val.size() / c; string sub = val.substr(0,k); for(int i = k; i &lt; val.size(); i += k)&#123; if(val.substr(i,k) != sub) return false; &#125; return true; &#125; bool check(int ka,int kb, string pattern, string value)&#123; int ina = -1, inb = -1; int index = 0; int idx = 0; while(ina == -1 || inb == -1)&#123; if(pattern[index] == 'a')&#123; if(ina == -1)&#123; ina = idx; &#125; idx += ka; &#125;else if(pattern[index] == 'b')&#123; if(inb == -1)&#123; inb = idx; &#125; idx += kb; &#125; index++; &#125; string sa = value.substr(ina,ka); string sb = value.substr(inb,kb); string res = ""; for(char p : pattern)&#123; if(p == 'a')res += sa; else if(p == 'b')res += sb; &#125; return res == value; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>程序员面试金典</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 124]]></title>
    <url>%2Fp%2Ff96b.html</url>
    <content type="text"><![CDATA[124. 二叉树中的最大路径和难度: hard 给定一个非空二叉树，返回其最大路径和。 本题中，路径被定义为一条从树中任意节点出发，达到任意节点的序列。该路径至少包含一个节点，且不一定经过根节点。 示例 1: 1234567输入: [1,2,3] 1 / \ 2 3输出: 6 示例 2: 123456789输入: [-10,9,20,null,null,15,7] -10 / \ 9 20 / \ 15 7输出: 42 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-maximum-path-sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int ans; int maxPathSum(TreeNode* root) &#123; ans = root-&gt;val; process(root); return ans; &#125; int process(TreeNode* root)&#123; if(!root)return 0; int leftSum = max(0,process(root-&gt;left)); int rightSum = max(0,process(root-&gt;right)); ans= max(ans,leftSum + rightSum + root-&gt;val); return root-&gt;val + max(leftSum,rightSum); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 10]]></title>
    <url>%2Fp%2F6be8.html</url>
    <content type="text"><![CDATA[10. 正则表达式匹配难度: hard 给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 &#39;.&#39; 和 &#39;*&#39; 的正则表达式匹配。 12&apos;.&apos; 匹配任意单个字符&apos;*&apos; 匹配零个或多个前面的那一个元素 所谓匹配，是要涵盖 整个 字符串 s的，而不是部分字符串。 说明: s 可能为空，且只包含从 a-z 的小写字母。 p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1: 12345输入:s = &quot;aa&quot;p = &quot;a&quot;输出: false解释: &quot;a&quot; 无法匹配 &quot;aa&quot; 整个字符串。 示例 2: 12345输入:s = &quot;aa&quot;p = &quot;a*&quot;输出: true解释: 因为 &apos;*&apos; 代表可以匹配零个或多个前面的那一个元素, 在这里前面的元素就是 &apos;a&apos;。因此，字符串 &quot;aa&quot; 可被视为 &apos;a&apos; 重复了一次。 示例 3: 12345输入:s = &quot;ab&quot;p = &quot;.*&quot;输出: true解释: &quot;.*&quot; 表示可匹配零个或多个（&apos;*&apos;）任意字符（&apos;.&apos;）。 示例 4: 12345输入:s = &quot;aab&quot;p = &quot;c*a*b&quot;输出: true解释: 因为 &apos;*&apos; 表示零个或多个，这里 &apos;c&apos; 为 0 个, &apos;a&apos; 被重复一次。因此可以匹配字符串 &quot;aab&quot;。 示例 5: 1234输入:s = &quot;mississippi&quot;p = &quot;mis*is*p*.&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/regular-expression-matching著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910class Solution &#123;public: bool isMatch(string s, string p) &#123; if(p.empty())return s.empty(); if(p.size() &gt; 1 &amp;&amp; p[1] == '*') return isMatch(s,p.substr(2)) || (!s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(s.substr(1),p)); else return !s.empty() &amp;&amp; (s[0] == p[0] || p[0] == '.') &amp;&amp; isMatch(s.substr(1), p.substr(1)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>回溯算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 125]]></title>
    <url>%2Fp%2F39aa.html</url>
    <content type="text"><![CDATA[125. 验证回文串难度: easy 给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 说明：本题中，我们将空字符串定义为有效的回文串。 示例 1: 12输入: &quot;A man, a plan, a canal: Panama&quot;输出: true 示例 2: 12输入: &quot;race a car&quot;输出: false 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920212223242526class Solution &#123;public: bool isPalindrome(string s) &#123; string temp = ""; for(char c : s)&#123; if(valid(c))&#123; temp += c; &#125; &#125; if(temp.size() &lt;= 1)return true; int l = 0, r = temp.size() - 1; while(l &lt; r)&#123; if(tolower(temp[l]) != tolower(temp[r])) return false; l++; r--; &#125; return true; &#125; bool valid(char c)&#123; if(c &gt;= '0' &amp;&amp; c &lt;= '9')return true; if(c &gt;= 'a' &amp;&amp; c &lt;= 'z')return true; if(c &gt;= 'A' &amp;&amp; c &lt;= 'Z')return true; return false; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1028]]></title>
    <url>%2Fp%2F5d1b.html</url>
    <content type="text"><![CDATA[1028. 从先序遍历还原二叉树难度: hard 我们从二叉树的根节点 root 开始进行深度优先搜索。 在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。 如果节点只有一个子节点，那么保证该子节点为左子节点。 给出遍历输出 S，还原树并返回其根节点 root。 示例 1： 12输入：&quot;1-2--3--4-5--6--7&quot;输出：[1,2,5,3,4,6,7] 示例 2： 12输入：&quot;1-2--3---4-5--6---7&quot;输出：[1,2,5,3,null,6,null,4,null,7] 示例 3： 12输入：&quot;1-401--349---90--88&quot;输出：[1,401,null,349,88,90] 提示： 原始树中的节点数介于 1 和 1000 之间。 每个节点的值介于 1 和 10 ^ 9 之间。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/recover-a-tree-from-preorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码map记录depth对应的结点 1234567891011121314151617181920212223242526272829303132/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* recoverFromPreorder(string S) &#123; int depth = 0; unordered_map&lt;int,TreeNode*&gt; mp; TreeNode *root = new TreeNode(stoi(S.substr(0))); mp[0] = root; for(int i = 1; i &lt; S.size(); i++)&#123; if(S[i] == '-')depth++; else if(depth &gt; 0)&#123; TreeNode *node = new TreeNode(stoi(S.substr(i))); if(mp[depth - 1]-&gt;left == NULL)&#123; mp[depth - 1]-&gt;left = node; &#125;else&#123; mp[depth - 1]-&gt;right = node; &#125; mp[depth] = node; depth = 0; &#125; &#125; return mp[0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先遍历</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1014]]></title>
    <url>%2Fp%2Fa81b.html</url>
    <content type="text"><![CDATA[1014. 最佳观光组合难度: hard 给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。 一对景点（i &lt; j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。 返回一对观光景点能取得的最高分。 示例： 123输入：[8,1,5,2,6]输出：11解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11 提示： 2 &lt;= A.length &lt;= 50000 1 &lt;= A[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotting-oranges著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112class Solution &#123;public: int maxScoreSightseeingPair(vector&lt;int&gt;&amp; A) &#123; int ans = 0; int aiplusi = A[0] + 0; for(int i = 1; i &lt; A.size(); i++)&#123; ans = max(ans, aiplusi + A[i] - i); aiplusi = max(aiplusi, A[i] + i); &#125; return ans; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 297]]></title>
    <url>%2Fp%2Fc8dc.html</url>
    <content type="text"><![CDATA[297. 二叉树的序列化与反序列化难度: hard 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。 示例: 123456789你可以将以下二叉树： 1 / \ 2 3 / \ 4 5序列化为 &quot;[1,2,3,null,null,4,5]&quot; 提示: 这与 LeetCode 目前使用的方式一致，详情请参阅 LeetCode 序列化二叉树的格式。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。 说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Codec &#123;public: // Encodes a tree to a single string. string serialize(TreeNode* root) &#123; ostringstream out; serializeProcess(root,out); return out.str(); &#125; // Decodes your encoded data to tree. TreeNode* deserialize(string data) &#123; istringstream in(data); return deserializeProcess(in); &#125;private: void serializeProcess(TreeNode *root, ostringstream &amp;out)&#123; if(root)&#123; out&lt;&lt;root-&gt;val&lt;&lt;" "; serializeProcess(root-&gt;left,out); serializeProcess(root-&gt;right,out); &#125;else&#123; out&lt;&lt;"# "; &#125; &#125; TreeNode* deserializeProcess(istringstream &amp;in)&#123; string val; in&gt;&gt;val; if(val == "#")return nullptr; TreeNode *root = new TreeNode(stoi(val)); root-&gt;left = deserializeProcess(in); root-&gt;right = deserializeProcess(in); return root; &#125;&#125;;// Your Codec object will be instantiated and called as such:// Codec codec;// codec.deserialize(codec.serialize(root));]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 14]]></title>
    <url>%2Fp%2Fa8e9.html</url>
    <content type="text"><![CDATA[14. 最长公共前缀难度: easy 编写一个函数来查找字符串数组中的最长公共前缀。 如果不存在公共前缀，返回空字符串 &quot;&quot;。 示例 1: 12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot; 示例 2: 123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。 说明: 所有输入只包含小写字母 a-z 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-common-prefix著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011class Solution &#123;public: string longestCommonPrefix(vector&lt;string&gt;&amp; strs) &#123; if(strs.empty())return ""; sort(strs.begin(),strs.end()); int len = min(strs[0].size(),strs.back().size()); int i = 0; while(i &lt; len &amp;&amp; strs[0][i] == strs.back()[i])i++; return strs[0].substr(0,i); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1300]]></title>
    <url>%2Fp%2Ffbeb.html</url>
    <content type="text"><![CDATA[1300. 转变数组后最接近目标值的数组和难度: medium 给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近 target （最接近表示两者之差的绝对值最小）。 如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。 请注意，答案不一定是 arr 中的数字。 示例 1： 123输入：arr = [4,9,3], target = 10输出：3解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。 示例 2： 12输入：arr = [2,3,5], target = 10输出：5 示例 3： 12输入：arr = [60864,25176,27249,21296,20204], target = 56803输出：11361 提示： 1 &lt;= arr.length &lt;= 10^4 1 &lt;= arr[i], target &lt;= 10^5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sum-of-mutated-array-closest-to-target著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718class Solution &#123;public: int findBestValue(vector&lt;int&gt;&amp; arr, int target) &#123; sort(arr.begin(),arr.end()); int sum = 0; int len = (int)arr.size(); for(int i = 0; i &lt; len; i++)&#123; int x = (target - sum) / (len - i); if(x &lt; arr[i])&#123; double y = ((double)(target - sum)) / (len - i); if(y - x &gt; 0.5)return x + 1; else return x; &#125; sum += arr[i]; &#125; return arr[len - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 70]]></title>
    <url>%2Fp%2Fcbeb.html</url>
    <content type="text"><![CDATA[70. 爬楼梯难度: easy 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？ 注意：给定 n 是一个正整数。 示例 1： 12345输入： 2输出： 2解释： 有两种方法可以爬到楼顶。1. 1 阶 + 1 阶2. 2 阶 示例 2： 123456输入： 3输出： 3解释： 有三种方法可以爬到楼顶。1. 1 阶 + 1 阶 + 1 阶2. 1 阶 + 2 阶3. 2 阶 + 1 阶 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/climbing-stairs著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码滚动数组，常见，O(1)空间 1234567891011121314class Solution &#123;public: int climbStairs(int n) &#123; if(n == 1)return 1; if(n == 2)return 2; int pre = 1; int cur = 2; for(int i = 3; i &lt;= n; i++)&#123; cur = pre + cur; pre = cur - pre; &#125; return cur; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 15]]></title>
    <url>%2Fp%2F6828.html</url>
    <content type="text"><![CDATA[15. 三数之和难度: medium 给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 示例： 1234567给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/3sum著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123; vector&lt;vector&lt;int&gt;&gt; res; sort(nums.begin(), nums.end()); if(nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return &#123;&#125;; for(int i = 0; i &lt; (int)nums.size() - 2; i++)&#123; if(nums[i] &gt; 0) break; if(i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) continue; int tempTarget = 0 - nums[i]; int j = i + 1, k = (int)nums.size() - 1; while(j &lt; k)&#123; if(nums[j] + nums[k] == tempTarget)&#123; res.push_back(&#123;nums[i], nums[j], nums[k]&#125;); while(j &lt; k &amp;&amp; nums[j] == nums[j + 1]) j++; while(j &lt; k &amp;&amp; nums[k] == nums[k - 1]) k--; j++; k--; &#125;else if(nums[j] + nums[k] &lt; tempTarget)&#123; j++; &#125;else&#123; k--; &#125; &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 739]]></title>
    <url>%2Fp%2Fad4b.html</url>
    <content type="text"><![CDATA[739. 每日温度难度: medium 根据每日 气温 列表，请重新生成一个列表，对应位置的输出是需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0来代替。 例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。 提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/daily-temperatures著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 12345678910111213141516class Solution &#123;public: vector&lt;int&gt; dailyTemperatures(vector&lt;int&gt;&amp; T) &#123; int len = T.size(); vector&lt;int&gt; res(len, 0); stack&lt;int&gt; stk; for(int i = 0; i &lt; len; i++)&#123; while(!stk.empty() &amp;&amp; T[i] &gt; T[stk.top()])&#123; auto t = stk.top();stk.pop(); res[t] = i - t; &#125; stk.push(i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 9]]></title>
    <url>%2Fp%2Faeab.html</url>
    <content type="text"><![CDATA[9. 回文数难度: easy 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。 示例 1: 12输入: 121输出: true 示例 2: 123输入: -121输出: false解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。 示例 3: 123输入: 10输出: false解释: 从右向左读, 为 01 。因此它不是一个回文数。 进阶: 你能不将整数转为字符串来解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/palindrome-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112class Solution &#123;public: bool isPalindrome(int x) &#123; if(x &lt; 0 || x % 10 == 0 &amp;&amp; x != 0)return false; int revertNum = 0; while(x &gt; revertNum)&#123; revertNum = revertNum * 10 + x % 10; x /= 10; &#125; return x == revertNum || x == revertNum / 10; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题46]]></title>
    <url>%2Fp%2F82b.html</url>
    <content type="text"><![CDATA[面试题46. 把数字翻译成字符串难度: medium 给定一个数字，我们按照如下规则把它翻译为字符串：0 翻译成 “a” ，1 翻译成 “b”，……，11 翻译成 “l”，……，25 翻译成 “z”。一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。 示例 1: 123输入: 12258输出: 5解释: 12258有5种不同的翻译，分别是&quot;bccfi&quot;, &quot;bwfi&quot;, &quot;bczi&quot;, &quot;mcfi&quot;和&quot;mzi&quot; 提示： $0 \leq num &lt; 2^{31}$ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920class Solution &#123;public: int translateNum(int num) &#123; string str = to_string(num); int len = str.length(); vector&lt;int&gt; dp(len + 1); dp[0] = 1; for(int i = 1; i &lt; len; i++)&#123; if((str[i - 1] == '1' &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') || (str[i - 1] == '2' &amp;&amp; str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '5'))&#123; if(i == 1) dp[i] = dp[i - 1] + 1; else dp[i] = dp[i - 1] + dp[i - 2]; &#125;else&#123; dp[i] = dp[i - 1]; &#125; &#125; return dp[len - 1]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 990]]></title>
    <url>%2Fp%2Fc8ec.html</url>
    <content type="text"><![CDATA[990. 等式方程的可满足性难度: medium 给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一：&quot;a==b&quot;或 &quot;a!=b&quot;。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。 只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。 示例 1： 123输入：[&quot;a==b&quot;,&quot;b!=a&quot;]输出：false解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。 示例 2： 123输出：[&quot;b==a&quot;,&quot;a==b&quot;]输入：true解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。 示例 3： 12输入：[&quot;a==b&quot;,&quot;b==c&quot;,&quot;a==c&quot;]输出：true 示例 4： 12输入：[&quot;a==b&quot;,&quot;b!=c&quot;,&quot;c==a&quot;]输出：false 示例 5： 12输入：[&quot;c==c&quot;,&quot;b==d&quot;,&quot;x!=z&quot;]输出：true 提示： 1 &lt;= equations.length &lt;= 500 equations[i].length == 4 equations[i][0] 和 equations[i][3] 是小写字母 equations[i][1] 要么是 &#39;=&#39;，要么是 &#39;!&#39; equations[i][2] 是 &#39;=&#39; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/satisfiability-of-equality-equations著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142class UnionFind&#123;public: vector&lt;int&gt; p; UnionFind()&#123; p.resize(26); iota(p.begin(),p.end(),0); &#125; int find(int index)&#123; if(index == p[index])&#123; return index; &#125; p[index] = find(p[index]); return p[index]; &#125; void unite(int in1,int in2)&#123; p[find(in1)] = find(in2); &#125;&#125;;class Solution &#123;public: bool equationsPossible(vector&lt;string&gt;&amp; equations) &#123; UnionFind uf; for(const string&amp; str : equations)&#123; if(str[1] == '=')&#123; int in1 = str[0] - 'a'; int in2 = str[3] - 'a'; uf.unite(in1,in2); &#125; &#125; for(const string&amp; str : equations)&#123; if(str[1] == '!')&#123; int in1 = str[0] - 'a'; int in2 = str[3] - 'a'; if(uf.find(in1) == uf.find(in2))&#123; return false; &#125; &#125; &#125; return true; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>并查集</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 126]]></title>
    <url>%2Fp%2F38ea.html</url>
    <content type="text"><![CDATA[126. 单词接龙 II难度: hard 给定两个单词（beginWord 和 endWord）和一个字典 wordList，找出所有从 beginWord 到 endWord 的最短转换序列。转换需遵循如下规则： 每次转换只能改变一个字母。 转换过程中的中间单词必须是字典中的单词。 说明: 如果不存在这样的转换序列，返回一个空列表。 所有单词具有相同的长度。 所有单词只由小写字母组成。 字典中不存在重复的单词。 你可以假设 beginWord 和 endWord 是非空的，且二者不相同。 示例 1: 12345678910输入:beginWord = &quot;hit&quot;,endWord = &quot;cog&quot;,wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]输出:[ [&quot;hit&quot;,&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;cog&quot;], [&quot;hit&quot;,&quot;hot&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]] 示例 2: 12345678输入:beginWord = &quot;hit&quot;endWord = &quot;cog&quot;wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]输出: []解释: endWord &quot;cog&quot; 不在字典中，所以不存在符合要求的转换序列。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/word-ladder-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码今天，不是出题人牛逼，就是我蒟蒻orz 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374class Solution &#123;public: unordered_map&lt;string,int&gt; wordId; vector&lt;string&gt; idWord; vector&lt;vector&lt;int&gt;&gt; edges; bool check(const string &amp;a, const string &amp;b)&#123; int diff = 0; for(int i = 0; i &lt; a.size() &amp;&amp; diff &lt; 2; i++)&#123; if(a[i] != b[i]) diff++; &#125; return diff == 1; &#125; vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; //存字符串和标记 int id = 0; for(auto word : wordList)&#123; if(!wordId.count(word))&#123; wordId[word] = id++; idWord.push_back(word); &#125; &#125; //可到达性初步判断 if(!wordId.count(endWord))return &#123;&#125;; //开始词填入词库 if(!wordId.count(beginWord))&#123; wordId[beginWord]=id++; idWord.push_back(beginWord); &#125; //建图，双向 edges.resize(idWord.size()); for(int i = 0; i &lt; idWord.size(); i++)&#123; for(int j = i + 1; j &lt; idWord.size(); j++)&#123; if(check(idWord[i],idWord[j]))&#123; edges[i].push_back(j); edges[j].push_back(i); &#125; &#125; &#125; //BFS int dest = wordId[endWord]; vector&lt;vector&lt;string&gt;&gt; res; queue&lt;vector&lt;int&gt;&gt; q; q.push(vector&lt;int&gt;&#123;wordId[beginWord]&#125;); vector&lt;int&gt; step(id,1&lt;&lt;20); step[wordId[beginWord]] = 0; while(!q.empty())&#123; vector&lt;int&gt; t = q.front();q.pop(); int cur = t.back(); if(cur == dest)&#123; //找到了 vector&lt;string&gt; ans; for(auto index : t)&#123; ans.push_back(idWord[index]); &#125; res.push_back(ans); &#125;else&#123; //继续找 for(int i = 0; i &lt; edges[cur].size(); i++)&#123; int next = edges[cur][i]; if(step[cur] + 1 &lt;= step[next])&#123; step[next] = step[cur] + 1; vector&lt;int&gt; tp(t); tp.push_back(next); q.push(tp); &#125; &#125; &#125; &#125; return res; &#125;&#125;; TLE代码。。。就是传值与传址的区别，主要还是算法垃圾吧，以后再改进 还有就是尽早跳出for的问题 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475class Solution &#123;public: unordered_map&lt;string,int&gt; wordId; vector&lt;string&gt; idWord; vector&lt;vector&lt;int&gt;&gt; edges; bool check(string a, string b)&#123; int diff = 0; for(int i = 0; i &lt; a.size() &amp;&amp; diff &lt; 2; i++)&#123; if(a[i] != b[i]) diff++; &#125; return diff == 1; &#125; vector&lt;vector&lt;string&gt;&gt; findLadders(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList) &#123; //存字符串和标记 int id = 0; for(auto word : wordList)&#123; if(!wordId.count(word))&#123; wordId[word] = id++; idWord.push_back(word); &#125; &#125; //可到达性初步判断 if(!wordId.count(endWord))return &#123;&#125;; //开始词填入词库 if(!wordId.count(beginWord))&#123; wordId[beginWord]=id++; idWord.push_back(beginWord); &#125; //建图，双向 edges.resize(idWord.size()); for(int i = 0; i &lt; idWord.size(); i++)&#123; for(int j = i + 1; j &lt; idWord.size(); j++)&#123; if(check(idWord[i],idWord[j]))&#123; edges[i].push_back(j); edges[j].push_back(i); &#125; &#125; &#125; //BFS int dest = wordId[endWord]; vector&lt;vector&lt;string&gt;&gt; res; queue&lt;vector&lt;int&gt;&gt; q; q.push(vector&lt;int&gt;&#123;wordId[beginWord]&#125;); vector&lt;int&gt; step(id,1&lt;&lt;20); step[wordId[beginWord]] = 0; while(!q.empty())&#123; vector&lt;int&gt; t = q.front();q.pop(); int cur = t.back(); if(cur == dest)&#123; //找到了 vector&lt;string&gt; ans; for(auto index : t)&#123; ans.push_back(idWord[index]); &#125; res.push_back(ans); &#125;else&#123; //继续找 int len = edges[cur].size(); for(int i = 0; i &lt; len; i++)&#123; int next = edges[cur][i]; if(step[cur] + 1 &lt;= step[next])&#123; step[next] = step[cur] + 1; vector&lt;int&gt; tp(t); tp.push_back(next); q.push(tp); &#125; &#125; &#125; &#125; return res; &#125;&#125;; 第二个代码TLE超时的样例，我吐了123&quot;nanny&quot;&quot;aloud&quot;[&quot;ricky&quot;,&quot;grind&quot;,&quot;cubic&quot;,&quot;panic&quot;,&quot;lover&quot;,&quot;farce&quot;,&quot;gofer&quot;,&quot;sales&quot;,&quot;flint&quot;,&quot;omens&quot;,&quot;lipid&quot;,&quot;briny&quot;,&quot;cloth&quot;,&quot;anted&quot;,&quot;slime&quot;,&quot;oaten&quot;,&quot;harsh&quot;,&quot;touts&quot;,&quot;stoop&quot;,&quot;cabal&quot;,&quot;lazed&quot;,&quot;elton&quot;,&quot;skunk&quot;,&quot;nicer&quot;,&quot;pesky&quot;,&quot;kusch&quot;,&quot;bused&quot;,&quot;kinda&quot;,&quot;tunis&quot;,&quot;enjoy&quot;,&quot;aches&quot;,&quot;prowl&quot;,&quot;babar&quot;,&quot;rooms&quot;,&quot;burst&quot;,&quot;slush&quot;,&quot;pines&quot;,&quot;urine&quot;,&quot;pinky&quot;,&quot;bayed&quot;,&quot;mania&quot;,&quot;light&quot;,&quot;flare&quot;,&quot;wares&quot;,&quot;women&quot;,&quot;verne&quot;,&quot;moron&quot;,&quot;shine&quot;,&quot;bluer&quot;,&quot;zeros&quot;,&quot;bleak&quot;,&quot;brief&quot;,&quot;tamra&quot;,&quot;vasts&quot;,&quot;jamie&quot;,&quot;lairs&quot;,&quot;penal&quot;,&quot;worst&quot;,&quot;yowls&quot;,&quot;pills&quot;,&quot;taros&quot;,&quot;addle&quot;,&quot;alyce&quot;,&quot;creep&quot;,&quot;saber&quot;,&quot;floyd&quot;,&quot;cures&quot;,&quot;soggy&quot;,&quot;vexed&quot;,&quot;vilma&quot;,&quot;cabby&quot;,&quot;verde&quot;,&quot;euler&quot;,&quot;cling&quot;,&quot;wanna&quot;,&quot;jenny&quot;,&quot;donor&quot;,&quot;stole&quot;,&quot;sakha&quot;,&quot;blake&quot;,&quot;sanes&quot;,&quot;riffs&quot;,&quot;forge&quot;,&quot;horus&quot;,&quot;sered&quot;,&quot;piked&quot;,&quot;prosy&quot;,&quot;wases&quot;,&quot;glove&quot;,&quot;onset&quot;,&quot;spake&quot;,&quot;benin&quot;,&quot;talks&quot;,&quot;sites&quot;,&quot;biers&quot;,&quot;wendy&quot;,&quot;dante&quot;,&quot;allan&quot;,&quot;haven&quot;,&quot;nears&quot;,&quot;shaka&quot;,&quot;sloth&quot;,&quot;perky&quot;,&quot;spear&quot;,&quot;spend&quot;,&quot;clint&quot;,&quot;dears&quot;,&quot;sadly&quot;,&quot;units&quot;,&quot;vista&quot;,&quot;hinds&quot;,&quot;marat&quot;,&quot;natal&quot;,&quot;least&quot;,&quot;bough&quot;,&quot;pales&quot;,&quot;boole&quot;,&quot;ditch&quot;,&quot;greys&quot;,&quot;slunk&quot;,&quot;bitch&quot;,&quot;belts&quot;,&quot;sense&quot;,&quot;skits&quot;,&quot;monty&quot;,&quot;yawns&quot;,&quot;music&quot;,&quot;hails&quot;,&quot;alien&quot;,&quot;gibes&quot;,&quot;lille&quot;,&quot;spacy&quot;,&quot;argot&quot;,&quot;wasps&quot;,&quot;drubs&quot;,&quot;poops&quot;,&quot;bella&quot;,&quot;clone&quot;,&quot;beast&quot;,&quot;emend&quot;,&quot;iring&quot;,&quot;start&quot;,&quot;darla&quot;,&quot;bells&quot;,&quot;cults&quot;,&quot;dhaka&quot;,&quot;sniff&quot;,&quot;seers&quot;,&quot;bantu&quot;,&quot;pages&quot;,&quot;fever&quot;,&quot;tacky&quot;,&quot;hoses&quot;,&quot;strop&quot;,&quot;climb&quot;,&quot;pairs&quot;,&quot;later&quot;,&quot;grant&quot;,&quot;raven&quot;,&quot;stael&quot;,&quot;drips&quot;,&quot;lucid&quot;,&quot;awing&quot;,&quot;dines&quot;,&quot;balms&quot;,&quot;della&quot;,&quot;galen&quot;,&quot;toned&quot;,&quot;snips&quot;,&quot;shady&quot;,&quot;chili&quot;,&quot;fears&quot;,&quot;nurse&quot;,&quot;joint&quot;,&quot;plump&quot;,&quot;micky&quot;,&quot;lions&quot;,&quot;jamal&quot;,&quot;queer&quot;,&quot;ruins&quot;,&quot;frats&quot;,&quot;spoof&quot;,&quot;semen&quot;,&quot;pulps&quot;,&quot;oldie&quot;,&quot;coors&quot;,&quot;rhone&quot;,&quot;papal&quot;,&quot;seals&quot;,&quot;spans&quot;,&quot;scaly&quot;,&quot;sieve&quot;,&quot;klaus&quot;,&quot;drums&quot;,&quot;tided&quot;,&quot;needs&quot;,&quot;rider&quot;,&quot;lures&quot;,&quot;treks&quot;,&quot;hares&quot;,&quot;liner&quot;,&quot;hokey&quot;,&quot;boots&quot;,&quot;primp&quot;,&quot;laval&quot;,&quot;limes&quot;,&quot;putts&quot;,&quot;fonda&quot;,&quot;damon&quot;,&quot;pikes&quot;,&quot;hobbs&quot;,&quot;specs&quot;,&quot;greet&quot;,&quot;ketch&quot;,&quot;braid&quot;,&quot;purer&quot;,&quot;tsars&quot;,&quot;berne&quot;,&quot;tarts&quot;,&quot;clean&quot;,&quot;grate&quot;,&quot;trips&quot;,&quot;chefs&quot;,&quot;timex&quot;,&quot;vicky&quot;,&quot;pares&quot;,&quot;price&quot;,&quot;every&quot;,&quot;beret&quot;,&quot;vices&quot;,&quot;jodie&quot;,&quot;fanny&quot;,&quot;mails&quot;,&quot;built&quot;,&quot;bossy&quot;,&quot;farms&quot;,&quot;pubic&quot;,&quot;gongs&quot;,&quot;magma&quot;,&quot;quads&quot;,&quot;shell&quot;,&quot;jocks&quot;,&quot;woods&quot;,&quot;waded&quot;,&quot;parka&quot;,&quot;jells&quot;,&quot;worse&quot;,&quot;diner&quot;,&quot;risks&quot;,&quot;bliss&quot;,&quot;bryan&quot;,&quot;terse&quot;,&quot;crier&quot;,&quot;incur&quot;,&quot;murky&quot;,&quot;gamed&quot;,&quot;edges&quot;,&quot;keens&quot;,&quot;bread&quot;,&quot;raced&quot;,&quot;vetch&quot;,&quot;glint&quot;,&quot;zions&quot;,&quot;porno&quot;,&quot;sizes&quot;,&quot;mends&quot;,&quot;ached&quot;,&quot;allie&quot;,&quot;bands&quot;,&quot;plank&quot;,&quot;forth&quot;,&quot;fuels&quot;,&quot;rhyme&quot;,&quot;wimpy&quot;,&quot;peels&quot;,&quot;foggy&quot;,&quot;wings&quot;,&quot;frill&quot;,&quot;edgar&quot;,&quot;slave&quot;,&quot;lotus&quot;,&quot;point&quot;,&quot;hints&quot;,&quot;germs&quot;,&quot;clung&quot;,&quot;limed&quot;,&quot;loafs&quot;,&quot;realm&quot;,&quot;myron&quot;,&quot;loopy&quot;,&quot;plush&quot;,&quot;volts&quot;,&quot;bimbo&quot;,&quot;smash&quot;,&quot;windy&quot;,&quot;sours&quot;,&quot;choke&quot;,&quot;karin&quot;,&quot;boast&quot;,&quot;whirr&quot;,&quot;tiber&quot;,&quot;dimes&quot;,&quot;basel&quot;,&quot;cutes&quot;,&quot;pinto&quot;,&quot;troll&quot;,&quot;thumb&quot;,&quot;decor&quot;,&quot;craft&quot;,&quot;tared&quot;,&quot;split&quot;,&quot;josue&quot;,&quot;tramp&quot;,&quot;screw&quot;,&quot;label&quot;,&quot;lenny&quot;,&quot;apses&quot;,&quot;slept&quot;,&quot;sikhs&quot;,&quot;child&quot;,&quot;bouts&quot;,&quot;cites&quot;,&quot;swipe&quot;,&quot;lurks&quot;,&quot;seeds&quot;,&quot;fists&quot;,&quot;hoard&quot;,&quot;steed&quot;,&quot;reams&quot;,&quot;spoil&quot;,&quot;diego&quot;,&quot;peale&quot;,&quot;bevel&quot;,&quot;flags&quot;,&quot;mazes&quot;,&quot;quart&quot;,&quot;snipe&quot;,&quot;latch&quot;,&quot;lards&quot;,&quot;acted&quot;,&quot;falls&quot;,&quot;busby&quot;,&quot;holed&quot;,&quot;mummy&quot;,&quot;wrong&quot;,&quot;wipes&quot;,&quot;carlo&quot;,&quot;leers&quot;,&quot;wails&quot;,&quot;night&quot;,&quot;pasty&quot;,&quot;eater&quot;,&quot;flunk&quot;,&quot;vedas&quot;,&quot;curse&quot;,&quot;tyros&quot;,&quot;mirth&quot;,&quot;jacky&quot;,&quot;butte&quot;,&quot;wired&quot;,&quot;fixes&quot;,&quot;tares&quot;,&quot;vague&quot;,&quot;roved&quot;,&quot;stove&quot;,&quot;swoon&quot;,&quot;scour&quot;,&quot;coked&quot;,&quot;marge&quot;,&quot;cants&quot;,&quot;comic&quot;,&quot;corns&quot;,&quot;zilch&quot;,&quot;typos&quot;,&quot;lives&quot;,&quot;truer&quot;,&quot;comma&quot;,&quot;gaily&quot;,&quot;teals&quot;,&quot;witty&quot;,&quot;hyper&quot;,&quot;croat&quot;,&quot;sways&quot;,&quot;tills&quot;,&quot;hones&quot;,&quot;dowel&quot;,&quot;llano&quot;,&quot;clefs&quot;,&quot;fores&quot;,&quot;cinch&quot;,&quot;brock&quot;,&quot;vichy&quot;,&quot;bleed&quot;,&quot;nuder&quot;,&quot;hoyle&quot;,&quot;slams&quot;,&quot;macro&quot;,&quot;arabs&quot;,&quot;tauts&quot;,&quot;eager&quot;,&quot;croak&quot;,&quot;scoop&quot;,&quot;crime&quot;,&quot;lurch&quot;,&quot;weals&quot;,&quot;fates&quot;,&quot;clipt&quot;,&quot;teens&quot;,&quot;bulls&quot;,&quot;domed&quot;,&quot;ghana&quot;,&quot;culls&quot;,&quot;frame&quot;,&quot;hanky&quot;,&quot;jared&quot;,&quot;swain&quot;,&quot;truss&quot;,&quot;drank&quot;,&quot;lobby&quot;,&quot;lumps&quot;,&quot;pansy&quot;,&quot;whews&quot;,&quot;saris&quot;,&quot;trite&quot;,&quot;weeps&quot;,&quot;dozes&quot;,&quot;jeans&quot;,&quot;flood&quot;,&quot;chimu&quot;,&quot;foxes&quot;,&quot;gelds&quot;,&quot;sects&quot;,&quot;scoff&quot;,&quot;poses&quot;,&quot;mares&quot;,&quot;famed&quot;,&quot;peers&quot;,&quot;hells&quot;,&quot;laked&quot;,&quot;zests&quot;,&quot;wring&quot;,&quot;steal&quot;,&quot;snoot&quot;,&quot;yodel&quot;,&quot;scamp&quot;,&quot;ellis&quot;,&quot;bandy&quot;,&quot;marry&quot;,&quot;jives&quot;,&quot;vises&quot;,&quot;blurb&quot;,&quot;relay&quot;,&quot;patch&quot;,&quot;haley&quot;,&quot;cubit&quot;,&quot;heine&quot;,&quot;place&quot;,&quot;touch&quot;,&quot;grain&quot;,&quot;gerry&quot;,&quot;badly&quot;,&quot;hooke&quot;,&quot;fuchs&quot;,&quot;savor&quot;,&quot;apron&quot;,&quot;judge&quot;,&quot;loren&quot;,&quot;britt&quot;,&quot;smith&quot;,&quot;tammy&quot;,&quot;altar&quot;,&quot;duels&quot;,&quot;huber&quot;,&quot;baton&quot;,&quot;dived&quot;,&quot;apace&quot;,&quot;sedan&quot;,&quot;basts&quot;,&quot;clark&quot;,&quot;mired&quot;,&quot;perch&quot;,&quot;hulks&quot;,&quot;jolly&quot;,&quot;welts&quot;,&quot;quack&quot;,&quot;spore&quot;,&quot;alums&quot;,&quot;shave&quot;,&quot;singe&quot;,&quot;lanny&quot;,&quot;dread&quot;,&quot;profs&quot;,&quot;skeet&quot;,&quot;flout&quot;,&quot;darin&quot;,&quot;newed&quot;,&quot;steer&quot;,&quot;taine&quot;,&quot;salvo&quot;,&quot;mites&quot;,&quot;rules&quot;,&quot;crash&quot;,&quot;thorn&quot;,&quot;olive&quot;,&quot;saves&quot;,&quot;yawed&quot;,&quot;pique&quot;,&quot;salon&quot;,&quot;ovens&quot;,&quot;dusty&quot;,&quot;janie&quot;,&quot;elise&quot;,&quot;carve&quot;,&quot;winds&quot;,&quot;abash&quot;,&quot;cheep&quot;,&quot;strap&quot;,&quot;fared&quot;,&quot;discs&quot;,&quot;poxed&quot;,&quot;hoots&quot;,&quot;catch&quot;,&quot;combo&quot;,&quot;maize&quot;,&quot;repay&quot;,&quot;mario&quot;,&quot;snuff&quot;,&quot;delve&quot;,&quot;cored&quot;,&quot;bards&quot;,&quot;sudan&quot;,&quot;shuns&quot;,&quot;yukon&quot;,&quot;jowls&quot;,&quot;wayne&quot;,&quot;torus&quot;,&quot;gales&quot;,&quot;creek&quot;,&quot;prove&quot;,&quot;needy&quot;,&quot;wisps&quot;,&quot;terri&quot;,&quot;ranks&quot;,&quot;books&quot;,&quot;dicky&quot;,&quot;tapes&quot;,&quot;aping&quot;,&quot;padre&quot;,&quot;roads&quot;,&quot;nines&quot;,&quot;seats&quot;,&quot;flats&quot;,&quot;rains&quot;,&quot;moira&quot;,&quot;basic&quot;,&quot;loves&quot;,&quot;pulls&quot;,&quot;tough&quot;,&quot;gills&quot;,&quot;codes&quot;,&quot;chest&quot;,&quot;teeny&quot;,&quot;jolts&quot;,&quot;woody&quot;,&quot;flame&quot;,&quot;asked&quot;,&quot;dulls&quot;,&quot;hotly&quot;,&quot;glare&quot;,&quot;mucky&quot;,&quot;spite&quot;,&quot;flake&quot;,&quot;vines&quot;,&quot;lindy&quot;,&quot;butts&quot;,&quot;froth&quot;,&quot;beeps&quot;,&quot;sills&quot;,&quot;bunny&quot;,&quot;flied&quot;,&quot;shaun&quot;,&quot;mawed&quot;,&quot;velds&quot;,&quot;voled&quot;,&quot;doily&quot;,&quot;patel&quot;,&quot;snake&quot;,&quot;thigh&quot;,&quot;adler&quot;,&quot;calks&quot;,&quot;desks&quot;,&quot;janus&quot;,&quot;spunk&quot;,&quot;baled&quot;,&quot;match&quot;,&quot;strip&quot;,&quot;hosed&quot;,&quot;nippy&quot;,&quot;wrest&quot;,&quot;whams&quot;,&quot;calfs&quot;,&quot;sleet&quot;,&quot;wives&quot;,&quot;boars&quot;,&quot;chain&quot;,&quot;table&quot;,&quot;duked&quot;,&quot;riped&quot;,&quot;edens&quot;,&quot;galas&quot;,&quot;huffs&quot;,&quot;biddy&quot;,&quot;claps&quot;,&quot;aleut&quot;,&quot;yucks&quot;,&quot;bangs&quot;,&quot;quids&quot;,&quot;glenn&quot;,&quot;evert&quot;,&quot;drunk&quot;,&quot;lusts&quot;,&quot;senna&quot;,&quot;slate&quot;,&quot;manet&quot;,&quot;roted&quot;,&quot;sleep&quot;,&quot;loxes&quot;,&quot;fluky&quot;,&quot;fence&quot;,&quot;clamp&quot;,&quot;doted&quot;,&quot;broad&quot;,&quot;sager&quot;,&quot;spark&quot;,&quot;belch&quot;,&quot;mandy&quot;,&quot;deana&quot;,&quot;beyer&quot;,&quot;hoist&quot;,&quot;leafy&quot;,&quot;levee&quot;,&quot;libel&quot;,&quot;tonic&quot;,&quot;aloes&quot;,&quot;steam&quot;,&quot;skews&quot;,&quot;tides&quot;,&quot;stall&quot;,&quot;rifts&quot;,&quot;saxon&quot;,&quot;mavis&quot;,&quot;asama&quot;,&quot;might&quot;,&quot;dotes&quot;,&quot;tangs&quot;,&quot;wroth&quot;,&quot;kited&quot;,&quot;salad&quot;,&quot;liens&quot;,&quot;clink&quot;,&quot;glows&quot;,&quot;balky&quot;,&quot;taffy&quot;,&quot;sided&quot;,&quot;sworn&quot;,&quot;oasis&quot;,&quot;tenth&quot;,&quot;blurt&quot;,&quot;tower&quot;,&quot;often&quot;,&quot;walsh&quot;,&quot;sonny&quot;,&quot;andes&quot;,&quot;slump&quot;,&quot;scans&quot;,&quot;boded&quot;,&quot;chive&quot;,&quot;finer&quot;,&quot;ponce&quot;,&quot;prune&quot;,&quot;sloes&quot;,&quot;dined&quot;,&quot;chums&quot;,&quot;dingo&quot;,&quot;harte&quot;,&quot;ahead&quot;,&quot;event&quot;,&quot;freer&quot;,&quot;heart&quot;,&quot;fetch&quot;,&quot;sated&quot;,&quot;soapy&quot;,&quot;skins&quot;,&quot;royal&quot;,&quot;cuter&quot;,&quot;loire&quot;,&quot;minot&quot;,&quot;aisle&quot;,&quot;horny&quot;,&quot;slued&quot;,&quot;panel&quot;,&quot;eight&quot;,&quot;snoop&quot;,&quot;pries&quot;,&quot;clive&quot;,&quot;pored&quot;,&quot;wrist&quot;,&quot;piped&quot;,&quot;daren&quot;,&quot;cells&quot;,&quot;parks&quot;,&quot;slugs&quot;,&quot;cubed&quot;,&quot;highs&quot;,&quot;booze&quot;,&quot;weary&quot;,&quot;stain&quot;,&quot;hoped&quot;,&quot;finny&quot;,&quot;weeds&quot;,&quot;fetid&quot;,&quot;racer&quot;,&quot;tasks&quot;,&quot;right&quot;,&quot;saint&quot;,&quot;shahs&quot;,&quot;basis&quot;,&quot;refer&quot;,&quot;chart&quot;,&quot;seize&quot;,&quot;lulls&quot;,&quot;slant&quot;,&quot;belay&quot;,&quot;clots&quot;,&quot;jinny&quot;,&quot;tours&quot;,&quot;modes&quot;,&quot;gloat&quot;,&quot;dunks&quot;,&quot;flute&quot;,&quot;conch&quot;,&quot;marts&quot;,&quot;aglow&quot;,&quot;gayer&quot;,&quot;lazes&quot;,&quot;dicks&quot;,&quot;chime&quot;,&quot;bears&quot;,&quot;sharp&quot;,&quot;hatch&quot;,&quot;forms&quot;,&quot;terry&quot;,&quot;gouda&quot;,&quot;thins&quot;,&quot;janet&quot;,&quot;tonya&quot;,&quot;axons&quot;,&quot;sewed&quot;,&quot;danny&quot;,&quot;rowdy&quot;,&quot;dolts&quot;,&quot;hurry&quot;,&quot;opine&quot;,&quot;fifty&quot;,&quot;noisy&quot;,&quot;spiky&quot;,&quot;humid&quot;,&quot;verna&quot;,&quot;poles&quot;,&quot;jayne&quot;,&quot;pecos&quot;,&quot;hooky&quot;,&quot;haney&quot;,&quot;shams&quot;,&quot;snots&quot;,&quot;sally&quot;,&quot;ruder&quot;,&quot;tempe&quot;,&quot;plunk&quot;,&quot;shaft&quot;,&quot;scows&quot;,&quot;essie&quot;,&quot;dated&quot;,&quot;fleet&quot;,&quot;spate&quot;,&quot;bunin&quot;,&quot;hikes&quot;,&quot;sodas&quot;,&quot;filly&quot;,&quot;thyme&quot;,&quot;fiefs&quot;,&quot;perks&quot;,&quot;chary&quot;,&quot;kiths&quot;,&quot;lidia&quot;,&quot;lefty&quot;,&quot;wolff&quot;,&quot;withe&quot;,&quot;three&quot;,&quot;crawl&quot;,&quot;wotan&quot;,&quot;brown&quot;,&quot;japed&quot;,&quot;tolls&quot;,&quot;taken&quot;,&quot;threw&quot;,&quot;crave&quot;,&quot;clash&quot;,&quot;layer&quot;,&quot;tends&quot;,&quot;notes&quot;,&quot;fudge&quot;,&quot;musky&quot;,&quot;bawdy&quot;,&quot;aline&quot;,&quot;matts&quot;,&quot;shirr&quot;,&quot;balks&quot;,&quot;stash&quot;,&quot;wicks&quot;,&quot;crepe&quot;,&quot;foods&quot;,&quot;fares&quot;,&quot;rotes&quot;,&quot;party&quot;,&quot;petty&quot;,&quot;press&quot;,&quot;dolly&quot;,&quot;mangy&quot;,&quot;leeks&quot;,&quot;silly&quot;,&quot;leant&quot;,&quot;nooks&quot;,&quot;chapt&quot;,&quot;loose&quot;,&quot;caged&quot;,&quot;wages&quot;,&quot;grist&quot;,&quot;alert&quot;,&quot;sheri&quot;,&quot;moody&quot;,&quot;tamps&quot;,&quot;hefts&quot;,&quot;souls&quot;,&quot;rubes&quot;,&quot;rolex&quot;,&quot;skulk&quot;,&quot;veeps&quot;,&quot;nonce&quot;,&quot;state&quot;,&quot;level&quot;,&quot;whirl&quot;,&quot;bight&quot;,&quot;grits&quot;,&quot;reset&quot;,&quot;faked&quot;,&quot;spiny&quot;,&quot;mixes&quot;,&quot;hunks&quot;,&quot;major&quot;,&quot;missy&quot;,&quot;arius&quot;,&quot;damns&quot;,&quot;fitly&quot;,&quot;caped&quot;,&quot;mucus&quot;,&quot;trace&quot;,&quot;surat&quot;,&quot;lloyd&quot;,&quot;furry&quot;,&quot;colin&quot;,&quot;texts&quot;,&quot;livia&quot;,&quot;reply&quot;,&quot;twill&quot;,&quot;ships&quot;,&quot;peons&quot;,&quot;shear&quot;,&quot;norms&quot;,&quot;jumbo&quot;,&quot;bring&quot;,&quot;masks&quot;,&quot;zippy&quot;,&quot;brine&quot;,&quot;dorks&quot;,&quot;roded&quot;,&quot;sinks&quot;,&quot;river&quot;,&quot;wolfs&quot;,&quot;strew&quot;,&quot;myths&quot;,&quot;pulpy&quot;,&quot;prank&quot;,&quot;veins&quot;,&quot;flues&quot;,&quot;minus&quot;,&quot;phone&quot;,&quot;banns&quot;,&quot;spell&quot;,&quot;burro&quot;,&quot;brags&quot;,&quot;boyle&quot;,&quot;lambs&quot;,&quot;sides&quot;,&quot;knees&quot;,&quot;clews&quot;,&quot;aired&quot;,&quot;skirt&quot;,&quot;heavy&quot;,&quot;dimer&quot;,&quot;bombs&quot;,&quot;scums&quot;,&quot;hayes&quot;,&quot;chaps&quot;,&quot;snugs&quot;,&quot;dusky&quot;,&quot;loxed&quot;,&quot;ellen&quot;,&quot;while&quot;,&quot;swank&quot;,&quot;track&quot;,&quot;minim&quot;,&quot;wiled&quot;,&quot;hazed&quot;,&quot;roofs&quot;,&quot;cantu&quot;,&quot;sorry&quot;,&quot;roach&quot;,&quot;loser&quot;,&quot;brass&quot;,&quot;stint&quot;,&quot;jerks&quot;,&quot;dirks&quot;,&quot;emory&quot;,&quot;campy&quot;,&quot;poise&quot;,&quot;sexed&quot;,&quot;gamer&quot;,&quot;catty&quot;,&quot;comte&quot;,&quot;bilbo&quot;,&quot;fasts&quot;,&quot;ledge&quot;,&quot;drier&quot;,&quot;idles&quot;,&quot;doors&quot;,&quot;waged&quot;,&quot;rizal&quot;,&quot;pured&quot;,&quot;weirs&quot;,&quot;crisp&quot;,&quot;tasty&quot;,&quot;sored&quot;,&quot;palmy&quot;,&quot;parts&quot;,&quot;ethel&quot;,&quot;unify&quot;,&quot;crows&quot;,&quot;crest&quot;,&quot;udder&quot;,&quot;delis&quot;,&quot;punks&quot;,&quot;dowse&quot;,&quot;totes&quot;,&quot;emile&quot;,&quot;coded&quot;,&quot;shops&quot;,&quot;poppa&quot;,&quot;pours&quot;,&quot;gushy&quot;,&quot;tiffs&quot;,&quot;shads&quot;,&quot;birds&quot;,&quot;coils&quot;,&quot;areas&quot;,&quot;boons&quot;,&quot;hulls&quot;,&quot;alter&quot;,&quot;lobes&quot;,&quot;pleat&quot;,&quot;depth&quot;,&quot;fires&quot;,&quot;pones&quot;,&quot;serra&quot;,&quot;sweat&quot;,&quot;kline&quot;,&quot;malay&quot;,&quot;ruled&quot;,&quot;calve&quot;,&quot;tired&quot;,&quot;drabs&quot;,&quot;tubed&quot;,&quot;wryer&quot;,&quot;slung&quot;,&quot;union&quot;,&quot;sonya&quot;,&quot;aided&quot;,&quot;hewed&quot;,&quot;dicey&quot;,&quot;grids&quot;,&quot;nixed&quot;,&quot;whits&quot;,&quot;mills&quot;,&quot;buffs&quot;,&quot;yucky&quot;,&quot;drops&quot;,&quot;ready&quot;,&quot;yuppy&quot;,&quot;tweet&quot;,&quot;napes&quot;,&quot;cadre&quot;,&quot;teach&quot;,&quot;rasps&quot;,&quot;dowdy&quot;,&quot;hoary&quot;,&quot;canto&quot;,&quot;posed&quot;,&quot;dumbo&quot;,&quot;kooks&quot;,&quot;reese&quot;,&quot;snaky&quot;,&quot;binge&quot;,&quot;byron&quot;,&quot;phony&quot;,&quot;safer&quot;,&quot;friar&quot;,&quot;novel&quot;,&quot;scale&quot;,&quot;huron&quot;,&quot;adorn&quot;,&quot;carla&quot;,&quot;fauna&quot;,&quot;myers&quot;,&quot;hobby&quot;,&quot;purse&quot;,&quot;flesh&quot;,&quot;smock&quot;,&quot;along&quot;,&quot;boils&quot;,&quot;pails&quot;,&quot;times&quot;,&quot;panza&quot;,&quot;lodge&quot;,&quot;clubs&quot;,&quot;colby&quot;,&quot;great&quot;,&quot;thing&quot;,&quot;peaks&quot;,&quot;diana&quot;,&quot;vance&quot;,&quot;whets&quot;,&quot;bergs&quot;,&quot;sling&quot;,&quot;spade&quot;,&quot;soaks&quot;,&quot;beach&quot;,&quot;traps&quot;,&quot;aspen&quot;,&quot;romps&quot;,&quot;boxed&quot;,&quot;fakir&quot;,&quot;weave&quot;,&quot;nerds&quot;,&quot;swazi&quot;,&quot;dotty&quot;,&quot;curls&quot;,&quot;diver&quot;,&quot;jonas&quot;,&quot;waite&quot;,&quot;verbs&quot;,&quot;yeast&quot;,&quot;lapel&quot;,&quot;barth&quot;,&quot;soars&quot;,&quot;hooks&quot;,&quot;taxed&quot;,&quot;slews&quot;,&quot;gouge&quot;,&quot;slags&quot;,&quot;chang&quot;,&quot;chafe&quot;,&quot;saved&quot;,&quot;josie&quot;,&quot;syncs&quot;,&quot;fonds&quot;,&quot;anion&quot;,&quot;actor&quot;,&quot;seems&quot;,&quot;pyrex&quot;,&quot;isiah&quot;,&quot;glued&quot;,&quot;groin&quot;,&quot;goren&quot;,&quot;waxes&quot;,&quot;tonia&quot;,&quot;whine&quot;,&quot;scads&quot;,&quot;knelt&quot;,&quot;teaks&quot;,&quot;satan&quot;,&quot;tromp&quot;,&quot;spats&quot;,&quot;merry&quot;,&quot;wordy&quot;,&quot;stake&quot;,&quot;gland&quot;,&quot;canal&quot;,&quot;donna&quot;,&quot;lends&quot;,&quot;filed&quot;,&quot;sacks&quot;,&quot;shied&quot;,&quot;moors&quot;,&quot;paths&quot;,&quot;older&quot;,&quot;pooch&quot;,&quot;balsa&quot;,&quot;riced&quot;,&quot;facet&quot;,&quot;decaf&quot;,&quot;attic&quot;,&quot;elder&quot;,&quot;akron&quot;,&quot;chomp&quot;,&quot;chump&quot;,&quot;picky&quot;,&quot;money&quot;,&quot;sheer&quot;,&quot;bolls&quot;,&quot;crabs&quot;,&quot;dorms&quot;,&quot;water&quot;,&quot;veers&quot;,&quot;tease&quot;,&quot;dummy&quot;,&quot;dumbs&quot;,&quot;lethe&quot;,&quot;halls&quot;,&quot;rifer&quot;,&quot;demon&quot;,&quot;fucks&quot;,&quot;whips&quot;,&quot;plops&quot;,&quot;fuses&quot;,&quot;focal&quot;,&quot;taces&quot;,&quot;snout&quot;,&quot;edict&quot;,&quot;flush&quot;,&quot;burps&quot;,&quot;dawes&quot;,&quot;lorry&quot;,&quot;spews&quot;,&quot;sprat&quot;,&quot;click&quot;,&quot;deann&quot;,&quot;sited&quot;,&quot;aunts&quot;,&quot;quips&quot;,&quot;godly&quot;,&quot;pupil&quot;,&quot;nanny&quot;,&quot;funks&quot;,&quot;shoon&quot;,&quot;aimed&quot;,&quot;stacy&quot;,&quot;helms&quot;,&quot;mints&quot;,&quot;banks&quot;,&quot;pinch&quot;,&quot;local&quot;,&quot;twine&quot;,&quot;pacts&quot;,&quot;deers&quot;,&quot;halos&quot;,&quot;slink&quot;,&quot;preys&quot;,&quot;potty&quot;,&quot;ruffs&quot;,&quot;pusan&quot;,&quot;suits&quot;,&quot;finks&quot;,&quot;slash&quot;,&quot;prods&quot;,&quot;dense&quot;,&quot;edsel&quot;,&quot;heeds&quot;,&quot;palls&quot;,&quot;slats&quot;,&quot;snits&quot;,&quot;mower&quot;,&quot;rares&quot;,&quot;ailed&quot;,&quot;rouge&quot;,&quot;ellie&quot;,&quot;gated&quot;,&quot;lyons&quot;,&quot;duded&quot;,&quot;links&quot;,&quot;oaths&quot;,&quot;letha&quot;,&quot;kicks&quot;,&quot;firms&quot;,&quot;gravy&quot;,&quot;month&quot;,&quot;kongo&quot;,&quot;mused&quot;,&quot;ducal&quot;,&quot;toted&quot;,&quot;vocal&quot;,&quot;disks&quot;,&quot;spied&quot;,&quot;studs&quot;,&quot;macao&quot;,&quot;erick&quot;,&quot;coupe&quot;,&quot;starr&quot;,&quot;reaps&quot;,&quot;decoy&quot;,&quot;rayon&quot;,&quot;nicks&quot;,&quot;breed&quot;,&quot;cosby&quot;,&quot;haunt&quot;,&quot;typed&quot;,&quot;plain&quot;,&quot;trays&quot;,&quot;muled&quot;,&quot;saith&quot;,&quot;drano&quot;,&quot;cower&quot;,&quot;snows&quot;,&quot;buses&quot;,&quot;jewry&quot;,&quot;argus&quot;,&quot;doers&quot;,&quot;flays&quot;,&quot;swish&quot;,&quot;resin&quot;,&quot;boobs&quot;,&quot;sicks&quot;,&quot;spies&quot;,&quot;bails&quot;,&quot;wowed&quot;,&quot;mabel&quot;,&quot;check&quot;,&quot;vapid&quot;,&quot;bacon&quot;,&quot;wilda&quot;,&quot;ollie&quot;,&quot;loony&quot;,&quot;irked&quot;,&quot;fraud&quot;,&quot;doles&quot;,&quot;facts&quot;,&quot;lists&quot;,&quot;gazed&quot;,&quot;furls&quot;,&quot;sunks&quot;,&quot;stows&quot;,&quot;wilde&quot;,&quot;brick&quot;,&quot;bowed&quot;,&quot;guise&quot;,&quot;suing&quot;,&quot;gates&quot;,&quot;niter&quot;,&quot;heros&quot;,&quot;hyped&quot;,&quot;clomp&quot;,&quot;never&quot;,&quot;lolls&quot;,&quot;rangy&quot;,&quot;paddy&quot;,&quot;chant&quot;,&quot;casts&quot;,&quot;terns&quot;,&quot;tunas&quot;,&quot;poker&quot;,&quot;scary&quot;,&quot;maims&quot;,&quot;saran&quot;,&quot;devon&quot;,&quot;tripe&quot;,&quot;lingo&quot;,&quot;paler&quot;,&quot;coped&quot;,&quot;bride&quot;,&quot;voted&quot;,&quot;dodge&quot;,&quot;gross&quot;,&quot;curds&quot;,&quot;sames&quot;,&quot;those&quot;,&quot;tithe&quot;,&quot;steep&quot;,&quot;flaks&quot;,&quot;close&quot;,&quot;swops&quot;,&quot;stare&quot;,&quot;notch&quot;,&quot;prays&quot;,&quot;roles&quot;,&quot;crush&quot;,&quot;feuds&quot;,&quot;nudge&quot;,&quot;baned&quot;,&quot;brake&quot;,&quot;plans&quot;,&quot;weepy&quot;,&quot;dazed&quot;,&quot;jenna&quot;,&quot;weiss&quot;,&quot;tomes&quot;,&quot;stews&quot;,&quot;whist&quot;,&quot;gibed&quot;,&quot;death&quot;,&quot;clank&quot;,&quot;cover&quot;,&quot;peeks&quot;,&quot;quick&quot;,&quot;abler&quot;,&quot;daddy&quot;,&quot;calls&quot;,&quot;scald&quot;,&quot;lilia&quot;,&quot;flask&quot;,&quot;cheer&quot;,&quot;grabs&quot;,&quot;megan&quot;,&quot;canes&quot;,&quot;jules&quot;,&quot;blots&quot;,&quot;mossy&quot;,&quot;begun&quot;,&quot;freak&quot;,&quot;caved&quot;,&quot;hello&quot;,&quot;hades&quot;,&quot;theed&quot;,&quot;wards&quot;,&quot;darcy&quot;,&quot;malta&quot;,&quot;peter&quot;,&quot;whorl&quot;,&quot;break&quot;,&quot;downs&quot;,&quot;odder&quot;,&quot;hoofs&quot;,&quot;kiddo&quot;,&quot;macho&quot;,&quot;fords&quot;,&quot;liked&quot;,&quot;flees&quot;,&quot;swing&quot;,&quot;elect&quot;,&quot;hoods&quot;,&quot;pluck&quot;,&quot;brook&quot;,&quot;astir&quot;,&quot;bland&quot;,&quot;sward&quot;,&quot;modal&quot;,&quot;flown&quot;,&quot;ahmad&quot;,&quot;waled&quot;,&quot;craps&quot;,&quot;cools&quot;,&quot;roods&quot;,&quot;hided&quot;,&quot;plath&quot;,&quot;kings&quot;,&quot;grips&quot;,&quot;gives&quot;,&quot;gnats&quot;,&quot;tabby&quot;,&quot;gauls&quot;,&quot;think&quot;,&quot;bully&quot;,&quot;fogey&quot;,&quot;sawed&quot;,&quot;lints&quot;,&quot;pushy&quot;,&quot;banes&quot;,&quot;drake&quot;,&quot;trail&quot;,&quot;moral&quot;,&quot;daley&quot;,&quot;balds&quot;,&quot;chugs&quot;,&quot;geeky&quot;,&quot;darts&quot;,&quot;soddy&quot;,&quot;haves&quot;,&quot;opens&quot;,&quot;rends&quot;,&quot;buggy&quot;,&quot;moles&quot;,&quot;freud&quot;,&quot;gored&quot;,&quot;shock&quot;,&quot;angus&quot;,&quot;puree&quot;,&quot;raves&quot;,&quot;johns&quot;,&quot;armed&quot;,&quot;packs&quot;,&quot;minis&quot;,&quot;reich&quot;,&quot;slots&quot;,&quot;totem&quot;,&quot;clown&quot;,&quot;popes&quot;,&quot;brute&quot;,&quot;hedge&quot;,&quot;latin&quot;,&quot;stoke&quot;,&quot;blend&quot;,&quot;pease&quot;,&quot;rubik&quot;,&quot;greer&quot;,&quot;hindi&quot;,&quot;betsy&quot;,&quot;flows&quot;,&quot;funky&quot;,&quot;kelli&quot;,&quot;humps&quot;,&quot;chewy&quot;,&quot;welds&quot;,&quot;scowl&quot;,&quot;yells&quot;,&quot;cough&quot;,&quot;sasha&quot;,&quot;sheaf&quot;,&quot;jokes&quot;,&quot;coast&quot;,&quot;words&quot;,&quot;irate&quot;,&quot;hales&quot;,&quot;camry&quot;,&quot;spits&quot;,&quot;burma&quot;,&quot;rhine&quot;,&quot;bends&quot;,&quot;spill&quot;,&quot;stubs&quot;,&quot;power&quot;,&quot;voles&quot;,&quot;learn&quot;,&quot;knoll&quot;,&quot;style&quot;,&quot;twila&quot;,&quot;drove&quot;,&quot;dacca&quot;,&quot;sheen&quot;,&quot;papas&quot;,&quot;shale&quot;,&quot;jones&quot;,&quot;duped&quot;,&quot;tunny&quot;,&quot;mouse&quot;,&quot;floss&quot;,&quot;corks&quot;,&quot;skims&quot;,&quot;swaps&quot;,&quot;inned&quot;,&quot;boxer&quot;,&quot;synch&quot;,&quot;skies&quot;,&quot;strep&quot;,&quot;bucks&quot;,&quot;belau&quot;,&quot;lower&quot;,&quot;flaky&quot;,&quot;quill&quot;,&quot;aural&quot;,&quot;rufus&quot;,&quot;floes&quot;,&quot;pokes&quot;,&quot;sends&quot;,&quot;sates&quot;,&quot;dally&quot;,&quot;boyer&quot;,&quot;hurts&quot;,&quot;foyer&quot;,&quot;gowns&quot;,&quot;torch&quot;,&quot;luria&quot;,&quot;fangs&quot;,&quot;moats&quot;,&quot;heinz&quot;,&quot;bolts&quot;,&quot;filet&quot;,&quot;firth&quot;,&quot;begot&quot;,&quot;argue&quot;,&quot;youth&quot;,&quot;chimp&quot;,&quot;frogs&quot;,&quot;kraft&quot;,&quot;smite&quot;,&quot;loges&quot;,&quot;loons&quot;,&quot;spine&quot;,&quot;domes&quot;,&quot;pokey&quot;,&quot;timur&quot;,&quot;noddy&quot;,&quot;doggy&quot;,&quot;wades&quot;,&quot;lanes&quot;,&quot;hence&quot;,&quot;louts&quot;,&quot;turks&quot;,&quot;lurid&quot;,&quot;goths&quot;,&quot;moist&quot;,&quot;bated&quot;,&quot;giles&quot;,&quot;stood&quot;,&quot;winos&quot;,&quot;shins&quot;,&quot;potts&quot;,&quot;brant&quot;,&quot;vised&quot;,&quot;alice&quot;,&quot;rosie&quot;,&quot;dents&quot;,&quot;babes&quot;,&quot;softy&quot;,&quot;decay&quot;,&quot;meats&quot;,&quot;tanya&quot;,&quot;rusks&quot;,&quot;pasts&quot;,&quot;karat&quot;,&quot;nuked&quot;,&quot;gorge&quot;,&quot;kinks&quot;,&quot;skull&quot;,&quot;noyce&quot;,&quot;aimee&quot;,&quot;watch&quot;,&quot;cleat&quot;,&quot;stuck&quot;,&quot;china&quot;,&quot;testy&quot;,&quot;doses&quot;,&quot;safes&quot;,&quot;stage&quot;,&quot;bayes&quot;,&quot;twins&quot;,&quot;limps&quot;,&quot;denis&quot;,&quot;chars&quot;,&quot;flaps&quot;,&quot;paces&quot;,&quot;abase&quot;,&quot;grays&quot;,&quot;deans&quot;,&quot;maria&quot;,&quot;asset&quot;,&quot;smuts&quot;,&quot;serbs&quot;,&quot;whigs&quot;,&quot;vases&quot;,&quot;robyn&quot;,&quot;girls&quot;,&quot;pents&quot;,&quot;alike&quot;,&quot;nodal&quot;,&quot;molly&quot;,&quot;swigs&quot;,&quot;swill&quot;,&quot;slums&quot;,&quot;rajah&quot;,&quot;bleep&quot;,&quot;beget&quot;,&quot;thanh&quot;,&quot;finns&quot;,&quot;clock&quot;,&quot;wafts&quot;,&quot;wafer&quot;,&quot;spicy&quot;,&quot;sorer&quot;,&quot;reach&quot;,&quot;beats&quot;,&quot;baker&quot;,&quot;crown&quot;,&quot;drugs&quot;,&quot;daisy&quot;,&quot;mocks&quot;,&quot;scots&quot;,&quot;fests&quot;,&quot;newer&quot;,&quot;agate&quot;,&quot;drift&quot;,&quot;marta&quot;,&quot;chino&quot;,&quot;flirt&quot;,&quot;homed&quot;,&quot;bribe&quot;,&quot;scram&quot;,&quot;bulks&quot;,&quot;servo&quot;,&quot;vesta&quot;,&quot;divas&quot;,&quot;preps&quot;,&quot;naval&quot;,&quot;tally&quot;,&quot;shove&quot;,&quot;ragas&quot;,&quot;blown&quot;,&quot;droll&quot;,&quot;tryst&quot;,&quot;lucky&quot;,&quot;leech&quot;,&quot;lines&quot;,&quot;sires&quot;,&quot;pyxed&quot;,&quot;taper&quot;,&quot;trump&quot;,&quot;payee&quot;,&quot;midge&quot;,&quot;paris&quot;,&quot;bored&quot;,&quot;loads&quot;,&quot;shuts&quot;,&quot;lived&quot;,&quot;swath&quot;,&quot;snare&quot;,&quot;boned&quot;,&quot;scars&quot;,&quot;aeons&quot;,&quot;grime&quot;,&quot;writs&quot;,&quot;paige&quot;,&quot;rungs&quot;,&quot;blent&quot;,&quot;signs&quot;,&quot;davis&quot;,&quot;dials&quot;,&quot;daubs&quot;,&quot;rainy&quot;,&quot;fawns&quot;,&quot;wrier&quot;,&quot;golds&quot;,&quot;wrath&quot;,&quot;ducks&quot;,&quot;allow&quot;,&quot;hosea&quot;,&quot;spike&quot;,&quot;meals&quot;,&quot;haber&quot;,&quot;muses&quot;,&quot;timed&quot;,&quot;broom&quot;,&quot;burks&quot;,&quot;louis&quot;,&quot;gangs&quot;,&quot;pools&quot;,&quot;vales&quot;,&quot;altai&quot;,&quot;elope&quot;,&quot;plied&quot;,&quot;slain&quot;,&quot;chasm&quot;,&quot;entry&quot;,&quot;slide&quot;,&quot;bawls&quot;,&quot;title&quot;,&quot;sings&quot;,&quot;grief&quot;,&quot;viola&quot;,&quot;doyle&quot;,&quot;peach&quot;,&quot;davit&quot;,&quot;bench&quot;,&quot;devil&quot;,&quot;latex&quot;,&quot;miles&quot;,&quot;pasha&quot;,&quot;tokes&quot;,&quot;coves&quot;,&quot;wheel&quot;,&quot;tried&quot;,&quot;verdi&quot;,&quot;wanda&quot;,&quot;sivan&quot;,&quot;prior&quot;,&quot;fryer&quot;,&quot;plots&quot;,&quot;kicky&quot;,&quot;porch&quot;,&quot;shill&quot;,&quot;coats&quot;,&quot;borne&quot;,&quot;brink&quot;,&quot;pawed&quot;,&quot;erwin&quot;,&quot;tense&quot;,&quot;stirs&quot;,&quot;wends&quot;,&quot;waxen&quot;,&quot;carts&quot;,&quot;smear&quot;,&quot;rival&quot;,&quot;scare&quot;,&quot;phase&quot;,&quot;bragg&quot;,&quot;crane&quot;,&quot;hocks&quot;,&quot;conan&quot;,&quot;bests&quot;,&quot;dares&quot;,&quot;molls&quot;,&quot;roots&quot;,&quot;dunes&quot;,&quot;slips&quot;,&quot;waked&quot;,&quot;fours&quot;,&quot;bolds&quot;,&quot;slosh&quot;,&quot;yemen&quot;,&quot;poole&quot;,&quot;solid&quot;,&quot;ports&quot;,&quot;fades&quot;,&quot;legal&quot;,&quot;cedes&quot;,&quot;green&quot;,&quot;curie&quot;,&quot;seedy&quot;,&quot;riper&quot;,&quot;poled&quot;,&quot;glade&quot;,&quot;hosts&quot;,&quot;tools&quot;,&quot;razes&quot;,&quot;tarry&quot;,&quot;muddy&quot;,&quot;shims&quot;,&quot;sword&quot;,&quot;thine&quot;,&quot;lasts&quot;,&quot;bloat&quot;,&quot;soled&quot;,&quot;tardy&quot;,&quot;foots&quot;,&quot;skiff&quot;,&quot;volta&quot;,&quot;murks&quot;,&quot;croci&quot;,&quot;gooks&quot;,&quot;gamey&quot;,&quot;pyxes&quot;,&quot;poems&quot;,&quot;kayla&quot;,&quot;larva&quot;,&quot;slaps&quot;,&quot;abuse&quot;,&quot;pings&quot;,&quot;plows&quot;,&quot;geese&quot;,&quot;minks&quot;,&quot;derby&quot;,&quot;super&quot;,&quot;inked&quot;,&quot;manic&quot;,&quot;leaks&quot;,&quot;flops&quot;,&quot;lajos&quot;,&quot;fuzes&quot;,&quot;swabs&quot;,&quot;twigs&quot;,&quot;gummy&quot;,&quot;pyres&quot;,&quot;shrew&quot;,&quot;islet&quot;,&quot;doled&quot;,&quot;wooly&quot;,&quot;lefts&quot;,&quot;hunts&quot;,&quot;toast&quot;,&quot;faith&quot;,&quot;macaw&quot;,&quot;sonia&quot;,&quot;leafs&quot;,&quot;colas&quot;,&quot;conks&quot;,&quot;altos&quot;,&quot;wiped&quot;,&quot;scene&quot;,&quot;boors&quot;,&quot;patsy&quot;,&quot;meany&quot;,&quot;chung&quot;,&quot;wakes&quot;,&quot;clear&quot;,&quot;ropes&quot;,&quot;tahoe&quot;,&quot;zones&quot;,&quot;crate&quot;,&quot;tombs&quot;,&quot;nouns&quot;,&quot;garth&quot;,&quot;puked&quot;,&quot;chats&quot;,&quot;hanks&quot;,&quot;baked&quot;,&quot;binds&quot;,&quot;fully&quot;,&quot;soaps&quot;,&quot;newel&quot;,&quot;yarns&quot;,&quot;puers&quot;,&quot;carps&quot;,&quot;spelt&quot;,&quot;lully&quot;,&quot;towed&quot;,&quot;scabs&quot;,&quot;prime&quot;,&quot;blest&quot;,&quot;patty&quot;,&quot;silky&quot;,&quot;abner&quot;,&quot;temps&quot;,&quot;lakes&quot;,&quot;tests&quot;,&quot;alias&quot;,&quot;mines&quot;,&quot;chips&quot;,&quot;funds&quot;,&quot;caret&quot;,&quot;splat&quot;,&quot;perry&quot;,&quot;turds&quot;,&quot;junks&quot;,&quot;cramp&quot;,&quot;saned&quot;,&quot;peary&quot;,&quot;snarl&quot;,&quot;fired&quot;,&quot;stung&quot;,&quot;nancy&quot;,&quot;bulge&quot;,&quot;styli&quot;,&quot;seams&quot;,&quot;hived&quot;,&quot;feast&quot;,&quot;triad&quot;,&quot;jaded&quot;,&quot;elvin&quot;,&quot;canny&quot;,&quot;birth&quot;,&quot;routs&quot;,&quot;rimed&quot;,&quot;pusey&quot;,&quot;laces&quot;,&quot;taste&quot;,&quot;basie&quot;,&quot;malls&quot;,&quot;shout&quot;,&quot;prier&quot;,&quot;prone&quot;,&quot;finis&quot;,&quot;claus&quot;,&quot;loops&quot;,&quot;heron&quot;,&quot;frump&quot;,&quot;spare&quot;,&quot;menus&quot;,&quot;ariel&quot;,&quot;crams&quot;,&quot;bloom&quot;,&quot;foxed&quot;,&quot;moons&quot;,&quot;mince&quot;,&quot;mixed&quot;,&quot;piers&quot;,&quot;deres&quot;,&quot;tempt&quot;,&quot;dryer&quot;,&quot;atone&quot;,&quot;heats&quot;,&quot;dario&quot;,&quot;hawed&quot;,&quot;swims&quot;,&quot;sheet&quot;,&quot;tasha&quot;,&quot;dings&quot;,&quot;clare&quot;,&quot;aging&quot;,&quot;daffy&quot;,&quot;wried&quot;,&quot;foals&quot;,&quot;lunar&quot;,&quot;havel&quot;,&quot;irony&quot;,&quot;ronny&quot;,&quot;naves&quot;,&quot;selma&quot;,&quot;gurus&quot;,&quot;crust&quot;,&quot;percy&quot;,&quot;murat&quot;,&quot;mauro&quot;,&quot;cowed&quot;,&quot;clang&quot;,&quot;biker&quot;,&quot;harms&quot;,&quot;barry&quot;,&quot;thump&quot;,&quot;crude&quot;,&quot;ulnae&quot;,&quot;thong&quot;,&quot;pager&quot;,&quot;oases&quot;,&quot;mered&quot;,&quot;locke&quot;,&quot;merle&quot;,&quot;soave&quot;,&quot;petal&quot;,&quot;poser&quot;,&quot;store&quot;,&quot;winch&quot;,&quot;wedge&quot;,&quot;inlet&quot;,&quot;nerdy&quot;,&quot;utter&quot;,&quot;filth&quot;,&quot;spray&quot;,&quot;drape&quot;,&quot;pukes&quot;,&quot;ewers&quot;,&quot;kinds&quot;,&quot;dates&quot;,&quot;meier&quot;,&quot;tammi&quot;,&quot;spoor&quot;,&quot;curly&quot;,&quot;chill&quot;,&quot;loped&quot;,&quot;gooey&quot;,&quot;boles&quot;,&quot;genet&quot;,&quot;boost&quot;,&quot;beets&quot;,&quot;heath&quot;,&quot;feeds&quot;,&quot;growl&quot;,&quot;livid&quot;,&quot;midst&quot;,&quot;rinds&quot;,&quot;fresh&quot;,&quot;waxed&quot;,&quot;yearn&quot;,&quot;keeps&quot;,&quot;rimes&quot;,&quot;naked&quot;,&quot;flick&quot;,&quot;plies&quot;,&quot;deeps&quot;,&quot;dirty&quot;,&quot;hefty&quot;,&quot;messy&quot;,&quot;hairy&quot;,&quot;walks&quot;,&quot;leper&quot;,&quot;sykes&quot;,&quot;nerve&quot;,&quot;rover&quot;,&quot;jived&quot;,&quot;brisk&quot;,&quot;lenin&quot;,&quot;viper&quot;,&quot;chuck&quot;,&quot;sinus&quot;,&quot;luger&quot;,&quot;ricks&quot;,&quot;hying&quot;,&quot;rusty&quot;,&quot;kathy&quot;,&quot;herds&quot;,&quot;wider&quot;,&quot;getty&quot;,&quot;roman&quot;,&quot;sandy&quot;,&quot;pends&quot;,&quot;fezes&quot;,&quot;trios&quot;,&quot;bites&quot;,&quot;pants&quot;,&quot;bless&quot;,&quot;diced&quot;,&quot;earth&quot;,&quot;shack&quot;,&quot;hinge&quot;,&quot;melds&quot;,&quot;jonah&quot;,&quot;chose&quot;,&quot;liver&quot;,&quot;salts&quot;,&quot;ratty&quot;,&quot;ashed&quot;,&quot;wacky&quot;,&quot;yokes&quot;,&quot;wanly&quot;,&quot;bruce&quot;,&quot;vowel&quot;,&quot;black&quot;,&quot;grail&quot;,&quot;lungs&quot;,&quot;arise&quot;,&quot;gluts&quot;,&quot;gluey&quot;,&quot;navel&quot;,&quot;coyer&quot;,&quot;ramps&quot;,&quot;miter&quot;,&quot;aldan&quot;,&quot;booth&quot;,&quot;musty&quot;,&quot;rills&quot;,&quot;darns&quot;,&quot;tined&quot;,&quot;straw&quot;,&quot;kerri&quot;,&quot;hared&quot;,&quot;lucks&quot;,&quot;metes&quot;,&quot;penny&quot;,&quot;radon&quot;,&quot;palms&quot;,&quot;deeds&quot;,&quot;earls&quot;,&quot;shard&quot;,&quot;pried&quot;,&quot;tampa&quot;,&quot;blank&quot;,&quot;gybes&quot;,&quot;vicki&quot;,&quot;drool&quot;,&quot;groom&quot;,&quot;curer&quot;,&quot;cubes&quot;,&quot;riggs&quot;,&quot;lanky&quot;,&quot;tuber&quot;,&quot;caves&quot;,&quot;acing&quot;,&quot;golly&quot;,&quot;hodge&quot;,&quot;beard&quot;,&quot;ginny&quot;,&quot;jibed&quot;,&quot;fumes&quot;,&quot;astor&quot;,&quot;quito&quot;,&quot;cargo&quot;,&quot;randi&quot;,&quot;gawky&quot;,&quot;zings&quot;,&quot;blind&quot;,&quot;dhoti&quot;,&quot;sneak&quot;,&quot;fatah&quot;,&quot;fixer&quot;,&quot;lapps&quot;,&quot;cline&quot;,&quot;grimm&quot;,&quot;fakes&quot;,&quot;maine&quot;,&quot;erika&quot;,&quot;dealt&quot;,&quot;mitch&quot;,&quot;olden&quot;,&quot;joist&quot;,&quot;gents&quot;,&quot;likes&quot;,&quot;shelf&quot;,&quot;silts&quot;,&quot;goats&quot;,&quot;leads&quot;,&quot;marin&quot;,&quot;spire&quot;,&quot;louie&quot;,&quot;evans&quot;,&quot;amuse&quot;,&quot;belly&quot;,&quot;nails&quot;,&quot;snead&quot;,&quot;model&quot;,&quot;whats&quot;,&quot;shari&quot;,&quot;quote&quot;,&quot;tacks&quot;,&quot;nutty&quot;,&quot;lames&quot;,&quot;caste&quot;,&quot;hexes&quot;,&quot;cooks&quot;,&quot;miner&quot;,&quot;shawn&quot;,&quot;anise&quot;,&quot;drama&quot;,&quot;trike&quot;,&quot;prate&quot;,&quot;ayers&quot;,&quot;loans&quot;,&quot;botch&quot;,&quot;vests&quot;,&quot;cilia&quot;,&quot;ridge&quot;,&quot;thugs&quot;,&quot;outed&quot;,&quot;jails&quot;,&quot;moped&quot;,&quot;plead&quot;,&quot;tunes&quot;,&quot;nosed&quot;,&quot;wills&quot;,&quot;lager&quot;,&quot;lacks&quot;,&quot;cried&quot;,&quot;wince&quot;,&quot;berle&quot;,&quot;flaws&quot;,&quot;boise&quot;,&quot;tibet&quot;,&quot;bided&quot;,&quot;shred&quot;,&quot;cocky&quot;,&quot;brice&quot;,&quot;delta&quot;,&quot;congo&quot;,&quot;holly&quot;,&quot;hicks&quot;,&quot;wraps&quot;,&quot;cocks&quot;,&quot;aisha&quot;,&quot;heard&quot;,&quot;cured&quot;,&quot;sades&quot;,&quot;horsy&quot;,&quot;umped&quot;,&quot;trice&quot;,&quot;dorky&quot;,&quot;curve&quot;,&quot;ferry&quot;,&quot;haler&quot;,&quot;ninth&quot;,&quot;pasta&quot;,&quot;jason&quot;,&quot;honer&quot;,&quot;kevin&quot;,&quot;males&quot;,&quot;fowls&quot;,&quot;awake&quot;,&quot;pores&quot;,&quot;meter&quot;,&quot;skate&quot;,&quot;drink&quot;,&quot;pussy&quot;,&quot;soups&quot;,&quot;bases&quot;,&quot;noyes&quot;,&quot;torts&quot;,&quot;bogus&quot;,&quot;still&quot;,&quot;soupy&quot;,&quot;dance&quot;,&quot;worry&quot;,&quot;eldon&quot;,&quot;stern&quot;,&quot;menes&quot;,&quot;dolls&quot;,&quot;dumpy&quot;,&quot;gaunt&quot;,&quot;grove&quot;,&quot;coops&quot;,&quot;mules&quot;,&quot;berry&quot;,&quot;sower&quot;,&quot;roams&quot;,&quot;brawl&quot;,&quot;greed&quot;,&quot;stags&quot;,&quot;blurs&quot;,&quot;swift&quot;,&quot;treed&quot;,&quot;taney&quot;,&quot;shame&quot;,&quot;easel&quot;,&quot;moves&quot;,&quot;leger&quot;,&quot;ville&quot;,&quot;order&quot;,&quot;spock&quot;,&quot;nifty&quot;,&quot;brian&quot;,&quot;elias&quot;,&quot;idler&quot;,&quot;serve&quot;,&quot;ashen&quot;,&quot;bizet&quot;,&quot;gilts&quot;,&quot;spook&quot;,&quot;eaten&quot;,&quot;pumas&quot;,&quot;cotes&quot;,&quot;broke&quot;,&quot;toxin&quot;,&quot;groan&quot;,&quot;laths&quot;,&quot;joins&quot;,&quot;spots&quot;,&quot;hated&quot;,&quot;tokay&quot;,&quot;elite&quot;,&quot;rawer&quot;,&quot;fiats&quot;,&quot;cards&quot;,&quot;sassy&quot;,&quot;milks&quot;,&quot;roost&quot;,&quot;glean&quot;,&quot;lutes&quot;,&quot;chins&quot;,&quot;drown&quot;,&quot;marks&quot;,&quot;pined&quot;,&quot;grace&quot;,&quot;fifth&quot;,&quot;lodes&quot;,&quot;rusts&quot;,&quot;terms&quot;,&quot;maxes&quot;,&quot;savvy&quot;,&quot;choir&quot;,&quot;savoy&quot;,&quot;spoon&quot;,&quot;halve&quot;,&quot;chord&quot;,&quot;hulas&quot;,&quot;sarah&quot;,&quot;celia&quot;,&quot;deems&quot;,&quot;ninny&quot;,&quot;wines&quot;,&quot;boggy&quot;,&quot;birch&quot;,&quot;raved&quot;,&quot;wales&quot;,&quot;beams&quot;,&quot;vibes&quot;,&quot;riots&quot;,&quot;warty&quot;,&quot;nigel&quot;,&quot;askew&quot;,&quot;faxes&quot;,&quot;sedge&quot;,&quot;sheol&quot;,&quot;pucks&quot;,&quot;cynic&quot;,&quot;relax&quot;,&quot;boers&quot;,&quot;whims&quot;,&quot;bents&quot;,&quot;candy&quot;,&quot;luann&quot;,&quot;slogs&quot;,&quot;bonny&quot;,&quot;barns&quot;,&quot;iambs&quot;,&quot;fused&quot;,&quot;duffy&quot;,&quot;guilt&quot;,&quot;bruin&quot;,&quot;pawls&quot;,&quot;penis&quot;,&quot;poppy&quot;,&quot;owing&quot;,&quot;tribe&quot;,&quot;tuner&quot;,&quot;moray&quot;,&quot;timid&quot;,&quot;ceded&quot;,&quot;geeks&quot;,&quot;kites&quot;,&quot;curio&quot;,&quot;puffy&quot;,&quot;perot&quot;,&quot;caddy&quot;,&quot;peeve&quot;,&quot;cause&quot;,&quot;dills&quot;,&quot;gavel&quot;,&quot;manse&quot;,&quot;joker&quot;,&quot;lynch&quot;,&quot;crank&quot;,&quot;golda&quot;,&quot;waits&quot;,&quot;wises&quot;,&quot;hasty&quot;,&quot;paves&quot;,&quot;grown&quot;,&quot;reedy&quot;,&quot;crypt&quot;,&quot;tonne&quot;,&quot;jerky&quot;,&quot;axing&quot;,&quot;swept&quot;,&quot;posse&quot;,&quot;rings&quot;,&quot;staff&quot;,&quot;tansy&quot;,&quot;pared&quot;,&quot;glaze&quot;,&quot;grebe&quot;,&quot;gonna&quot;,&quot;shark&quot;,&quot;jumps&quot;,&quot;vials&quot;,&quot;unset&quot;,&quot;hires&quot;,&quot;tying&quot;,&quot;lured&quot;,&quot;motes&quot;,&quot;linen&quot;,&quot;locks&quot;,&quot;mamas&quot;,&quot;nasty&quot;,&quot;mamie&quot;,&quot;clout&quot;,&quot;nader&quot;,&quot;velma&quot;,&quot;abate&quot;,&quot;tight&quot;,&quot;dales&quot;,&quot;serer&quot;,&quot;rives&quot;,&quot;bales&quot;,&quot;loamy&quot;,&quot;warps&quot;,&quot;plato&quot;,&quot;hooch&quot;,&quot;togae&quot;,&quot;damps&quot;,&quot;ofter&quot;,&quot;plumb&quot;,&quot;fifes&quot;,&quot;filmy&quot;,&quot;wiper&quot;,&quot;chess&quot;,&quot;lousy&quot;,&quot;sails&quot;,&quot;brahe&quot;,&quot;ounce&quot;,&quot;flits&quot;,&quot;hindu&quot;,&quot;manly&quot;,&quot;beaux&quot;,&quot;mimed&quot;,&quot;liken&quot;,&quot;forts&quot;,&quot;jambs&quot;,&quot;peeps&quot;,&quot;lelia&quot;,&quot;brews&quot;,&quot;handy&quot;,&quot;lusty&quot;,&quot;brads&quot;,&quot;marne&quot;,&quot;pesos&quot;,&quot;earle&quot;,&quot;arson&quot;,&quot;scout&quot;,&quot;showy&quot;,&quot;chile&quot;,&quot;sumps&quot;,&quot;hiked&quot;,&quot;crook&quot;,&quot;herbs&quot;,&quot;silks&quot;,&quot;alamo&quot;,&quot;mores&quot;,&quot;dunce&quot;,&quot;blaze&quot;,&quot;stank&quot;,&quot;haste&quot;,&quot;howls&quot;,&quot;trots&quot;,&quot;creon&quot;,&quot;lisle&quot;,&quot;pause&quot;,&quot;hates&quot;,&quot;mulch&quot;,&quot;mined&quot;,&quot;moder&quot;,&quot;devin&quot;,&quot;types&quot;,&quot;cindy&quot;,&quot;beech&quot;,&quot;tuned&quot;,&quot;mowed&quot;,&quot;pitts&quot;,&quot;chaos&quot;,&quot;colds&quot;,&quot;bidet&quot;,&quot;tines&quot;,&quot;sighs&quot;,&quot;slimy&quot;,&quot;brain&quot;,&quot;belle&quot;,&quot;leery&quot;,&quot;morse&quot;,&quot;ruben&quot;,&quot;prows&quot;,&quot;frown&quot;,&quot;disco&quot;,&quot;regal&quot;,&quot;oaken&quot;,&quot;sheds&quot;,&quot;hives&quot;,&quot;corny&quot;,&quot;baser&quot;,&quot;fated&quot;,&quot;throe&quot;,&quot;revel&quot;,&quot;bores&quot;,&quot;waved&quot;,&quot;shits&quot;,&quot;elvia&quot;,&quot;ferns&quot;,&quot;maids&quot;,&quot;color&quot;,&quot;coifs&quot;,&quot;cohan&quot;,&quot;draft&quot;,&quot;hmong&quot;,&quot;alton&quot;,&quot;stine&quot;,&quot;cluck&quot;,&quot;nodes&quot;,&quot;emily&quot;,&quot;brave&quot;,&quot;blair&quot;,&quot;blued&quot;,&quot;dress&quot;,&quot;bunts&quot;,&quot;holst&quot;,&quot;clogs&quot;,&quot;rally&quot;,&quot;knack&quot;,&quot;demos&quot;,&quot;brady&quot;,&quot;blues&quot;,&quot;flash&quot;,&quot;goofy&quot;,&quot;blocs&quot;,&quot;diane&quot;,&quot;colic&quot;,&quot;smile&quot;,&quot;yules&quot;,&quot;foamy&quot;,&quot;splay&quot;,&quot;bilge&quot;,&quot;faker&quot;,&quot;foils&quot;,&quot;condo&quot;,&quot;knell&quot;,&quot;crack&quot;,&quot;gallo&quot;,&quot;purls&quot;,&quot;auras&quot;,&quot;cakes&quot;,&quot;doves&quot;,&quot;joust&quot;,&quot;aides&quot;,&quot;lades&quot;,&quot;muggy&quot;,&quot;tanks&quot;,&quot;middy&quot;,&quot;tarps&quot;,&quot;slack&quot;,&quot;capet&quot;,&quot;frays&quot;,&quot;donny&quot;,&quot;venal&quot;,&quot;yeats&quot;,&quot;misty&quot;,&quot;denim&quot;,&quot;glass&quot;,&quot;nudes&quot;,&quot;seeps&quot;,&quot;gibbs&quot;,&quot;blows&quot;,&quot;bobbi&quot;,&quot;shane&quot;,&quot;yards&quot;,&quot;pimps&quot;,&quot;clued&quot;,&quot;quiet&quot;,&quot;witch&quot;,&quot;boxes&quot;,&quot;prawn&quot;,&quot;kerry&quot;,&quot;torah&quot;,&quot;kinko&quot;,&quot;dingy&quot;,&quot;emote&quot;,&quot;honor&quot;,&quot;jelly&quot;,&quot;grins&quot;,&quot;trope&quot;,&quot;vined&quot;,&quot;bagel&quot;,&quot;arden&quot;,&quot;rapid&quot;,&quot;paged&quot;,&quot;loved&quot;,&quot;agape&quot;,&quot;mural&quot;,&quot;budge&quot;,&quot;ticks&quot;,&quot;suers&quot;,&quot;wendi&quot;,&quot;slice&quot;,&quot;salve&quot;,&quot;robin&quot;,&quot;bleat&quot;,&quot;batik&quot;,&quot;myles&quot;,&quot;teddy&quot;,&quot;flatt&quot;,&quot;puppy&quot;,&quot;gelid&quot;,&quot;largo&quot;,&quot;attar&quot;,&quot;polls&quot;,&quot;glide&quot;,&quot;serum&quot;,&quot;fundy&quot;,&quot;sucks&quot;,&quot;shalt&quot;,&quot;sewer&quot;,&quot;wreak&quot;,&quot;dames&quot;,&quot;fonts&quot;,&quot;toxic&quot;,&quot;hines&quot;,&quot;wormy&quot;,&quot;grass&quot;,&quot;louse&quot;,&quot;bowls&quot;,&quot;crass&quot;,&quot;benny&quot;,&quot;moire&quot;,&quot;margo&quot;,&quot;golfs&quot;,&quot;smart&quot;,&quot;roxie&quot;,&quot;wight&quot;,&quot;reign&quot;,&quot;dairy&quot;,&quot;clops&quot;,&quot;paled&quot;,&quot;oddly&quot;,&quot;sappy&quot;,&quot;flair&quot;,&quot;shown&quot;,&quot;bulgy&quot;,&quot;benet&quot;,&quot;larch&quot;,&quot;curry&quot;,&quot;gulfs&quot;,&quot;fends&quot;,&quot;lunch&quot;,&quot;dukes&quot;,&quot;doris&quot;,&quot;spoke&quot;,&quot;coins&quot;,&quot;manna&quot;,&quot;conga&quot;,&quot;jinns&quot;,&quot;eases&quot;,&quot;dunno&quot;,&quot;tisha&quot;,&quot;swore&quot;,&quot;rhino&quot;,&quot;calms&quot;,&quot;irvin&quot;,&quot;clans&quot;,&quot;gully&quot;,&quot;liege&quot;,&quot;mains&quot;,&quot;besot&quot;,&quot;serge&quot;,&quot;being&quot;,&quot;welch&quot;,&quot;wombs&quot;,&quot;draco&quot;,&quot;lynda&quot;,&quot;forty&quot;,&quot;mumps&quot;,&quot;bloch&quot;,&quot;ogden&quot;,&quot;knits&quot;,&quot;fussy&quot;,&quot;alder&quot;,&quot;danes&quot;,&quot;loyal&quot;,&quot;valet&quot;,&quot;wooer&quot;,&quot;quire&quot;,&quot;liefs&quot;,&quot;shana&quot;,&quot;toyed&quot;,&quot;forks&quot;,&quot;gages&quot;,&quot;slims&quot;,&quot;cloys&quot;,&quot;yates&quot;,&quot;rails&quot;,&quot;sheep&quot;,&quot;nacho&quot;,&quot;divan&quot;,&quot;honks&quot;,&quot;stone&quot;,&quot;snack&quot;,&quot;added&quot;,&quot;basal&quot;,&quot;hasps&quot;,&quot;focus&quot;,&quot;alone&quot;,&quot;laxes&quot;,&quot;arose&quot;,&quot;lamed&quot;,&quot;wrapt&quot;,&quot;frail&quot;,&quot;clams&quot;,&quot;plait&quot;,&quot;hover&quot;,&quot;tacos&quot;,&quot;mooch&quot;,&quot;fault&quot;,&quot;teeth&quot;,&quot;marva&quot;,&quot;mucks&quot;,&quot;tread&quot;,&quot;waves&quot;,&quot;purim&quot;,&quot;boron&quot;,&quot;horde&quot;,&quot;smack&quot;,&quot;bongo&quot;,&quot;monte&quot;,&quot;swirl&quot;,&quot;deals&quot;,&quot;mikes&quot;,&quot;scold&quot;,&quot;muter&quot;,&quot;sties&quot;,&quot;lawns&quot;,&quot;fluke&quot;,&quot;jilts&quot;,&quot;meuse&quot;,&quot;fives&quot;,&quot;sulky&quot;,&quot;molds&quot;,&quot;snore&quot;,&quot;timmy&quot;,&quot;ditty&quot;,&quot;gasps&quot;,&quot;kills&quot;,&quot;carey&quot;,&quot;jawed&quot;,&quot;byers&quot;,&quot;tommy&quot;,&quot;homer&quot;,&quot;hexed&quot;,&quot;dumas&quot;,&quot;given&quot;,&quot;mewls&quot;,&quot;smelt&quot;,&quot;weird&quot;,&quot;speck&quot;,&quot;merck&quot;,&quot;keats&quot;,&quot;draws&quot;,&quot;trent&quot;,&quot;agave&quot;,&quot;wells&quot;,&quot;chews&quot;,&quot;blabs&quot;,&quot;roves&quot;,&quot;grieg&quot;,&quot;evens&quot;,&quot;alive&quot;,&quot;mulls&quot;,&quot;cared&quot;,&quot;garbo&quot;,&quot;fined&quot;,&quot;happy&quot;,&quot;trued&quot;,&quot;rodes&quot;,&quot;thurs&quot;,&quot;cadet&quot;,&quot;alvin&quot;,&quot;busch&quot;,&quot;moths&quot;,&quot;guild&quot;,&quot;staci&quot;,&quot;lever&quot;,&quot;widen&quot;,&quot;props&quot;,&quot;hussy&quot;,&quot;lamer&quot;,&quot;riley&quot;,&quot;bauer&quot;,&quot;chirp&quot;,&quot;rants&quot;,&quot;poxes&quot;,&quot;shyer&quot;,&quot;pelts&quot;,&quot;funny&quot;,&quot;slits&quot;,&quot;tinge&quot;,&quot;ramos&quot;,&quot;shift&quot;,&quot;caper&quot;,&quot;credo&quot;,&quot;renal&quot;,&quot;veils&quot;,&quot;covey&quot;,&quot;elmer&quot;,&quot;mated&quot;,&quot;tykes&quot;,&quot;wooed&quot;,&quot;briar&quot;,&quot;gears&quot;,&quot;foley&quot;,&quot;shoes&quot;,&quot;decry&quot;,&quot;hypes&quot;,&quot;dells&quot;,&quot;wilds&quot;,&quot;runts&quot;,&quot;wilts&quot;,&quot;white&quot;,&quot;easts&quot;,&quot;comer&quot;,&quot;sammy&quot;,&quot;lochs&quot;,&quot;favor&quot;,&quot;lance&quot;,&quot;dawns&quot;,&quot;bushy&quot;,&quot;muted&quot;,&quot;elsie&quot;,&quot;creel&quot;,&quot;pocks&quot;,&quot;tenet&quot;,&quot;cagey&quot;,&quot;rides&quot;,&quot;socks&quot;,&quot;ogled&quot;,&quot;soils&quot;,&quot;sofas&quot;,&quot;janna&quot;,&quot;exile&quot;,&quot;barks&quot;,&quot;frank&quot;,&quot;takes&quot;,&quot;zooms&quot;,&quot;hakes&quot;,&quot;sagan&quot;,&quot;scull&quot;,&quot;heaps&quot;,&quot;augur&quot;,&quot;pouch&quot;,&quot;blare&quot;,&quot;bulbs&quot;,&quot;wryly&quot;,&quot;homey&quot;,&quot;tubas&quot;,&quot;limbo&quot;,&quot;hardy&quot;,&quot;hoagy&quot;,&quot;minds&quot;,&quot;bared&quot;,&quot;gabby&quot;,&quot;bilks&quot;,&quot;float&quot;,&quot;limns&quot;,&quot;clasp&quot;,&quot;laura&quot;,&quot;range&quot;,&quot;brush&quot;,&quot;tummy&quot;,&quot;kilts&quot;,&quot;cooed&quot;,&quot;worms&quot;,&quot;leary&quot;,&quot;feats&quot;,&quot;robes&quot;,&quot;suite&quot;,&quot;veals&quot;,&quot;bosch&quot;,&quot;moans&quot;,&quot;dozen&quot;,&quot;rarer&quot;,&quot;slyer&quot;,&quot;cabin&quot;,&quot;craze&quot;,&quot;sweet&quot;,&quot;talon&quot;,&quot;treat&quot;,&quot;yanks&quot;,&quot;react&quot;,&quot;creed&quot;,&quot;eliza&quot;,&quot;sluts&quot;,&quot;cruet&quot;,&quot;hafts&quot;,&quot;noise&quot;,&quot;seder&quot;,&quot;flies&quot;,&quot;weeks&quot;,&quot;venus&quot;,&quot;backs&quot;,&quot;eider&quot;,&quot;uriel&quot;,&quot;vouch&quot;,&quot;robed&quot;,&quot;hacks&quot;,&quot;perth&quot;,&quot;shiny&quot;,&quot;stilt&quot;,&quot;torte&quot;,&quot;throb&quot;,&quot;merer&quot;,&quot;twits&quot;,&quot;reeds&quot;,&quot;shawl&quot;,&quot;clara&quot;,&quot;slurs&quot;,&quot;mixer&quot;,&quot;newts&quot;,&quot;fried&quot;,&quot;woolf&quot;,&quot;swoop&quot;,&quot;kaaba&quot;,&quot;oozed&quot;,&quot;mayer&quot;,&quot;caned&quot;,&quot;laius&quot;,&quot;lunge&quot;,&quot;chits&quot;,&quot;kenny&quot;,&quot;lifts&quot;,&quot;mafia&quot;,&quot;sowed&quot;,&quot;piled&quot;,&quot;stein&quot;,&quot;whack&quot;,&quot;colts&quot;,&quot;warms&quot;,&quot;cleft&quot;,&quot;girds&quot;,&quot;seeks&quot;,&quot;poets&quot;,&quot;angel&quot;,&quot;trade&quot;,&quot;parsi&quot;,&quot;tiers&quot;,&quot;rojas&quot;,&quot;vexes&quot;,&quot;bryce&quot;,&quot;moots&quot;,&quot;grunt&quot;,&quot;drain&quot;,&quot;lumpy&quot;,&quot;stabs&quot;,&quot;poohs&quot;,&quot;leapt&quot;,&quot;polly&quot;,&quot;cuffs&quot;,&quot;giddy&quot;,&quot;towns&quot;,&quot;dacha&quot;,&quot;quoth&quot;,&quot;provo&quot;,&quot;dilly&quot;,&quot;carly&quot;,&quot;mewed&quot;,&quot;tzars&quot;,&quot;crock&quot;,&quot;toked&quot;,&quot;speak&quot;,&quot;mayas&quot;,&quot;pssts&quot;,&quot;ocher&quot;,&quot;motel&quot;,&quot;vogue&quot;,&quot;camps&quot;,&quot;tharp&quot;,&quot;taunt&quot;,&quot;drone&quot;,&quot;taint&quot;,&quot;badge&quot;,&quot;scott&quot;,&quot;scats&quot;,&quot;bakes&quot;,&quot;antes&quot;,&quot;gruel&quot;,&quot;snort&quot;,&quot;capes&quot;,&quot;plate&quot;,&quot;folly&quot;,&quot;adobe&quot;,&quot;yours&quot;,&quot;papaw&quot;,&quot;hench&quot;,&quot;moods&quot;,&quot;clunk&quot;,&quot;chevy&quot;,&quot;tomas&quot;,&quot;narcs&quot;,&quot;vonda&quot;,&quot;wiles&quot;,&quot;prigs&quot;,&quot;chock&quot;,&quot;laser&quot;,&quot;viced&quot;,&quot;stiff&quot;,&quot;rouse&quot;,&quot;helps&quot;,&quot;knead&quot;,&quot;gazer&quot;,&quot;blade&quot;,&quot;tumid&quot;,&quot;avail&quot;,&quot;anger&quot;,&quot;egged&quot;,&quot;guide&quot;,&quot;goads&quot;,&quot;rabin&quot;,&quot;toddy&quot;,&quot;gulps&quot;,&quot;flank&quot;,&quot;brats&quot;,&quot;pedal&quot;,&quot;junky&quot;,&quot;marco&quot;,&quot;tinny&quot;,&quot;tires&quot;,&quot;flier&quot;,&quot;satin&quot;,&quot;darth&quot;,&quot;paley&quot;,&quot;gumbo&quot;,&quot;rared&quot;,&quot;muffs&quot;,&quot;rower&quot;,&quot;prude&quot;,&quot;frees&quot;,&quot;quays&quot;,&quot;homes&quot;,&quot;munch&quot;,&quot;beefs&quot;,&quot;leash&quot;,&quot;aston&quot;,&quot;colon&quot;,&quot;finch&quot;,&quot;bogey&quot;,&quot;leaps&quot;,&quot;tempo&quot;,&quot;posts&quot;,&quot;lined&quot;,&quot;gapes&quot;,&quot;locus&quot;,&quot;maori&quot;,&quot;nixes&quot;,&quot;liven&quot;,&quot;songs&quot;,&quot;opted&quot;,&quot;babel&quot;,&quot;wader&quot;,&quot;barer&quot;,&quot;farts&quot;,&quot;lisps&quot;,&quot;koran&quot;,&quot;lathe&quot;,&quot;trill&quot;,&quot;smirk&quot;,&quot;mamma&quot;,&quot;viler&quot;,&quot;scurf&quot;,&quot;ravel&quot;,&quot;brigs&quot;,&quot;cooky&quot;,&quot;sachs&quot;,&quot;fulls&quot;,&quot;goals&quot;,&quot;turfs&quot;,&quot;norse&quot;,&quot;hauls&quot;,&quot;cores&quot;,&quot;fairy&quot;,&quot;pluto&quot;,&quot;kneed&quot;,&quot;cheek&quot;,&quot;pangs&quot;,&quot;risen&quot;,&quot;czars&quot;,&quot;milne&quot;,&quot;cribs&quot;,&quot;genes&quot;,&quot;wefts&quot;,&quot;vents&quot;,&quot;sages&quot;,&quot;seres&quot;,&quot;owens&quot;,&quot;wiley&quot;,&quot;flume&quot;,&quot;haded&quot;,&quot;auger&quot;,&quot;tatty&quot;,&quot;onion&quot;,&quot;cater&quot;,&quot;wolfe&quot;,&quot;magic&quot;,&quot;bodes&quot;,&quot;gulls&quot;,&quot;gazes&quot;,&quot;dandy&quot;,&quot;snags&quot;,&quot;rowed&quot;,&quot;quell&quot;,&quot;spurn&quot;,&quot;shore&quot;,&quot;veldt&quot;,&quot;turns&quot;,&quot;slavs&quot;,&quot;coach&quot;,&quot;stalk&quot;,&quot;snuck&quot;,&quot;piles&quot;,&quot;orate&quot;,&quot;joyed&quot;,&quot;daily&quot;,&quot;crone&quot;,&quot;wager&quot;,&quot;solos&quot;,&quot;earns&quot;,&quot;stark&quot;,&quot;lauds&quot;,&quot;kasey&quot;,&quot;villa&quot;,&quot;gnaws&quot;,&quot;scent&quot;,&quot;wears&quot;,&quot;fains&quot;,&quot;laced&quot;,&quot;tamer&quot;,&quot;pipes&quot;,&quot;plant&quot;,&quot;lorie&quot;,&quot;rivet&quot;,&quot;tamed&quot;,&quot;cozen&quot;,&quot;theme&quot;,&quot;lifer&quot;,&quot;sunny&quot;,&quot;shags&quot;,&quot;flack&quot;,&quot;gassy&quot;,&quot;eased&quot;,&quot;jeeps&quot;,&quot;shire&quot;,&quot;fargo&quot;,&quot;timer&quot;,&quot;brash&quot;,&quot;behan&quot;,&quot;basin&quot;,&quot;volga&quot;,&quot;krone&quot;,&quot;swiss&quot;,&quot;docks&quot;,&quot;booed&quot;,&quot;ebert&quot;,&quot;gusty&quot;,&quot;delay&quot;,&quot;oared&quot;,&quot;grady&quot;,&quot;buick&quot;,&quot;curbs&quot;,&quot;crete&quot;,&quot;lucas&quot;,&quot;strum&quot;,&quot;besom&quot;,&quot;gorse&quot;,&quot;troth&quot;,&quot;donne&quot;,&quot;chink&quot;,&quot;faced&quot;,&quot;ahmed&quot;,&quot;texas&quot;,&quot;longs&quot;,&quot;aloud&quot;,&quot;bethe&quot;,&quot;cacao&quot;,&quot;hilda&quot;,&quot;eagle&quot;,&quot;karyn&quot;,&quot;harks&quot;,&quot;adder&quot;,&quot;verse&quot;,&quot;drays&quot;,&quot;cello&quot;,&quot;taped&quot;,&quot;snide&quot;,&quot;taxis&quot;,&quot;kinky&quot;,&quot;penes&quot;,&quot;wicca&quot;,&quot;sonja&quot;,&quot;aways&quot;,&quot;dyers&quot;,&quot;bolas&quot;,&quot;elfin&quot;,&quot;slope&quot;,&quot;lamps&quot;,&quot;hutch&quot;,&quot;lobed&quot;,&quot;baaed&quot;,&quot;masts&quot;,&quot;ashes&quot;,&quot;ionic&quot;,&quot;joyce&quot;,&quot;payed&quot;,&quot;brays&quot;,&quot;malts&quot;,&quot;dregs&quot;,&quot;leaky&quot;,&quot;runny&quot;,&quot;fecal&quot;,&quot;woven&quot;,&quot;hurls&quot;,&quot;jorge&quot;,&quot;henna&quot;,&quot;dolby&quot;,&quot;booty&quot;,&quot;brett&quot;,&quot;dykes&quot;,&quot;rural&quot;,&quot;fight&quot;,&quot;feels&quot;,&quot;flogs&quot;,&quot;brunt&quot;,&quot;preen&quot;,&quot;elvis&quot;,&quot;dopey&quot;,&quot;gripe&quot;,&quot;garry&quot;,&quot;gamma&quot;,&quot;fling&quot;,&quot;space&quot;,&quot;mange&quot;,&quot;storm&quot;,&quot;arron&quot;,&quot;hairs&quot;,&quot;rogue&quot;,&quot;repel&quot;,&quot;elgar&quot;,&quot;ruddy&quot;,&quot;cross&quot;,&quot;medan&quot;,&quot;loses&quot;,&quot;howdy&quot;,&quot;foams&quot;,&quot;piker&quot;,&quot;halts&quot;,&quot;jewel&quot;,&quot;avery&quot;,&quot;stool&quot;,&quot;cruel&quot;,&quot;cases&quot;,&quot;ruses&quot;,&quot;cathy&quot;,&quot;harem&quot;,&quot;flour&quot;,&quot;meted&quot;,&quot;faces&quot;,&quot;hobos&quot;,&quot;charm&quot;,&quot;jamar&quot;,&quot;cameo&quot;,&quot;crape&quot;,&quot;hooey&quot;,&quot;reefs&quot;,&quot;denny&quot;,&quot;mitts&quot;,&quot;sores&quot;,&quot;smoky&quot;,&quot;nopes&quot;,&quot;sooty&quot;,&quot;twirl&quot;,&quot;toads&quot;,&quot;vader&quot;,&quot;julep&quot;,&quot;licks&quot;,&quot;arias&quot;,&quot;wrote&quot;,&quot;north&quot;,&quot;bunks&quot;,&quot;heady&quot;,&quot;batch&quot;,&quot;snaps&quot;,&quot;claws&quot;,&quot;fouls&quot;,&quot;faded&quot;,&quot;beans&quot;,&quot;wimps&quot;,&quot;idled&quot;,&quot;pulse&quot;,&quot;goons&quot;,&quot;noose&quot;,&quot;vowed&quot;,&quot;ronda&quot;,&quot;rajas&quot;,&quot;roast&quot;,&quot;allah&quot;,&quot;punic&quot;,&quot;slows&quot;,&quot;hours&quot;,&quot;metal&quot;,&quot;slier&quot;,&quot;meaty&quot;,&quot;hanna&quot;,&quot;curvy&quot;,&quot;mussy&quot;,&quot;truth&quot;,&quot;troys&quot;,&quot;block&quot;,&quot;reels&quot;,&quot;print&quot;,&quot;miffs&quot;,&quot;busts&quot;,&quot;bytes&quot;,&quot;cream&quot;,&quot;otter&quot;,&quot;grads&quot;,&quot;siren&quot;,&quot;kilos&quot;,&quot;dross&quot;,&quot;batty&quot;,&quot;debts&quot;,&quot;sully&quot;,&quot;bares&quot;,&quot;baggy&quot;,&quot;hippy&quot;,&quot;berth&quot;,&quot;gorky&quot;,&quot;argon&quot;,&quot;wacko&quot;,&quot;harry&quot;,&quot;smoke&quot;,&quot;fails&quot;,&quot;perms&quot;,&quot;score&quot;,&quot;steps&quot;,&quot;unity&quot;,&quot;couch&quot;,&quot;kelly&quot;,&quot;rumps&quot;,&quot;fines&quot;,&quot;mouth&quot;,&quot;broth&quot;,&quot;knows&quot;,&quot;becky&quot;,&quot;quits&quot;,&quot;lauri&quot;,&quot;trust&quot;,&quot;grows&quot;,&quot;logos&quot;,&quot;apter&quot;,&quot;burrs&quot;,&quot;zincs&quot;,&quot;buyer&quot;,&quot;bayer&quot;,&quot;moose&quot;,&quot;overt&quot;,&quot;croon&quot;,&quot;ousts&quot;,&quot;lands&quot;,&quot;lithe&quot;,&quot;poach&quot;,&quot;jamel&quot;,&quot;waive&quot;,&quot;wiser&quot;,&quot;surly&quot;,&quot;works&quot;,&quot;paine&quot;,&quot;medal&quot;,&quot;glads&quot;,&quot;gybed&quot;,&quot;paint&quot;,&quot;lorre&quot;,&quot;meant&quot;,&quot;smugs&quot;,&quot;bryon&quot;,&quot;jinni&quot;,&quot;sever&quot;,&quot;viols&quot;,&quot;flubs&quot;,&quot;melts&quot;,&quot;heads&quot;,&quot;peals&quot;,&quot;aiken&quot;,&quot;named&quot;,&quot;teary&quot;,&quot;yalta&quot;,&quot;styes&quot;,&quot;heist&quot;,&quot;bongs&quot;,&quot;slops&quot;,&quot;pouts&quot;,&quot;grape&quot;,&quot;belie&quot;,&quot;cloak&quot;,&quot;rocks&quot;,&quot;scone&quot;,&quot;lydia&quot;,&quot;goofs&quot;,&quot;rents&quot;,&quot;drive&quot;,&quot;crony&quot;,&quot;orlon&quot;,&quot;narks&quot;,&quot;plays&quot;,&quot;blips&quot;,&quot;pence&quot;,&quot;march&quot;,&quot;alger&quot;,&quot;baste&quot;,&quot;acorn&quot;,&quot;billy&quot;,&quot;croce&quot;,&quot;boone&quot;,&quot;aaron&quot;,&quot;slobs&quot;,&quot;idyls&quot;,&quot;irwin&quot;,&quot;elves&quot;,&quot;stoat&quot;,&quot;doing&quot;,&quot;globe&quot;,&quot;verve&quot;,&quot;icons&quot;,&quot;trial&quot;,&quot;olsen&quot;,&quot;pecks&quot;,&quot;there&quot;,&quot;blame&quot;,&quot;tilde&quot;,&quot;milky&quot;,&quot;sells&quot;,&quot;tangy&quot;,&quot;wrack&quot;,&quot;fills&quot;,&quot;lofty&quot;,&quot;truce&quot;,&quot;quark&quot;,&quot;delia&quot;,&quot;stowe&quot;,&quot;marty&quot;,&quot;overs&quot;,&quot;putty&quot;,&quot;coral&quot;,&quot;swine&quot;,&quot;stats&quot;,&quot;swags&quot;,&quot;weans&quot;,&quot;spout&quot;,&quot;bulky&quot;,&quot;farsi&quot;,&quot;brest&quot;,&quot;gleam&quot;,&quot;beaks&quot;,&quot;coons&quot;,&quot;hater&quot;,&quot;peony&quot;,&quot;huffy&quot;,&quot;exert&quot;,&quot;clips&quot;,&quot;riven&quot;,&quot;payer&quot;,&quot;doped&quot;,&quot;salas&quot;,&quot;meyer&quot;,&quot;dryad&quot;,&quot;thuds&quot;,&quot;tilts&quot;,&quot;quilt&quot;,&quot;jetty&quot;,&quot;brood&quot;,&quot;gulch&quot;,&quot;corps&quot;,&quot;tunic&quot;,&quot;hubby&quot;,&quot;slang&quot;,&quot;wreck&quot;,&quot;purrs&quot;,&quot;punch&quot;,&quot;drags&quot;,&quot;chide&quot;,&quot;sulks&quot;,&quot;tints&quot;,&quot;huger&quot;,&quot;roped&quot;,&quot;dopes&quot;,&quot;booby&quot;,&quot;rosin&quot;,&quot;outer&quot;,&quot;gusto&quot;,&quot;tents&quot;,&quot;elude&quot;,&quot;brows&quot;,&quot;lease&quot;,&quot;ceres&quot;,&quot;laxer&quot;,&quot;worth&quot;,&quot;necks&quot;,&quot;races&quot;,&quot;corey&quot;,&quot;trait&quot;,&quot;stuns&quot;,&quot;soles&quot;,&quot;teems&quot;,&quot;scrip&quot;,&quot;privy&quot;,&quot;sight&quot;,&quot;minor&quot;,&quot;alisa&quot;,&quot;stray&quot;,&quot;spank&quot;,&quot;cress&quot;,&quot;nukes&quot;,&quot;rises&quot;,&quot;gusts&quot;,&quot;aurae&quot;,&quot;karma&quot;,&quot;icing&quot;,&quot;prose&quot;,&quot;biked&quot;,&quot;grand&quot;,&quot;grasp&quot;,&quot;skein&quot;,&quot;shaky&quot;,&quot;clump&quot;,&quot;rummy&quot;,&quot;stock&quot;,&quot;twain&quot;,&quot;zoned&quot;,&quot;offed&quot;,&quot;ghats&quot;,&quot;mover&quot;,&quot;randy&quot;,&quot;vault&quot;,&quot;craws&quot;,&quot;thees&quot;,&quot;salem&quot;,&quot;downy&quot;,&quot;sangs&quot;,&quot;chore&quot;,&quot;cited&quot;,&quot;grave&quot;,&quot;spinx&quot;,&quot;erica&quot;,&quot;raspy&quot;,&quot;dying&quot;,&quot;skips&quot;,&quot;clerk&quot;,&quot;paste&quot;,&quot;moved&quot;,&quot;rooks&quot;,&quot;intel&quot;,&quot;moses&quot;,&quot;avers&quot;,&quot;staid&quot;,&quot;yawls&quot;,&quot;blast&quot;,&quot;lyres&quot;,&quot;monks&quot;,&quot;gaits&quot;,&quot;floor&quot;,&quot;saner&quot;,&quot;waver&quot;,&quot;assam&quot;,&quot;infer&quot;,&quot;wands&quot;,&quot;bunch&quot;,&quot;dryly&quot;,&quot;weedy&quot;,&quot;honey&quot;,&quot;baths&quot;,&quot;leach&quot;,&quot;shorn&quot;,&quot;shows&quot;,&quot;dream&quot;,&quot;value&quot;,&quot;dooms&quot;,&quot;spiro&quot;,&quot;raped&quot;,&quot;shook&quot;,&quot;stead&quot;,&quot;moran&quot;,&quot;ditto&quot;,&quot;loots&quot;,&quot;tapir&quot;,&quot;looms&quot;,&quot;clove&quot;,&quot;stops&quot;,&quot;pinks&quot;,&quot;soppy&quot;,&quot;ripen&quot;,&quot;wench&quot;,&quot;shone&quot;,&quot;bauds&quot;,&quot;doric&quot;,&quot;leans&quot;,&quot;nadia&quot;,&quot;cries&quot;,&quot;camus&quot;,&quot;boozy&quot;,&quot;maris&quot;,&quot;fools&quot;,&quot;morns&quot;,&quot;bides&quot;,&quot;greek&quot;,&quot;gauss&quot;,&quot;roget&quot;,&quot;lamar&quot;,&quot;hazes&quot;,&quot;beefy&quot;,&quot;dupes&quot;,&quot;refed&quot;,&quot;felts&quot;,&quot;larry&quot;,&quot;guile&quot;,&quot;ables&quot;,&quot;wants&quot;,&quot;warns&quot;,&quot;toils&quot;,&quot;bathe&quot;,&quot;edger&quot;,&quot;paced&quot;,&quot;rinks&quot;,&quot;shoos&quot;,&quot;erich&quot;,&quot;whore&quot;,&quot;tiger&quot;,&quot;jumpy&quot;,&quot;lamas&quot;,&quot;stack&quot;,&quot;among&quot;,&quot;punts&quot;,&quot;scalp&quot;,&quot;alloy&quot;,&quot;solon&quot;,&quot;quite&quot;,&quot;comas&quot;,&quot;whole&quot;,&quot;parse&quot;,&quot;tries&quot;,&quot;reeve&quot;,&quot;tiled&quot;,&quot;deena&quot;,&quot;roomy&quot;,&quot;rodin&quot;,&quot;aster&quot;,&quot;twice&quot;,&quot;musts&quot;,&quot;globs&quot;,&quot;parch&quot;,&quot;drawn&quot;,&quot;filch&quot;,&quot;bonds&quot;,&quot;tells&quot;,&quot;droop&quot;,&quot;janis&quot;,&quot;holds&quot;,&quot;scant&quot;,&quot;lopes&quot;,&quot;based&quot;,&quot;keven&quot;,&quot;whiny&quot;,&quot;aspic&quot;,&quot;gains&quot;,&quot;franz&quot;,&quot;jerri&quot;,&quot;steel&quot;,&quot;rowel&quot;,&quot;vends&quot;,&quot;yelps&quot;,&quot;begin&quot;,&quot;logic&quot;,&quot;tress&quot;,&quot;sunni&quot;,&quot;going&quot;,&quot;barge&quot;,&quot;blood&quot;,&quot;burns&quot;,&quot;basks&quot;,&quot;waifs&quot;,&quot;bones&quot;,&quot;skill&quot;,&quot;hewer&quot;,&quot;burly&quot;,&quot;clime&quot;,&quot;eking&quot;,&quot;withs&quot;,&quot;capek&quot;,&quot;berta&quot;,&quot;cheap&quot;,&quot;films&quot;,&quot;scoot&quot;,&quot;tweed&quot;,&quot;sizer&quot;,&quot;wheat&quot;,&quot;acton&quot;,&quot;flung&quot;,&quot;ponds&quot;,&quot;tracy&quot;,&quot;fiver&quot;,&quot;berra&quot;,&quot;roger&quot;,&quot;mutes&quot;,&quot;burke&quot;,&quot;miked&quot;,&quot;valve&quot;,&quot;whisk&quot;,&quot;runes&quot;,&quot;parry&quot;,&quot;toots&quot;,&quot;japes&quot;,&quot;roars&quot;,&quot;rough&quot;,&quot;irons&quot;,&quot;romeo&quot;,&quot;cages&quot;,&quot;reeks&quot;,&quot;cigar&quot;,&quot;saiph&quot;,&quot;dully&quot;,&quot;hangs&quot;,&quot;chops&quot;,&quot;rolls&quot;,&quot;prick&quot;,&quot;acuff&quot;,&quot;spent&quot;,&quot;sulla&quot;,&quot;train&quot;,&quot;swell&quot;,&quot;frets&quot;,&quot;names&quot;,&quot;anita&quot;,&quot;crazy&quot;,&quot;sixth&quot;,&quot;blunt&quot;,&quot;fewer&quot;,&quot;large&quot;,&quot;brand&quot;,&quot;slick&quot;,&quot;spitz&quot;,&quot;rears&quot;,&quot;ogres&quot;,&quot;toffy&quot;,&quot;yolks&quot;,&quot;flock&quot;,&quot;gnawn&quot;,&quot;eries&quot;,&quot;blink&quot;,&quot;skier&quot;,&quot;feted&quot;,&quot;tones&quot;,&quot;snail&quot;,&quot;ether&quot;,&quot;barbs&quot;,&quot;noses&quot;,&quot;hears&quot;,&quot;upset&quot;,&quot;awash&quot;,&quot;cloud&quot;,&quot;trunk&quot;,&quot;degas&quot;,&quot;dungs&quot;,&quot;rated&quot;,&quot;shall&quot;,&quot;yeahs&quot;,&quot;coven&quot;,&quot;sands&quot;,&quot;susan&quot;,&quot;fable&quot;,&quot;gunny&quot;,&quot;began&quot;,&quot;serfs&quot;,&quot;balls&quot;,&quot;dinky&quot;,&quot;madge&quot;,&quot;prong&quot;,&quot;spilt&quot;,&quot;lilly&quot;,&quot;brawn&quot;,&quot;comet&quot;,&quot;spins&quot;,&quot;raids&quot;,&quot;dries&quot;,&quot;sorts&quot;,&quot;makes&quot;,&quot;mason&quot;,&quot;mayra&quot;,&quot;royce&quot;,&quot;stout&quot;,&quot;mealy&quot;,&quot;pagan&quot;,&quot;nasal&quot;,&quot;folds&quot;,&quot;libby&quot;,&quot;coups&quot;,&quot;photo&quot;,&quot;mosey&quot;,&quot;amens&quot;,&quot;speed&quot;,&quot;lords&quot;,&quot;board&quot;,&quot;fetal&quot;,&quot;lagos&quot;,&quot;scope&quot;,&quot;raked&quot;,&quot;bonus&quot;,&quot;mutts&quot;,&quot;willy&quot;,&quot;sport&quot;,&quot;bingo&quot;,&quot;thant&quot;,&quot;araby&quot;,&quot;bette&quot;,&quot;rebel&quot;,&quot;gases&quot;,&quot;small&quot;,&quot;humus&quot;,&quot;grosz&quot;,&quot;beset&quot;,&quot;slays&quot;,&quot;steve&quot;,&quot;scrap&quot;,&quot;blahs&quot;,&quot;south&quot;,&quot;pride&quot;,&quot;heels&quot;,&quot;tubes&quot;,&quot;beady&quot;,&quot;lacey&quot;,&quot;genus&quot;,&quot;mauls&quot;,&quot;vying&quot;,&quot;spice&quot;,&quot;sexes&quot;,&quot;ester&quot;,&quot;drams&quot;,&quot;today&quot;,&quot;comae&quot;,&quot;under&quot;,&quot;jests&quot;,&quot;direr&quot;,&quot;yoked&quot;,&quot;tempi&quot;,&quot;early&quot;,&quot;boats&quot;,&quot;jesus&quot;,&quot;warts&quot;,&quot;guppy&quot;,&quot;gilda&quot;,&quot;quota&quot;,&quot;token&quot;,&quot;edwin&quot;,&quot;ringo&quot;,&quot;gaped&quot;,&quot;lemon&quot;,&quot;hurst&quot;,&quot;manor&quot;,&quot;arrow&quot;,&quot;mists&quot;,&quot;prize&quot;,&quot;silas&quot;,&quot;blobs&quot;,&quot;diets&quot;,&quot;ervin&quot;,&quot;stony&quot;,&quot;buddy&quot;,&quot;bates&quot;,&quot;rabid&quot;,&quot;ducat&quot;,&quot;ewing&quot;,&quot;jaunt&quot;,&quot;beads&quot;,&quot;doyen&quot;,&quot;blush&quot;,&quot;thoth&quot;,&quot;tiles&quot;,&quot;piper&quot;,&quot;short&quot;,&quot;peron&quot;,&quot;alley&quot;,&quot;decks&quot;,&quot;shunt&quot;,&quot;whirs&quot;,&quot;cushy&quot;,&quot;roils&quot;,&quot;betty&quot;,&quot;plugs&quot;,&quot;woken&quot;,&quot;jibes&quot;,&quot;foray&quot;,&quot;merak&quot;,&quot;ruing&quot;,&quot;becks&quot;,&quot;whale&quot;,&quot;shoot&quot;,&quot;dwelt&quot;,&quot;spawn&quot;,&quot;fairs&quot;,&quot;dozed&quot;,&quot;celts&quot;,&quot;blond&quot;,&quot;tikes&quot;,&quot;sabin&quot;,&quot;feint&quot;,&quot;vamps&quot;,&quot;cokes&quot;,&quot;willa&quot;,&quot;slues&quot;,&quot;bills&quot;,&quot;force&quot;,&quot;curst&quot;,&quot;yokel&quot;,&quot;surer&quot;,&quot;miler&quot;,&quot;fices&quot;,&quot;arced&quot;,&quot;douse&quot;,&quot;hilly&quot;,&quot;lucio&quot;,&quot;tongs&quot;,&quot;togas&quot;,&quot;minty&quot;,&quot;sagas&quot;,&quot;pates&quot;,&quot;welsh&quot;,&quot;bruno&quot;,&quot;decal&quot;,&quot;elate&quot;,&quot;linux&quot;,&quot;gyros&quot;,&quot;pryor&quot;,&quot;mousy&quot;,&quot;pains&quot;,&quot;shake&quot;,&quot;spica&quot;,&quot;pupal&quot;,&quot;probe&quot;,&quot;mount&quot;,&quot;shirk&quot;,&quot;purus&quot;,&quot;kilns&quot;,&quot;rests&quot;,&quot;graze&quot;,&quot;hague&quot;,&quot;spuds&quot;,&quot;sweep&quot;,&quot;momma&quot;,&quot;burch&quot;,&quot;maces&quot;,&quot;samar&quot;,&quot;brace&quot;,&quot;riser&quot;,&quot;booms&quot;,&quot;build&quot;,&quot;camel&quot;,&quot;flyer&quot;,&quot;synge&quot;,&quot;sauna&quot;,&quot;tonga&quot;,&quot;tings&quot;,&quot;promo&quot;,&quot;hides&quot;,&quot;clair&quot;,&quot;elisa&quot;,&quot;bower&quot;,&quot;reins&quot;,&quot;diann&quot;,&quot;lubed&quot;,&quot;nulls&quot;,&quot;picks&quot;,&quot;laban&quot;,&quot;milch&quot;,&quot;buber&quot;,&quot;stomp&quot;,&quot;bosom&quot;,&quot;lying&quot;,&quot;haled&quot;,&quot;avert&quot;,&quot;wries&quot;,&quot;macon&quot;,&quot;skids&quot;,&quot;fumed&quot;,&quot;ogles&quot;,&quot;clods&quot;,&quot;antic&quot;,&quot;nosey&quot;,&quot;crimp&quot;,&quot;purge&quot;,&quot;mommy&quot;,&quot;cased&quot;,&quot;taxes&quot;,&quot;covet&quot;,&quot;clack&quot;,&quot;butch&quot;,&quot;panty&quot;,&quot;lents&quot;,&quot;machs&quot;,&quot;exude&quot;,&quot;tooth&quot;,&quot;adore&quot;,&quot;shuck&quot;,&quot;asses&quot;,&quot;after&quot;,&quot;terra&quot;,&quot;dices&quot;,&quot;aryan&quot;,&quot;regor&quot;,&quot;romes&quot;,&quot;stile&quot;,&quot;cairo&quot;,&quot;maura&quot;,&quot;flail&quot;,&quot;eaves&quot;,&quot;estes&quot;,&quot;sousa&quot;,&quot;visas&quot;,&quot;baron&quot;,&quot;civet&quot;,&quot;kitty&quot;,&quot;freed&quot;,&quot;ralph&quot;,&quot;tango&quot;,&quot;gawks&quot;,&quot;cheat&quot;,&quot;study&quot;,&quot;fancy&quot;,&quot;fiber&quot;,&quot;musks&quot;,&quot;souse&quot;,&quot;brims&quot;,&quot;claim&quot;,&quot;bikes&quot;,&quot;venue&quot;,&quot;sired&quot;,&quot;thymi&quot;,&quot;rivas&quot;,&quot;skimp&quot;,&quot;pleas&quot;,&quot;woman&quot;,&quot;gimpy&quot;,&quot;cawed&quot;,&quot;minos&quot;,&quot;pints&quot;,&quot;knock&quot;,&quot;poked&quot;,&quot;bowen&quot;,&quot;risky&quot;,&quot;towel&quot;,&quot;oinks&quot;,&quot;linus&quot;,&quot;heals&quot;,&quot;pears&quot;,&quot;codas&quot;,&quot;inner&quot;,&quot;pitch&quot;,&quot;harpy&quot;,&quot;niger&quot;,&quot;madly&quot;,&quot;bumpy&quot;,&quot;stair&quot;,&quot;files&quot;,&quot;nobel&quot;,&quot;celli&quot;,&quot;spars&quot;,&quot;jades&quot;,&quot;balmy&quot;,&quot;kooky&quot;,&quot;plums&quot;,&quot;trues&quot;,&quot;gloss&quot;,&quot;trims&quot;,&quot;daunt&quot;,&quot;tubby&quot;,&quot;dared&quot;,&quot;wadis&quot;,&quot;smell&quot;,&quot;darby&quot;,&quot;stink&quot;,&quot;drill&quot;,&quot;dover&quot;,&quot;ruler&quot;,&quot;laden&quot;,&quot;dikes&quot;,&quot;layla&quot;,&quot;fells&quot;,&quot;maker&quot;,&quot;joked&quot;,&quot;horns&quot;,&quot;these&quot;,&quot;baize&quot;,&quot;spahn&quot;,&quot;whens&quot;,&quot;edged&quot;,&quot;mushy&quot;,&quot;plume&quot;,&quot;tucks&quot;,&quot;spurs&quot;,&quot;husky&quot;,&quot;dried&quot;,&quot;bigot&quot;,&quot;pupas&quot;,&quot;drily&quot;,&quot;aware&quot;,&quot;hagar&quot;,&quot;newly&quot;,&quot;knots&quot;,&quot;pratt&quot;,&quot;feces&quot;,&quot;sabik&quot;,&quot;watts&quot;,&quot;cooke&quot;,&quot;riles&quot;,&quot;seamy&quot;,&quot;fleas&quot;,&quot;dusts&quot;,&quot;barfs&quot;,&quot;roans&quot;,&quot;pawns&quot;,&quot;vivid&quot;,&quot;kirks&quot;,&quot;tania&quot;,&quot;feral&quot;,&quot;tubae&quot;,&quot;horne&quot;,&quot;aries&quot;,&quot;brits&quot;,&quot;combs&quot;,&quot;chunk&quot;,&quot;stork&quot;,&quot;waned&quot;,&quot;texan&quot;,&quot;elide&quot;,&quot;glens&quot;,&quot;emery&quot;,&quot;autos&quot;,&quot;trams&quot;,&quot;dosed&quot;,&quot;cheri&quot;,&quot;baits&quot;,&quot;jacks&quot;,&quot;whose&quot;,&quot;fazed&quot;,&quot;matte&quot;,&quot;swans&quot;,&quot;maxed&quot;,&quot;write&quot;,&quot;spays&quot;,&quot;orion&quot;,&quot;traci&quot;,&quot;horse&quot;,&quot;stars&quot;,&quot;strut&quot;,&quot;goods&quot;,&quot;verge&quot;,&quot;scuff&quot;,&quot;award&quot;,&quot;dives&quot;,&quot;wires&quot;,&quot;burnt&quot;,&quot;dimly&quot;,&quot;sleds&quot;,&quot;mayan&quot;,&quot;biped&quot;,&quot;quirk&quot;,&quot;sofia&quot;,&quot;slabs&quot;,&quot;waste&quot;,&quot;robby&quot;,&quot;mayor&quot;,&quot;fatty&quot;,&quot;items&quot;,&quot;bowel&quot;,&quot;mires&quot;,&quot;swarm&quot;,&quot;route&quot;,&quot;swash&quot;,&quot;sooth&quot;,&quot;paved&quot;,&quot;steak&quot;,&quot;upend&quot;,&quot;sough&quot;,&quot;throw&quot;,&quot;perts&quot;,&quot;stave&quot;,&quot;carry&quot;,&quot;burgs&quot;,&quot;hilts&quot;,&quot;plane&quot;,&quot;toady&quot;,&quot;nadir&quot;,&quot;stick&quot;,&quot;foist&quot;,&quot;gnarl&quot;,&quot;spain&quot;,&quot;enter&quot;,&quot;sises&quot;,&quot;story&quot;,&quot;scarf&quot;,&quot;ryder&quot;,&quot;glums&quot;,&quot;nappy&quot;,&quot;sixes&quot;,&quot;honed&quot;,&quot;marcy&quot;,&quot;offer&quot;,&quot;kneel&quot;,&quot;leeds&quot;,&quot;lites&quot;,&quot;voter&quot;,&quot;vince&quot;,&quot;bursa&quot;,&quot;heave&quot;,&quot;roses&quot;,&quot;trees&quot;,&quot;argos&quot;,&quot;leann&quot;,&quot;grimy&quot;,&quot;zelma&quot;,&quot;crick&quot;,&quot;tract&quot;,&quot;flips&quot;,&quot;folks&quot;,&quot;smote&quot;,&quot;brier&quot;,&quot;moore&quot;,&quot;goose&quot;,&quot;baden&quot;,&quot;riled&quot;,&quot;looks&quot;,&quot;sober&quot;,&quot;tusks&quot;,&quot;house&quot;,&quot;acmes&quot;,&quot;lubes&quot;,&quot;chows&quot;,&quot;neath&quot;,&quot;vivas&quot;,&quot;defer&quot;,&quot;allay&quot;,&quot;casey&quot;,&quot;kmart&quot;,&quot;pests&quot;,&quot;proms&quot;,&quot;eying&quot;,&quot;cider&quot;,&quot;leave&quot;,&quot;shush&quot;,&quot;shots&quot;,&quot;karla&quot;,&quot;scorn&quot;,&quot;gifts&quot;,&quot;sneer&quot;,&quot;mercy&quot;,&quot;copes&quot;,&quot;faxed&quot;,&quot;spurt&quot;,&quot;monet&quot;,&quot;awoke&quot;,&quot;rocky&quot;,&quot;share&quot;,&quot;gores&quot;,&quot;drawl&quot;,&quot;tears&quot;,&quot;mooed&quot;,&quot;nones&quot;,&quot;wined&quot;,&quot;wrens&quot;,&quot;modem&quot;,&quot;beria&quot;,&quot;hovel&quot;,&quot;retch&quot;,&quot;mates&quot;,&quot;hands&quot;,&quot;stymy&quot;,&quot;peace&quot;,&quot;carat&quot;,&quot;coots&quot;,&quot;hotel&quot;,&quot;karen&quot;,&quot;hayed&quot;,&quot;mamet&quot;,&quot;cuing&quot;,&quot;paper&quot;,&quot;rages&quot;,&quot;suave&quot;,&quot;reuse&quot;,&quot;auden&quot;,&quot;costs&quot;,&quot;loner&quot;,&quot;rapes&quot;,&quot;hazel&quot;,&quot;rites&quot;,&quot;brent&quot;,&quot;pumps&quot;,&quot;dutch&quot;,&quot;puffs&quot;,&quot;noons&quot;,&quot;grams&quot;,&quot;teats&quot;,&quot;cease&quot;,&quot;honda&quot;,&quot;pricy&quot;,&quot;forgo&quot;,&quot;fleck&quot;,&quot;hired&quot;,&quot;silos&quot;,&quot;merge&quot;,&quot;rafts&quot;,&quot;halon&quot;,&quot;larks&quot;,&quot;deere&quot;,&quot;jello&quot;,&quot;cunts&quot;,&quot;sifts&quot;,&quot;boner&quot;,&quot;morin&quot;,&quot;mimes&quot;,&quot;bungs&quot;,&quot;marie&quot;,&quot;harts&quot;,&quot;snobs&quot;,&quot;sonic&quot;,&quot;hippo&quot;,&quot;comes&quot;,&quot;crops&quot;,&quot;mango&quot;,&quot;wrung&quot;,&quot;garbs&quot;,&quot;natty&quot;,&quot;cents&quot;,&quot;fitch&quot;,&quot;moldy&quot;,&quot;adams&quot;,&quot;sorta&quot;,&quot;coeds&quot;,&quot;gilds&quot;,&quot;kiddy&quot;,&quot;nervy&quot;,&quot;slurp&quot;,&quot;ramon&quot;,&quot;fuzed&quot;,&quot;hiker&quot;,&quot;winks&quot;,&quot;vanes&quot;,&quot;goody&quot;,&quot;hawks&quot;,&quot;crowd&quot;,&quot;bract&quot;,&quot;marla&quot;,&quot;limbs&quot;,&quot;solve&quot;,&quot;gloom&quot;,&quot;sloop&quot;,&quot;eaton&quot;,&quot;memos&quot;,&quot;tames&quot;,&quot;heirs&quot;,&quot;berms&quot;,&quot;wanes&quot;,&quot;faint&quot;,&quot;numbs&quot;,&quot;holes&quot;,&quot;grubs&quot;,&quot;rakes&quot;,&quot;waist&quot;,&quot;miser&quot;,&quot;stays&quot;,&quot;antis&quot;,&quot;marsh&quot;,&quot;skyed&quot;,&quot;payne&quot;,&quot;champ&quot;,&quot;jimmy&quot;,&quot;clues&quot;,&quot;fatal&quot;,&quot;shoed&quot;,&quot;freon&quot;,&quot;lopez&quot;,&quot;snowy&quot;,&quot;loins&quot;,&quot;stale&quot;,&quot;thank&quot;,&quot;reads&quot;,&quot;isles&quot;,&quot;grill&quot;,&quot;align&quot;,&quot;saxes&quot;,&quot;rubin&quot;,&quot;rigel&quot;,&quot;walls&quot;,&quot;beers&quot;,&quot;wispy&quot;,&quot;topic&quot;,&quot;alden&quot;,&quot;anton&quot;,&quot;ducts&quot;,&quot;david&quot;,&quot;duets&quot;,&quot;fries&quot;,&quot;oiled&quot;,&quot;waken&quot;,&quot;allot&quot;,&quot;swats&quot;,&quot;woozy&quot;,&quot;tuxes&quot;,&quot;inter&quot;,&quot;dunne&quot;,&quot;known&quot;,&quot;axles&quot;,&quot;graph&quot;,&quot;bumps&quot;,&quot;jerry&quot;,&quot;hitch&quot;,&quot;crews&quot;,&quot;lucia&quot;,&quot;banal&quot;,&quot;grope&quot;,&quot;valid&quot;,&quot;meres&quot;,&quot;thick&quot;,&quot;lofts&quot;,&quot;chaff&quot;,&quot;taker&quot;,&quot;glues&quot;,&quot;snubs&quot;,&quot;trawl&quot;,&quot;keels&quot;,&quot;liker&quot;,&quot;stand&quot;,&quot;harps&quot;,&quot;casks&quot;,&quot;nelly&quot;,&quot;debby&quot;,&quot;panes&quot;,&quot;dumps&quot;,&quot;norma&quot;,&quot;racks&quot;,&quot;scams&quot;,&quot;forte&quot;,&quot;dwell&quot;,&quot;dudes&quot;,&quot;hypos&quot;,&quot;sissy&quot;,&quot;swamp&quot;,&quot;faust&quot;,&quot;slake&quot;,&quot;maven&quot;,&quot;lowed&quot;,&quot;lilts&quot;,&quot;bobby&quot;,&quot;gorey&quot;,&quot;swear&quot;,&quot;nests&quot;,&quot;marci&quot;,&quot;palsy&quot;,&quot;siege&quot;,&quot;oozes&quot;,&quot;rates&quot;,&quot;stunt&quot;,&quot;herod&quot;,&quot;wilma&quot;,&quot;other&quot;,&quot;girts&quot;,&quot;conic&quot;,&quot;goner&quot;,&quot;peppy&quot;,&quot;class&quot;,&quot;sized&quot;,&quot;games&quot;,&quot;snell&quot;,&quot;newsy&quot;,&quot;amend&quot;,&quot;solis&quot;,&quot;duane&quot;,&quot;troop&quot;,&quot;linda&quot;,&quot;tails&quot;,&quot;woofs&quot;,&quot;scuds&quot;,&quot;shies&quot;,&quot;patti&quot;,&quot;stunk&quot;,&quot;acres&quot;,&quot;tevet&quot;,&quot;allen&quot;,&quot;carpi&quot;,&quot;meets&quot;,&quot;trend&quot;,&quot;salty&quot;,&quot;galls&quot;,&quot;crept&quot;,&quot;toner&quot;,&quot;panda&quot;,&quot;cohen&quot;,&quot;chase&quot;,&quot;james&quot;,&quot;bravo&quot;,&quot;styed&quot;,&quot;coals&quot;,&quot;oates&quot;,&quot;swami&quot;,&quot;staph&quot;,&quot;frisk&quot;,&quot;cares&quot;,&quot;cords&quot;,&quot;stems&quot;,&quot;razed&quot;,&quot;since&quot;,&quot;mopes&quot;,&quot;rices&quot;,&quot;junes&quot;,&quot;raged&quot;,&quot;liter&quot;,&quot;manes&quot;,&quot;rearm&quot;,&quot;naive&quot;,&quot;tyree&quot;,&quot;medic&quot;,&quot;laded&quot;,&quot;pearl&quot;,&quot;inset&quot;,&quot;graft&quot;,&quot;chair&quot;,&quot;votes&quot;,&quot;saver&quot;,&quot;cains&quot;,&quot;knobs&quot;,&quot;gamay&quot;,&quot;hunch&quot;,&quot;crags&quot;,&quot;olson&quot;,&quot;teams&quot;,&quot;surge&quot;,&quot;wests&quot;,&quot;boney&quot;,&quot;limos&quot;,&quot;ploys&quot;,&quot;algae&quot;,&quot;gaols&quot;,&quot;caked&quot;,&quot;molts&quot;,&quot;glops&quot;,&quot;tarot&quot;,&quot;wheal&quot;,&quot;cysts&quot;,&quot;husks&quot;,&quot;vaunt&quot;,&quot;beaus&quot;,&quot;fauns&quot;,&quot;jeers&quot;,&quot;mitty&quot;,&quot;stuff&quot;,&quot;shape&quot;,&quot;sears&quot;,&quot;buffy&quot;,&quot;maced&quot;,&quot;fazes&quot;,&quot;vegas&quot;,&quot;stamp&quot;,&quot;borer&quot;,&quot;gaged&quot;,&quot;shade&quot;,&quot;finds&quot;,&quot;frock&quot;,&quot;plods&quot;,&quot;skied&quot;,&quot;stump&quot;,&quot;ripes&quot;,&quot;chick&quot;,&quot;cones&quot;,&quot;fixed&quot;,&quot;coled&quot;,&quot;rodeo&quot;,&quot;basil&quot;,&quot;dazes&quot;,&quot;sting&quot;,&quot;surfs&quot;,&quot;mindy&quot;,&quot;creak&quot;,&quot;swung&quot;,&quot;cadge&quot;,&quot;franc&quot;,&quot;seven&quot;,&quot;sices&quot;,&quot;weest&quot;,&quot;unite&quot;,&quot;codex&quot;,&quot;trick&quot;,&quot;fusty&quot;,&quot;plaid&quot;,&quot;hills&quot;,&quot;truck&quot;,&quot;spiel&quot;,&quot;sleek&quot;,&quot;anons&quot;,&quot;pupae&quot;,&quot;chiba&quot;,&quot;hoops&quot;,&quot;trash&quot;,&quot;noted&quot;,&quot;boris&quot;,&quot;dough&quot;,&quot;shirt&quot;,&quot;cowls&quot;,&quot;seine&quot;,&quot;spool&quot;,&quot;miens&quot;,&quot;yummy&quot;,&quot;grade&quot;,&quot;proxy&quot;,&quot;hopes&quot;,&quot;girth&quot;,&quot;deter&quot;,&quot;dowry&quot;,&quot;aorta&quot;,&quot;paean&quot;,&quot;corms&quot;,&quot;giant&quot;,&quot;shank&quot;,&quot;where&quot;,&quot;means&quot;,&quot;years&quot;,&quot;vegan&quot;,&quot;derek&quot;,&quot;tales&quot;]]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>字符串</tag>
        <tag>回溯算法</tag>
        <tag>数组</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 128]]></title>
    <url>%2Fp%2Ffc6b.html</url>
    <content type="text"><![CDATA[128. 最长连续序列难度: hard 给定一个未排序的整数数组，找出最长连续序列的长度。 要求算法的时间复杂度为 O(n)。 示例: 123输入: [100, 4, 200, 1, 3, 2]输出: 4解释: 最长连续序列是 [1, 2, 3, 4]。它的长度为 4。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-consecutive-sequence著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码时间消耗还是挺大的。。。 1234567891011121314151617181920212223class Solution &#123;public: int longestConsecutive(vector&lt;int&gt;&amp; nums) &#123; unordered_map&lt;int,int&gt; a; for(auto num : nums)&#123; a[num] = num; &#125; int res = 0; int len = nums.size() - 1; for(int i = len; i &gt;= 0; i--)&#123; if(!a.count(nums[i] - 1))&#123; int cur = nums[i]; int t = 1; while(a.count(cur + 1))&#123; cur++; t++; &#125; res = max(res, t); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>数组</tag>
        <tag>并查集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题29]]></title>
    <url>%2Fp%2Fac68.html</url>
    <content type="text"><![CDATA[面试题29. 顺时针打印矩阵难度: easy 输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 示例 1： 12输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]输出：[1,2,3,6,9,8,7,4,5] 示例 2： 12输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]输出：[1,2,3,4,8,12,11,10,9,5,6,7] 限制： 0 &lt;= matrix.length &lt;= 100 0 &lt;= matrix[i].length &lt;= 100 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/难度: easy著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425class Solution &#123;public: vector&lt;int&gt; spiralOrder(vector&lt;vector&lt;int&gt;&gt;&amp; matrix) &#123; vector&lt;int&gt; res; if(matrix.empty())return res; int m = matrix.size(), n = matrix[0].size(); vector&lt;vector&lt;bool&gt;&gt; used(m,vector&lt;bool&gt;(n,false)); int dx[4] = &#123;0, 1, 0, -1&#125;; int dy[4] = &#123;1, 0, -1, 0&#125;; int x = 0, y = 0, dir = 0; for(int i = 0; i &lt; n * m ; i ++)&#123; res.push_back(matrix[x][y]); used[x][y] = true; int tx = x + dx[dir]; int ty = y + dy[dir]; if(tx &lt; 0 || tx &gt;= m || ty &lt; 0 || ty &gt;= n || used[tx][ty])&#123; dir = (dir + 1) % 4; tx = x + dx[dir]; ty = y + dy[dir]; &#125; x = tx, y = ty; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 994]]></title>
    <url>%2Fp%2Fbed.html</url>
    <content type="text"><![CDATA[994. 腐烂的橘子难度: medium 在给定的网格中，每个单元格可以有以下三个值之一： 值 0 代表空单元格； 值 1 代表新鲜橘子； 值 2 代表腐烂的橘子。 每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。 返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。 示例 1： 12输入：[[2,1,1],[1,1,0],[0,1,1]]输出：4 示例 2： 123输入：[[2,1,1],[0,1,1],[1,0,1]]输出：-1解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。 示例 3： 123输入：[[0,2]]输出：0解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。 提示： 1 &lt;= grid.length &lt;= 10 1 &lt;= grid[0].length &lt;= 10 grid[i][j] 仅为 0、1 或 2 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rotting-oranges著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码广搜，可以扩展时+1 123456789101112131415161718192021222324252627282930313233343536373839class Solution &#123;public: int m, n; int dx[4] = &#123;0, 1, 0, -1&#125;; int dy[4] = &#123;1, 0, -1, 0&#125;; int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) &#123; int count = 0; m = grid.size(); n = grid[0].size(); int step = 0; queue&lt;pair&lt;int,int&gt;&gt; q; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(grid[i][j] == 2)&#123; q.push(make_pair(i,j)); &#125;else if(grid[i][j] == 1) count++; &#125; &#125; while(!q.empty())&#123; int len = q.size(); bool flag = false; while(len--)&#123; pair&lt;int,int&gt; t = q.front();q.pop(); for(int i = 0; i &lt; 4; i++)&#123; int tx = t.first + dx[i]; int ty = t.second + dy[i]; if(tx &lt; 0 || tx &gt;= m || ty &lt; 0 || ty &gt;= n || grid[tx][ty] != 1)continue; grid[tx][ty] = 2; q.push(make_pair(tx,ty)); flag = true; count--; &#125; &#125; if(flag)step++; &#125; return count == 0 ? step : -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1160]]></title>
    <url>%2Fp%2F9b49.html</url>
    <content type="text"><![CDATA[1160. 拼写单词难度: easy 给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。 假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。 注意：每次拼写（指拼写词汇表中的一个单词）时，chars 中的每个字母都只能用一次。 返回词汇表 words 中你掌握的所有单词的 长度之和。 示例 1： 1234输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;输出：6解释： 可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。 示例 2： 1234输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;输出：10解释：可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。 提示： 1 &lt;= words.length &lt;= 1000 1 &lt;= words[i].length, chars.length &lt;= 100 所有字符串中都仅包含小写英文字母 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-words-that-can-be-formed-by-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920212223class Solution &#123;public: int countCharacters(vector&lt;string&gt;&amp; words, string chars) &#123; int vec[26] = &#123;0&#125;; int res = 0; for(auto word : words)&#123; bool flag = true; for(auto c : chars)&#123; vec[c - 'a']++; &#125; for(auto c : word)&#123; vec[c - 'a']--; if(vec[c - 'a'] &lt; 0)&#123; flag = false; break; &#125; &#125; memset(vec,0,sizeof(vec)); if(flag)res += word.size(); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 238]]></title>
    <url>%2Fp%2F6c9a.html</url>
    <content type="text"><![CDATA[238. 除自身以外数组的乘积难度: medium 给你一个长度为 n 的整数数组 nums，其中 n &gt; 1，返回输出数组 output ，其中 output[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积。 示例: 12输入: [1,2,3,4]输出: [24,12,8,6] 提示：题目数据保证数组之中任意元素的全部前缀元素和后缀（甚至是整个数组）的乘积都在 32 位整数范围内。 说明: 请不要使用除法，且在 O(n) 时间复杂度内完成此题。 进阶：你可以在常数空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组不被视为额外空间。） 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/product-of-array-except-self著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码前缀+后缀 123456789101112131415class Solution &#123;public: vector&lt;int&gt; productExceptSelf(vector&lt;int&gt;&amp; nums) &#123; vector&lt;int&gt; res(nums.size(),1); for(int i = 1; i &lt; nums.size(); i++)&#123; res[i] = res[i - 1] * nums[i - 1]; &#125; int product = 1; for(int i = nums.size() - 2; i &gt;= 0; i--)&#123; product *= nums[i + 1]; res[i] = res[i] * product; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 837]]></title>
    <url>%2Fp%2F6afa.html</url>
    <content type="text"><![CDATA[837. 新21点难度: medium 爱丽丝参与一个大致基于纸牌游戏 “21点” 规则的游戏，描述如下： 爱丽丝以 0 分开始，并在她的得分少于 K 分时抽取数字。 抽取时，她从 [1, W] 的范围中随机获得一个整数作为分数进行累计，其中 W 是整数。 每次抽取都是独立的，其结果具有相同的概率。 当爱丽丝获得不少于 K 分时，她就停止抽取数字。 爱丽丝的分数不超过 N的概率是多少？ 示例 1 ： 123输入：N = 10, K = 1, W = 10输出：1.00000说明：爱丽丝得到一张卡，然后停止。 示例 2 ： 1234输入：N = 6, K = 1, W = 10输出：0.60000说明：爱丽丝得到一张卡，然后停止。在 W = 10 的 6 种可能下，她的得分不超过 N = 6 分。 示例 3 ： 12输入：N = 21, K = 17, W = 10输出：0.73278 提示： 0 &lt;= K &lt;= N &lt;= 10000 1 &lt;= W &lt;= 10000 如果答案与正确答案的误差不超过 10^-5，则该答案将被视为正确答案通过。 此问题的判断限制时间已经减少。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/new-21-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: double new21Game(int N, int K, int W) &#123; if(K == 0)return 1.0; vector&lt;double&gt; dp(K + W); for(int i = K; i &lt;= N &amp;&amp; i &lt; K + W; i++)&#123; dp[i] = 1.0; &#125; dp[K - 1] = 1.0 * min(N - K + 1, W) / W; for(int i = K - 2; i &gt;= 0; i--)&#123; dp[i] = dp[i + 1] - (dp[i + W + 1] - dp[i + 1]) / W; &#125; return dp[0]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题64]]></title>
    <url>%2Fp%2Fa9ab.html</url>
    <content type="text"><![CDATA[面试题64. 求1+2+…+n难度:medium 求 1+2+...+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 示例 1： 12输入: n = 3输出: 6 示例 2： 12输入: n = 9输出: 45 限制 1 &lt;= n &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/qiu-12n-lcof著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路短路或者异常 12345678class Solution &#123;public: int sumNums(int n) &#123; int sum = n; bool flag = n &gt; 0 &amp;&amp; (sum += sumNums(n - 1)) &gt; 0; return sum; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1431]]></title>
    <url>%2Fp%2Fa9b.html</url>
    <content type="text"><![CDATA[1431. 拥有最多糖果的孩子难度: easy 给你一个数组 candies 和一个整数 extraCandies ，其中 candies[i] 代表第 i 个孩子拥有的糖果数目。 对每一个孩子，检查是否存在一种方案，将额外的 extraCandies 个糖果分配给孩子们之后，此孩子有 最多 的糖果。注意，允许有多个孩子同时拥有 最多 的糖果数目。 示例 1： 12345678输入：candies = [2,3,5,1,3], extraCandies = 3输出：[true,true,true,false,true] 解释：孩子 1 有 2 个糖果，如果他得到所有额外的糖果（3个），那么他总共有 5 个糖果，他将成为拥有最多糖果的孩子。孩子 2 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。孩子 3 有 5 个糖果，他已经是拥有最多糖果的孩子。孩子 4 有 1 个糖果，即使他得到所有额外的糖果，他也只有 4 个糖果，无法成为拥有糖果最多的孩子。孩子 5 有 3 个糖果，如果他得到至少 2 个额外糖果，那么他将成为拥有最多糖果的孩子。 示例 2： 123输入：candies = [4,2,1,1,2], extraCandies = 1输出：[true,false,false,false,false] 解释：只有 1 个额外糖果，所以不管额外糖果给谁，只有孩子 1 可以成为拥有糖果最多的孩子。 示例 3： 12输入：candies = [12,1,12], extraCandies = 10输出：[true,false,true] 提示： 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/kids-with-the-greatest-number-of-candies/)著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718class Solution &#123;public: vector&lt;bool&gt; kidsWithCandies(vector&lt;int&gt;&amp; candies, int extraCandies) &#123; int maxm = 0; for(int candy : candies)&#123; maxm = max(candy,maxm); &#125; vector&lt;bool&gt; res; for(int candy : candies)&#123; if(candy + extraCandies &gt;= maxm)&#123; res.push_back(true); &#125;else&#123; res.push_back(false); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 101]]></title>
    <url>%2Fp%2F9aaa.html</url>
    <content type="text"><![CDATA[101. 对称二叉树难度: easy 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码迭代水一下 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root)return true; return isSymmetricSubTree(root-&gt;left,root-&gt;right); &#125; bool isSymmetricSubTree(TreeNode* left, TreeNode* right)&#123; if(!left &amp;&amp; !right)return true; if(!left || !right)return false; if(left-&gt;val != right-&gt;val)return false; return isSymmetricSubTree(left-&gt;left,right-&gt;right) &amp;&amp; isSymmetricSubTree(left-&gt;right,right-&gt;left); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 84]]></title>
    <url>%2Fp%2Ff8ef.html</url>
    <content type="text"><![CDATA[84. 柱状图中最大的矩形难度:hard 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 12输入: [2,1,5,6,2,3]输出: 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码monostack单调栈 1234567891011121314151617181920class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; stack&lt;int&gt; stk; heights.insert(heights.begin(),0); heights.push_back(0); for(int i = 0; i &lt; heights.size(); i++)&#123; while(!stk.empty() &amp;&amp; heights[stk.top()] &gt; heights[i])&#123; int cur = stk.top(); stk.pop(); int left = stk.top() + 1; int right = i - 1; res = max((right - left + 1) * heights[cur], res); &#125; stk.push(i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198]]></title>
    <url>%2Fp%2Fcc6c.html</url>
    <content type="text"><![CDATA[198. 打家劫舍难度: easy 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码普通dp即可 1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())return 0; if(nums.size() == 1)return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp.back(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 394]]></title>
    <url>%2Fp%2F9cd.html</url>
    <content type="text"><![CDATA[394. 字符串解码难度: medium 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: string decodeString(string s) &#123; string t = ""; stack&lt;int&gt; k; stack&lt;string&gt; str; int n = s.size(); int count = 0; for(int i = 0; i &lt; n; i++)&#123; if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; count = 10 * count + s[i] - '0'; &#125;else if(s[i] == '[')&#123; k.push(count); str.push(t); count = 0; t.clear(); &#125;else if(s[i] == ']')&#123; int num = k.top(); k.pop(); while(num--)&#123; str.top() += t; &#125; t = str.top(); str.pop(); &#125;else&#123; t += s[i]; &#125; &#125; return str.empty() ? t : str.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>栈</tag>
        <tag>LeetCOde</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 974]]></title>
    <url>%2Fp%2F6be9.html</url>
    <content type="text"><![CDATA[974. 和可被 K 整除的子数组难度: medium 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 12345输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 &lt;= A.length &lt;= 30000 -10000 &lt;= A[i] &lt;= 10000 2 &lt;= K &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sums-divisible-by-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码果然低端前缀和走不远，跟LeetCode 560差不多，注意负数的问题就是了 这就是同余的力量吧 123456789101112131415161718192021222324252627282930class Solution &#123;public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123; /*TLE int n = A.size(); vector&lt;int&gt; dp(n + 1); for(int i = 1; i &lt; n + 1; i++)&#123; dp[i] = dp[i - 1] + A[i - 1]; &#125; int res = 0; for(int i = 1; i &lt; dp.size(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if((dp[j] - dp[i]) % K == 0)&#123; res++; &#125; &#125; &#125; return res; */ int res = 0, sum = 0, n = A.size(); unordered_map&lt;int,int&gt; mp&#123;&#123;0,1&#125;&#125;; for(int i = 0; i &lt; n; i++)&#123; sum += (A[i] % K + K) % K; sum %= K; res += mp[sum]; mp[sum]++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 287]]></title>
    <url>%2Fp%2F58dd.html</url>
    <content type="text"><![CDATA[287. 寻找重复数难度: medium 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码弱智的我第一次还以为重复的数字只出现一次，所以累加和…tui 123456789101112131415161718192021222324class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int left = 1, right = (int)nums.size() - 1; while(left &lt; right)&#123; int mid = left + right &gt;&gt; 1; int co = count(nums,mid); if(co &lt;= mid)&#123; left = mid + 1; &#125;else&#123; right = mid; &#125; &#125; return left; &#125; int count(vector&lt;int&gt;&amp; nums, int target)&#123; int res = 0; for(auto num : nums)&#123; res += target &gt;= num; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>双指针</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 146]]></title>
    <url>%2Fp%2F98e9.html</url>
    <content type="text"><![CDATA[146. LRU缓存机制难度: medium 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: 1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码使用了splice函数 list中排序，越是最近，放在头部 存储key和list迭代器的映射，方便使用find查找 超过capacity时，清除末尾即可 123456789101112131415161718192021222324252627282930313233343536class LRUCache &#123;public: LRUCache(int capacity) &#123; cap = capacity; &#125; int get(int key) &#123; auto iter = mp.find(key); if(iter == mp.end())return -1; l.splice(l.begin(), l, iter-&gt;second); return iter-&gt;second-&gt;second; &#125; void put(int key, int value) &#123; auto iter = mp.find(key); if(iter != mp.end()) l.erase(iter-&gt;second); l.push_front(make_pair(key, value)); mp[key] = l.begin(); if(mp.size() &gt; cap)&#123; int k = l.rbegin()-&gt;first; l.pop_back(); mp.erase(k); &#125; &#125;private: int cap; list&lt;pair&lt;int,int&gt;&gt; l; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; mp;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4]]></title>
    <url>%2Fp%2F6b6a.html</url>
    <content type="text"><![CDATA[4. 寻找两个正序数组的中位数难度: hard 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码查找两次 m = nums1.size(), n = nums2.size() trick: 中位数则为:((m+n+1)/2 + (m+n+2)/2)/2.0 对空间的优化以后补充(如果想起来的话) 细节的优化处真是有点烦人 1234567891011121314151617181920212223class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); int mean1 = (m + n + 1) / 2, mean2 = (m + n + 2) / 2; return (process(nums1,nums2,mean1) + process(nums1,nums2,mean2))/ 2.0; &#125; int process(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2,int k)&#123; if(nums1.empty())return nums2[k - 1]; if(nums2.empty())return nums1[k - 1]; if(k == 1)return min(nums1[0],nums2[0]); //divide and conquer int midk1 = min((int)nums1.size(), k / 2); int midk2 = min((int)nums2.size(), k / 2); if(nums1[midk1 - 1] &gt; nums2[midk2 - 1])&#123; return process(nums1,vector&lt;int&gt;(nums2.begin() + midk2, nums2.end()), k - midk2); &#125;else&#123; return process(vector&lt;int&gt;(nums1.begin() + midk1, nums1.end()), nums2, k - midk1); &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>数组</tag>
        <tag>二分查找</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 76]]></title>
    <url>%2Fp%2Fc96b.html</url>
    <content type="text"><![CDATA[76. 最小覆盖子串难度: hard 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 12输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot; 说明： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-window-substring著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425class Solution &#123;public: string minWindow(string s, string t) &#123; unordered_map&lt;char,int&gt; mp; for(char c : t)mp[c]++; int len = s.size(), target = t.size(); int count = 0, left = 0; int length = INT_MAX, minleft = -1; for(int i = 0; i &lt; len; i++)&#123; if(--mp[s[i]] &gt;= 0)&#123; count++; &#125; while(count == target)&#123; int temp = i - left + 1; if(temp &lt; length)&#123; length = temp; minleft = left; &#125; if(++mp[s[left]] &gt; 0)count--; left++; &#125; &#125; return minleft == -1 ? "" : s.substr(minleft,length); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>字符串</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105]]></title>
    <url>%2Fp%2F59ab.html</url>
    <content type="text"><![CDATA[105. 从前序与中序遍历序列构造二叉树难度: medium 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码写个递归拉到了，迭代懒得写，以后补吧 同样的问题还有很多，需要说明的是，迭代才有点难度，尤其是涉及后序遍历相关的问题 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if(preorder.empty() || inorder.empty() || preorder.size() != inorder.size())return NULL; int len1 = preorder.size(), len2 = inorder.size(); return process(preorder, inorder, 0, len1 - 1, 0, len2 - 1); &#125; TreeNode* process(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder,int l1, int r1, int l2, int r2)&#123; if(l1 &gt; r1 || l2 &gt; r2)return NULL; int rootValue = preorder[l1]; TreeNode* root = new TreeNode(rootValue); TreeNode* leftNode = NULL, *rightNode = NULL; int index = l2; while(inorder[index] != rootValue &amp;&amp; index &lt;= r2)index++; if(index &gt; l2)&#123; leftNode = process(preorder, inorder, l1 + 1, l1 + index - l2, l2, index - 1); &#125; if(index &lt; r2)&#123; rightNode = process(preorder, inorder, l1 + index - l2 + 1, r1, index + 1, r2); &#125; root-&gt;left = leftNode; root-&gt;right = rightNode; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5]]></title>
    <url>%2Fp%2Fabab.html</url>
    <content type="text"><![CDATA[5. 最长回文子串难度: medium 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-palindromic-substring著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码动态规划1234567891011121314151617181920class Solution &#123;public: string longestPalindrome(string s) &#123; if(s.empty())return ""; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); int len = 1, st = 0; for(int i = 0; i &lt; n; i++)&#123; dp[i][i] = 1; for(int j = 0; j &lt; i; j++)&#123; dp[j][i] = (s[j] == s[i]) &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1]); if(dp[j][i] &amp;&amp; len &lt; i - j + 1)&#123; len = i - j + 1; st = j; &#125; &#125; &#125; return s.substr(st, len); &#125;&#125;; 马拉车算法(Manacher’s Algorithm)参考马拉车算法 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; string newS = "$#"; for(char c : s)&#123; newS += c; newS += '#'; &#125; newS += '@'; int n = newS.size(); vector&lt;int&gt; p(n); int id = 0, mx = 0; int len = 1, idx = 0; for(int j = 1; j &lt; n - 1; j++)&#123; p[j] = mx &gt; j ? min(p[2 * id - j], mx - j) : 1; while(newS[j + p[j]] == newS[j - p[j]])p[j]++; if(mx &lt; p[j] + j)&#123; mx = p[j] + j; id = j; &#125; if(len &lt; p[j] - 1)&#123; len = p[j] - 1; idx = j; &#125; &#125; int st = (idx - len) / 2; return s.substr(st, len); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>字符串</tag>
        <tag>动态规划</tag>
        <tag>马拉车算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 101 最大流]]></title>
    <url>%2Fp%2F69d2.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1371]]></title>
    <url>%2Fp%2Fb28.html</url>
    <content type="text"><![CDATA[1371. 每个元音包含偶数次的最长子字符串难度: medium 给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。 示例 1： 123输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。 示例 2： 123输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。 示例 3： 123输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示： 1 &lt;= s.length &lt;= 5 x 10^5 s 只包含小写英文字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/divisor-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425class Solution &#123;public: int findTheLongestSubstring(string s) &#123; int res = 0, flag = 0; vector&lt;int&gt; position(32, -1); position[0] = 0; for(int i = 0; i &lt; s.size(); i++)&#123; char c = s[i]; switch(c)&#123; case 'a': flag ^= 1 &lt;&lt; 0; break; case 'e': flag ^= 1 &lt;&lt; 1; break; case 'i': flag ^= 1 &lt;&lt; 2; break; case 'o': flag ^= 1 &lt;&lt; 3; break; case 'u': flag ^= 1 &lt;&lt; 4; break; default:break; &#125; if(position[flag] == -1)&#123; position[flag] = i + 1; &#125;else&#123; res = max(res, i - position[flag] + 1); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>字符串</tag>
        <tag>前缀和</tag>
        <tag>状态压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 680]]></title>
    <url>%2Fp%2F5bdd.html</url>
    <content type="text"><![CDATA[680. 验证回文字符串 Ⅱ难度: easy 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 12输入: &quot;aba&quot;输出: True 示例 2: 123输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617class Solution &#123;public: bool validPalindrome(string s) &#123; if(s.size() &lt;= 1)return true; return valid(s, 0, s.size() - 1, 0); &#125; bool valid(string&amp; s, int left, int right, int c)&#123; if(left &gt;= right)return true; if(s[left] == s[right])return valid(s, left + 1, right - 1, c); else&#123; if(c &gt; 0)return false; c++; return valid(s,left + 1, right, c) || valid(s,left, right - 1); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 152]]></title>
    <url>%2Fp%2Fcbe9.html</url>
    <content type="text"><![CDATA[152. 乘积最大子数组难度: medium 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = nums[0]; vector&lt;int&gt; dp1(n,0);dp1[0] = nums[0]; vector&lt;int&gt; dp2(n,0);dp2[0] = nums[0]; for(int i = 1; i &lt; n; i++)&#123; dp1[i] = max(max(nums[i], dp1[i - 1] * nums[i]), dp2[i - 1] * nums[i]); dp2[i] = min(min(nums[i], dp1[i - 1] * nums[i]), dp2[i - 1] * nums[i]); res = max(dp1[i],res); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 210]]></title>
    <url>%2Fp%2Fca9a.html</url>
    <content type="text"><![CDATA[210. 课程表 II难度: medium 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/course-schedule-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析1.很明显的拓扑排序问题 有向无环图结点的线性排序 2.BFS算法step1:统计图中每个节点的入度，生成入度表 indegrees。step2:借助一个队列 queue，将所有入度为0的节点入队。step3:当queue非空时，依次将队首节点出队，依次将队首节点的所有邻接节点cur的入度-1，即 indegrees[cur] -= 1;当入度-1后邻接节点cur的入度为0，说明cur所有的前驱节点已经被 “删除”，此时将cur入队 3.DFS算法略了，懒得打，网上有很多解析 AC代码BFS12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; res; vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;(0)); vector&lt;int&gt; indegrees(numCourses,0); for(auto &amp; pre : prerequisites)&#123; graph[pre[1]].push_back(pre[0]); indegrees[pre[0]]++; &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; numCourses; i++)&#123; if(indegrees[i] == 0)q.push(i); &#125; while(!q.empty())&#123; int t = q.front(); res.push_back(t); q.pop(); for(auto &amp;a: graph[t])&#123; indegrees[a]--; if(indegrees[a] == 0) q.push(a); &#125; &#125; if(res.size() != numCourses)return &#123;&#125;; return res; &#125;&#125;; DFS12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; res; vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;(0)); vector&lt;int&gt; visited(numCourses); bool circle = false; for(auto &amp; pre : prerequisites)&#123; graph[pre[1]].push_back(pre[0]); &#125; for(int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)&#123; if(!visited[i])&#123; dfs(i,res,graph,visited,circle); &#125; &#125; if(circle)return &#123;&#125;; reverse(res.begin(),res.end()); return res; &#125; void dfs(int x, vector&lt;int&gt;&amp; res, vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; visited, bool&amp; circle)&#123; visited[x] = 1; for(int v: graph[x])&#123; if(visited[v] == 0)&#123; dfs(v,res,graph,visited,circle); if(circle)&#123; return; &#125; &#125;else if(visited[v] == 1)&#123; circle = true; return; &#125; &#125; visited[x]= 2; res.push_back(x); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>mark</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 25]]></title>
    <url>%2Fp%2F9828.html</url>
    <content type="text"><![CDATA[25. K 个一组翻转链表难度: hard 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路递归不递归都随便吧，按照题意实现而已 1.非递归123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k == 1)return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* cur = head; for(int i = 1; cur; i++)&#123; if(i % k == 0)&#123; pre = reverse(pre, cur-&gt;next); cur = pre-&gt;next; &#125;else&#123; cur = cur-&gt;next; &#125; &#125; return dummy-&gt;next; &#125; ListNode* reverse(ListNode* pre, ListNode* last)&#123; ListNode* dummy = pre-&gt;next; ListNode* cur = dummy-&gt;next; while(cur != last)&#123; dummy-&gt;next = cur-&gt;next; cur-&gt;next = pre-&gt;next; pre-&gt;next = cur; cur = dummy-&gt;next; &#125; return dummy; &#125;&#125;; 2.递归123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k == 1)return head; ListNode* cur = head; for(int i = 0; i &lt; k; i++)&#123; if(!cur)return head; cur = cur-&gt;next; &#125; ListNode* dummy = reverse(head, cur); head-&gt;next = reverseKGroup(cur, k); return dummy; &#125; ListNode* reverse(ListNode* head, ListNode* tail)&#123; ListNode* pre = tail; while(head != tail)&#123; ListNode* temp = head-&gt;next; head-&gt;next = pre; pre = head; head = temp; &#125; return pre; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 560]]></title>
    <url>%2Fp%2F3b29.html</url>
    <content type="text"><![CDATA[560. 和为K的子数组难度: medium 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sum-equals-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; // TLE // TLE的输入太过酸爽 // int res = 0; // int n = nums.size(); // vector&lt;int&gt; sums(n); // sums[0] = nums[0]; // for(int i = 1; i &lt; n; i++)&#123; // sums[i] = sums[i - 1] + nums[i]; // &#125; // for(int i = 0; i &lt; n; i++)&#123; // if(sums[i] == k)res++; // for(int j = i - 1; j &gt;= 0; j--)&#123; // if(sums[i] - sums[j] == k) // res++; // &#125; // &#125; // return res; int res = 0, sum = 0, n = nums.size(); unordered_map&lt;int,int&gt; mp&#123;&#123;0,1&#125;&#125;; for(int i = 0; i &lt; n; i++)&#123; sum += nums[i]; res += mp[sum - k]; mp[sum]++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 136]]></title>
    <url>%2Fp%2Fa8eb.html</url>
    <content type="text"><![CDATA[136. 只出现一次的数字难度: easy 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码至于其他思路哈希表啥的都很简单，懒得写了，因为没啥技术含量 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int num : nums) res ^= num; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102]]></title>
    <url>%2Fp%2F9bea.html</url>
    <content type="text"><![CDATA[102. 二叉树的层序遍历难度: medium 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码迭代(BFS)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if(!root)return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; level; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = q.front(); q.pop(); level.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res.push_back(level); &#125; return res; &#125;&#125;; 递归(DFS)12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; traverse(root,res,0); return res; &#125; void traverse(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; res, int level)&#123; if(!root)return; if(res.size() == level)res.push_back(&#123;&#125;); res[level].push_back(root-&gt;val); traverse(root-&gt;left,res,level + 1); traverse(root-&gt;right,res,level + 1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 155]]></title>
    <url>%2Fp%2F9a8.html</url>
    <content type="text"><![CDATA[155. 最小栈难度: medium 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码双栈或者记录“曾经”的最小值，注意相同的值 双栈123456789101112131415161718192021222324252627282930313233343536class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; stk1.push(x); if(stk2.empty() || x &lt;= stk2.top())stk2.push(x); &#125; void pop() &#123; if(stk1.top() == stk2.top())stk2.pop(); stk1.pop(); &#125; int top() &#123; return stk1.top(); &#125; int getMin() &#123; return stk2.top(); &#125;private: stack&lt;int&gt; stk1,stk2;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 曾经的最小值1234567891011121314151617181920212223242526272829303132333435363738394041424344class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; minm = INT_MAX; &#125; void push(int x) &#123; if(x &lt;= minm)&#123; stk.push(minm); minm = x; &#125; stk.push(x); &#125; void pop() &#123; int t = stk.top(); stk.pop(); if(t == minm)&#123; minm = stk.top(); stk.pop(); &#125; &#125; int top() &#123; return stk.top(); &#125; int getMin() &#123; return minm; &#125;private: stack&lt;int&gt; stk; int minm;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>设计</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 50]]></title>
    <url>%2Fp%2Fabea.html</url>
    <content type="text"><![CDATA[50. Pow(x, n)难度: medium 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码快速幂迭代也不难，懒得写了 注意INT_MIN这个点就行了，也就是1/pow(x,-n)是要考虑范围的 顺便，快速幂是二分查找的意思么？感觉牵强 12345678910111213class Solution &#123;public: double myPow(double x, int n) &#123; // x == 0??? // n = -2147483648 if(n == 0)return 1.0; if(n == 1)return x; double half = myPow(x, n / 2); if(n % 2 == 0)return half * half; if(n &gt; 0)return half * half * x; return half * half / x; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 236]]></title>
    <url>%2Fp%2Fa81b.html</url>
    <content type="text"><![CDATA[236. 二叉树的最近公共祖先难度: medium 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root || p == root || q == root) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p ,q); if(left &amp;&amp; right)return root; return left ? left : right; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69]]></title>
    <url>%2Fp%2F5d2a.html</url>
    <content type="text"><![CDATA[69. x 的平方根难度: easy 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码强行回顾一波… 袖珍计算器算法12345678class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; int ans = exp(0.5 * log(x)); return (long long)(ans + 1) * (ans + 1) &lt;= x ? ans + 1 : ans; &#125;&#125;; 牛顿切线1234567891011class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; double x0 = x / 2.0; while(abs(x0 - (x / x0)) &gt; 1e-7)&#123; x0 = (x0 + x / x0) / 2; &#125; return (int)x0; &#125;&#125;; 二分查找12345678910111213class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; double left = 0.0, right = x; while(right - left &gt;= 1e-7)&#123; double mid = (left + right) / 2.0; if(mid * mid &gt; x)right = mid; else left = mid; &#125; return (int)(right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>— LeetCode - 二分查找 -  数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 590]]></title>
    <url>%2Fp%2Fcb2c.html</url>
    <content type="text"><![CDATA[590. N叉树的后序遍历难度: easy 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此题吗? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425262728293031323334353637/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; postorder(Node* root) &#123; vector&lt;int&gt; res; process(root, res); return res; &#125; void process(Node* root, vector&lt;int&gt;&amp; res)&#123; if(!root)return; for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; process(root-&gt;children[i],res); &#125; res.push_back(root-&gt;val); &#125;&#125;; 迭代(可以但没必要)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 589]]></title>
    <url>%2Fp%2F5ded.html</url>
    <content type="text"><![CDATA[589. N叉树的前序遍历难度: easy 给定一个 N 叉树，返回其节点值的前序遍历。 例如，给定一个 3叉树 : 返回其前序遍历: [1,3,5,6,2,4]。 说明: 递归法很简单，你可以使用迭代法完成此题吗? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; res; process(root, res); return res; &#125; void process(Node* root, vector&lt;int&gt;&amp; res)&#123; if(!root)return; res.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; process(root-&gt;children[i],res); &#125; &#125;&#125;; 迭代(可以但没必要)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 95]]></title>
    <url>%2Fp%2Fa82f.html</url>
    <content type="text"><![CDATA[95. 不同的二叉搜索树 II难度: medium 给定一个整数 n ，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 1234567891011121314151617输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码常规分治 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n &lt; 1)return &#123;&#125;; return divide(1, n); &#125; vector&lt;TreeNode*&gt; divide(int left, int right)&#123; if(left &gt; right)return &#123;nullptr&#125;; vector&lt;TreeNode*&gt; res; for(int i = left; i &lt;= right; i++)&#123; auto leftTree = divide(left, i - 1); auto rightTree = divide(i + 1, right); for(auto leftSubTree : leftTree)&#123; for(auto rightSubTree: rightTree)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = leftSubTree; root-&gt;right = rightSubTree; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125;; 强行动规不想写了，用一个二维$vector$,$vec[i][j]$记录区间i到j所有可以生成的BST的根节点。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1025]]></title>
    <url>%2Fp%2F98da.html</url>
    <content type="text"><![CDATA[1025. 除数博弈难度: easy 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例 1： 123输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 123输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 &lt;= N &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/divisor-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码常规动态规划 123456789101112131415161718192021class Solution &#123;public: bool divisorGame(int N) &#123; if(N &lt; 2)return false; vector&lt;int&gt; dp(N + 1); dp[1] = false;dp[2] = true; for(int i = 3; i &lt;= N; i++)&#123; dp[i] = false; for(int j = 1; j &lt; i; j++)&#123; if(i % j)continue; else&#123; if(!dp[i - j])&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[N]; &#125;&#125;; 优化一下1-&gt;false 2-&gt;true 3-&gt;false 4-&gt;true(4,3,2-&gt;false) 猜想:奇数-&gt;false;偶数-&gt;true 证明: $dp[2k-1] = false, dp[2k] = true$ $k = 1$时，显然成立 假设$k \leq m$时，成立 则$k\leq m + 1$时，显然 $(2m+1) \% x = 0 \rightarrow x = 2n + 1$$dp[2m+ 1] = !dp[2m +1 - x] = !dp[2 * n] = false$ $dp[2m + 1] = !dp[2m + 2 - 1] = !dp[2*m + 1] = true$成立 123456class Solution &#123;public: bool divisorGame(int N) &#123; return N % 2 == 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 223]]></title>
    <url>%2Fp%2F3bda.html</url>
    <content type="text"><![CDATA[223. 矩形面积难度: medium 在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例: 12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rectangle-area著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码简单题… 12345678910111213141516class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int overlap; if(E &gt;= C || G &lt;= A || F &gt;= D || H &lt;= B)&#123; overlap = 0; &#125;else&#123; int x1 = max(A,E); int x2 = min(C,G); int y1 = max(B,F); int y2 = min(D,H); overlap = (x2 - x1) * (y2 - y1); &#125; return (C - A) * (D - B) - overlap + (G - E) * (H - F); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222]]></title>
    <url>%2Fp%2Ffb1b.html</url>
    <content type="text"><![CDATA[222. 完全二叉树的节点个数难度: medium 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例: 12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-complete-tree-nodes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码???这题有意义？ 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root)return 0; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; 二分代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; int res = 0; int h = getHeight(root); if(h &lt; 0)return 0; if(getHeight(root-&gt;right) == h - 1)return (1 &lt;&lt; h) + countNodes(root-&gt;right); return (1 &lt;&lt; (h - 1)) + countNodes(root-&gt;left); &#125; int getHeight(TreeNode* root)&#123; return root ? 1 + getHeight(root-&gt;left) : -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221]]></title>
    <url>%2Fp%2Ffa5b.html</url>
    <content type="text"><![CDATA[221. 最大正方形难度: medium 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximal-square著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC 代码1234567891011121314151617181920class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())return 0; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; dp(m * n); int res = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0) dp[i * n + j] = matrix[i][j] - '0'; else if(matrix[i][j] == '1')&#123; dp[i * n + j] = min(dp[i * n + j - 1], min(dp[(i - 1) *n + j - 1], dp[(i - 1) * n + j])) + 1; &#125; res = max(res, dp[i * n + j]); &#125; &#125; return res * res; &#125;&#125;; 优化一下好像优化的不咋样… 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())return 0; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; dp(n + 1); int res = 0, pre = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int temp = dp[j]; if(matrix[i][j - 1] == '1')&#123; dp[j] = min(dp[j],min(dp[j - 1], pre)) + 1; res = max(res, dp[j]); &#125;else&#123; dp[j] = 0; &#125; pre = temp; &#125; &#125; return res * res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572]]></title>
    <url>%2Fp%2F6aa9.html</url>
    <content type="text"><![CDATA[572. 另一个树的子树难度: easy 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1:给定的树 s:12345 3 / \ 4 5 / \1 2 给定的树 t：123 4 / \1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2:给定的树 s： 1234567 3 / \ 4 5 / \1 2 / 0 给定的树 t：123 4 / \1 2 返回 false。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subtree-of-another-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码区分好”相同”与”真子树” 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s) return false; if (isSame(s, t)) return true; else return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); &#125; bool isSame(TreeNode* s, TreeNode* t)&#123; if (!s &amp;&amp; !t) return true; if (!s || !t) return false; if (s-&gt;val != t-&gt;val) return false; return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 983]]></title>
    <url>%2Fp%2F59ad.html</url>
    <content type="text"><![CDATA[983. 最低票价难度: medium 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有三种不同的销售方式： 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1： 12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。 示例 2： 1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示： 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days 按顺序严格递增 costs.length == 3 1 &lt;= costs[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路动态规划 第i天需要旅行 dp[i] = dp[i - 1] dp[i] = min(dp[i - 1] + cost[0], dp[i - 7] + cost[1], dp[i-30] + cost[2]) 越界时dp[i] = 0 不能遍历到最后一天就结束，原因:“浪费时间可能省钱” AC代码1234567891011121314151617181920class Solution &#123;public: int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; //dp[i] min cost in pre i days; vector&lt;int&gt; dp(366, INT_MAX); for(int day : days)dp[day] = 0; dp[0] = 0; int last = days.back(); for(int i = 1; i &lt;= 365; i++)&#123; if(dp[i] == INT_MAX) dp[i] = dp[i - 1]; else&#123; dp[i] = dp[i - 1] + costs[0]; dp[i] = min(dp[i], costs[1] + (i &gt;= 7 ? dp[i - 7] : 0)); dp[i] = min(dp[i], costs[2] + (i &gt;= 30 ? dp[i - 30] : 0)); &#125; &#125; return dp[last]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98]]></title>
    <url>%2Fp%2F6dee.html</url>
    <content type="text"><![CDATA[98. 验证二叉搜索树难度: medium 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路白给题 AC代码12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root)return true; return isValid(root, LONG_MIN, LONG_MAX); &#125; bool isValid(TreeNode* root, long minn, long maxx)&#123; if(!root)return true; if(root-&gt;val &lt;= minn || root-&gt;val &gt;= maxx)return false; return isValid(root-&gt;left, minn, root-&gt;val) &amp;&amp; isValid(root-&gt;right, root-&gt;val, maxx); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 45]]></title>
    <url>%2Fp%2F382b.html</url>
    <content type="text"><![CDATA[45. 跳跃游戏 II难度: hard 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 1234输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jump-game-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处 思路记录每一步活动范围内可以到达的新的活动范围，最小是走一步，最大时走nums[i] + i 步。 AC代码123456789101112131415161718class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)return 0; int n = (int)nums.size(); int cur = 0, step = 0, last = 0; while(cur &lt; n - 1)&#123; int fur = 0; for(int i = last; i &lt;= cur; i++)&#123; fur = max(fur, nums[i] + i); &#125; step++; last = cur + 1;cur = fur; if(cur &gt;= n - 1)break; &#125; return cur &gt;= n - 1 ? step : -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 53]]></title>
    <url>%2Fp%2Faaaa.html</url>
    <content type="text"><![CDATA[53. 最大子序和难度 easy 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码 O(n)很容易 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int maxSum = nums[0]; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; if(sum &lt; 0)sum = nums[i]; else sum += nums[i]; maxSum = max(maxSum, sum); &#125; return maxSum; &#125;&#125;; 分治算法，并不觉得很强 左子数组max1, 右子数组max2, 从中间向左右延伸max3，求三者最大即可。 123456789101112131415161718192021222324class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return divide(nums, 0, (int)nums.size() - 1); &#125; int divide(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left &gt;= right)return nums[left]; int mid = left + (right - left) / 2; int max1 = divide(nums, left, mid - 1); int max2 = divide(nums, mid + 1, right); int max3 = nums[mid], tempMax = max3; for(int i = mid - 1; i &gt;= left; i--)&#123; tempMax += nums[i]; max3 = max(max3, tempMax); &#125; tempMax = max3; for(int i = mid + 1; i &lt;= right; i++)&#123; tempMax += nums[i]; max3 = max(max3, tempMax); &#125; return max(max3, max(max1, max2)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3]]></title>
    <url>%2Fp%2Fa92b.html</url>
    <content type="text"><![CDATA[3. 无重复字符的最长子串难度: medium 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路hash记录字符的索引，size = i - left，left表示当前不重复的子串的最左元素的索引 AC代码12345678910111213class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vec(128, -1); int res = 0, left = -1; for(int i = 0; i &lt; s.size(); i++)&#123; left = max(left, vec[s[i]]); vec[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 100 矩阵乘法]]></title>
    <url>%2Fp%2F3d8b.html</url>
    <content type="text"><![CDATA[Loj 100题目描述这是一道模板题。 分别给定 $n \times p$ 和 $p \times m$ 的两个矩阵 $A$ 和 $B$，求 $A\times B$。 输入格式第一行三个正整数 $n$ 、$p$ 、$m$，表示矩阵的长宽。之后的 $n$ 行，每行 $p$ 个整数，表示矩阵 $A$。之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。 输出格式输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A \times B$，每个数模 $10^9 +7$ 输出。 样例样例输入123456783 4 5-2 -8 -9 8-10 0 6 -8-10 -6 6 94 -7 5 -5 910 -2 -10 5 5-3 -7 -3 8 -2-6 7 7 3 -2 样例输出123999999898 149 153 999999929 999999951999999997 999999979 999999883 74 999999921999999835 103 55 95 999999857 数据范围与提示$1 \leq n, p, m \leq 500, -10^9 \leq A_{i,j},B_{i,j} \leq 10^9$ AC代码测试数据很坑，注意long long范围，以及mod 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;const int maxn = 500;const long long mod = 1e9 + 7;int n,p,m;long long a[maxn][maxn];long long b[maxn][maxn];int main()&#123; scanf("%d %d %d",&amp;n,&amp;p,&amp;m); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; p; j++)&#123; scanf("%lld",&amp;a[i][j]); a[i][j] = (a[i][j] + mod) % mod; &#125; &#125; for(int i = 0; i &lt; p; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; scanf("%lld",&amp;b[i][j]); b[i][j] = (b[i][j] + mod) % mod; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; long long res = 0ll; int k; for(k = 0; k &lt; p; k++)&#123; res = res + a[i][k] * b[k][j] % mod; res %= mod; &#125; cout&lt;&lt;res; if(j &lt; m - 1) cout&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;/*3 4 5605484667 -184715359 -844798432 303281860154160217 251340539 503442468 -585835226-605901720 -111757647 145470433 -60142328583215279 444795017 210075636 921181746 560215639-392073611 -248331514 -984830557 766445752 -888503479811152088 -721594655 299338374 779359743 -766800655-68463587 -878021890 -370611066 502520549 -952228*/]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Template problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21]]></title>
    <url>%2Fp%2F5b29.html</url>
    <content type="text"><![CDATA[21. 合并两个有序链表难度: easy 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路低配版mergesort，很简单，不多说。 AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1)cur-&gt;next = l1; if(l2)cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 7 InputTest]]></title>
    <url>%2Fp%2Ff7ec.html</url>
    <content type="text"><![CDATA[题目描述输入 $3\times 10^6$ 个$[0,2^m)$中均匀随机的十进制整数，输出它们的异或和。 输入格式输入共 $3\times 10^6$ 行，每行一个整数。 输出格式输出共一行一个整数表示它们的异或和。 数据范围与提示共5组数据， 分别为 1, 3, 15, 31, 63 。 AC代码12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long res = 0; long long c =3 * 1000000; long long a; while(c--)&#123; cin&gt;&gt;a; res ^= a; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6 GuessNumber]]></title>
    <url>%2Fp%2F45c0.html</url>
    <content type="text"><![CDATA[题目描述这是一个交互题的模板。 系统会随机生成 个数 ，你需要猜测出这 个数的值。暴力枚举 / 二分 / 随机猜测等方法都可以解决这个问题，但得分将依猜测次数而定。 交互方式使用 C++ 与 C++11 的选手将可以利用系统给出的交互库来进行交互。 使用其他语言的选手也不必担心，我们提供了一个友好的交互接口，你将能够轻而易举地通过标准输入 / 输出来进行交互。 不使用交互库为了更清晰地演示交互题的使用方法，我们设计了三种操作： get_num：获取需要猜测的数字数量 n 。本操作不包含参数。 guess：猜测某个数字。本操作包含 2 个参数：需要猜测的数字的序号（从 0 开始）以及猜测值。当你猜测的值小于实际值时，返回值为 -1；当你猜测的值大于实际值时，返回值为 1；当恰好猜对时，返回值为 0。 submit：提交猜测结果。本操作包含 n个参数，即 个数的猜测结果。本操作没有返回值。 当你想要进行某个操作时，请向标准输出流中写入如下格式的字符串： 1&lt;操作名称&gt; &lt;操作参数 1&gt; &lt;操作参数 2&gt; ... &lt;操作参数 n&gt; 你必须在请求后追加换行符；多余的空白字符将被自动忽略。 在收到用户程序发送的请求后，交互器会向用户程序的标准输入流中发送返回值。你只需在你的程序中使用通常的办法读入这个值，就好像是从控制台或文件中读取内容一样。交互器将在发送返回值后再附加一个换行符 \n，以便于用户程序读入。本题目的操作返回值都是数字，因此直接读入数字即可。 请注意，很多语言的输入 / 输出库都会带有缓存，请在写入操作请求后手动刷新缓存，以确保请求顺利递送。 C++ 语言可以这样刷新缓存（std::endl 会自动刷新缓存）： 12std::cout &lt;&lt; std::flush;// 或 std::cout &lt;&lt; value &lt;&lt; std::endl; 提交猜测结果后，即可结束程序。交互器退出时，如果用户程序还在运行，就会被立即终止，但不会引发超时错误。 使用交互库对于 C++ 与 C++11 选手，我们提供交互库 interaction.h，你将可以通过题目上方的「附加文件」下载到这个交互库。正式比赛时交互库也将是公开的。 当然，你可以选择不使用交互库，自己通过标准输入输出来通信。 C++ 与 C++11 的 interaction.h 将包含三个原型如下的函数： 123int get_num();int guess(int index, int x);void submit(const std::vector&lt;int&gt; &amp;resultv); 参数的意义及返回值请参见上面的描述。 附注 1 文件说明「附加文件」中的 interaction.h 为供用户调用的交互库；interactor.cpp 为交互器。 附注 2 C 与 C++ #include 说明#include 表示在标准库及默认搜索目录中寻找将要 include 的文件；#include &quot;file&quot; 表示先在当前目录中搜索文件，然后再到默认搜索目录中搜寻。 在提交交互题时，请使用 #include &quot;interaction.h&quot;。 输入格式输入文件是供交互器使用的；一般用户无需在意这里的内容，只需关心如何与交互器交互即可。 第一行一个正整数 n，表示有 n 个数，第二行 n 个正整数表示要猜的序列。 样例样例输入1251 2 3 4 5 数据范围与提示数量 $1 \leq n \leq 100$；要猜测的数字 $0 \leq A_i \leq 1000000$。 请尽量保证你的猜测次数在 $1000n$ 之内，对于每个测试点 x，设你的猜测次数为 ，则你的得分为 $\text{max}(\text{min}(100,(950-\frac{x}{n})-100))/950\times100),0)$。 每次猜测均为 I / O 操作，消耗时间较多，如果猜测次数过多将导致超时。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1000000int guess(int i)&#123; int l= 0,r= maxn; int m; int flag; while (l &lt; r)&#123; m = (l + r) &gt;&gt; 1; printf("guess %d %d\n", i, m); fflush(stdout); scanf("%d", &amp;flag); switch (flag)&#123; case -1: l = m + 1; break; case 1: r = m - 1; break; case 0: return m; &#125; &#125; return l;&#125;int main()&#123; int n, a[100]; printf("get_num\n"); fflush(stdout); scanf("%d", &amp;n); for (int i = 0; i&lt; n; i++) a[i] = guess(i); printf("submit"); for (int i = 0; i&lt; n; i++) printf(" %d", a[i]); printf("\n"); fflush(stdout);&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>双指针</tag>
        <tag>二分查找</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 5 GuessDate]]></title>
    <url>%2Fp%2Fca9d.html</url>
    <content type="text"><![CDATA[题目描述给你一个提示，请猜测对应的日期。假设日期 x 用 1, 2, …, n中的一个整数表示。 在任意一个数据点输出 0 都可以得到一定的同情分。 输入格式第一行一个整数 n ，表示日期 x 的范围是 1, 2, …, n。 第二行一个字符串，为一个关于日期 x 的 Python 表达式，表示给出的提示。 输出格式对于每个测试点，请将对应答案写入 date#.usr 中，并填入网页下方提交答案处，或者以 zip 压缩包形式上传。 样例样例输入1210abs(x - 7) == 4 样例输出13 数据范围与提示本题中给出的 Python 表达式与 C++ 语义相同。表达式中 x 是一个整型变量，当 x 为正确答案时，表达式求值为 True；否则为 False。保证答案惟一。 注： Python 中 a ** b 表示计算 $a^b$。 pi 的值为 3.1415926535897932；三角函数使用弧度制。 给出的表达式可以直接在 Python 中 from math import * 后求值。 本题的测试数据中，in 文件是输出 0可得的分数百分比；out 文件是正确日期。在上传提交答案类题目时，如果 Special Judge 不需要 in/out 文件，可在 data.yml 中对应省略 inputFile/outputFile 项。 不保证 答案是一个公历日期。 AC思路date1.usr题目: 121231x * (x - 31) == 815184 - x 解方程，不bb 1918 date2.usr题目 1220021231(x ** x % 911) + (x ^ (x % 1248679)) == 20000000 我直接费马定理整一下，然后范围内暴力 1234567891011121320010911for(long long i = 18750412; i &lt;= 20021231 ;i++)&#123; long long t1 = i % 911, t2 = i % 910; long long res = 1; for(long long k = 1; k &lt;= t2; k++)&#123; res = (res * t1) % 911; &#125; long long m = i ^ (i % 1248679); if(res + m == 20000000)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125;&#125; date3.usr题目 121234567890abs(2e9 - max(abs(x - 1e9), abs(x - 2e9), abs(x - 3e9))) &lt;= 10 and abs(sin(pi * (x + 25) / 32)) &lt;= 1e-8 不超过21个数字，暴力 1234567891,000,000,007const double pi = 3.141592653589793;for(long long i = 1000000000 - 10; i &lt;= 1000000000 + 10; i++)&#123; if(abs(sin(pi * (i + 25) / 32)) &lt;= 1e-8)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; date4.usr题目 121463030063184x * ((x &amp; -x) + ((x - (x &amp; -x)) &amp; -(x - (x &amp; -x)))) == 1463030063184 好题,对lowbit进行枚举，代回去检验 123456789101112131415161718192021222324121919171932#define low(x) ((x) &amp; (-x)) #define n 1463030063184int m = log2(n);long long lowx, lowy, t, x, tlowx, tlowy, s;for(int i = 0; i &lt;= m; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; lowx = 2 &lt;&lt; i; lowy = 2 &lt;&lt; j; t = lowx + lowy; if(n % t)continue; x = n / t; tlowx = low(x); if(tlowx != lowx) continue; tlowy = low((x - tlowx)); if(tlowy != lowy) continue; s = x * (tlowx + tlowy); if(s == n)&#123; cout&lt;&lt;x&lt;&lt;endl; break; &#125; &#125;&#125; date5.usr题目 121not not not not not not not not x and not (((x + (x ^ 998244353) + (((((x + 123) % 456 * 789) ^ 987) - x * 654) ^ (321 * (x % 2))) - (987654321 ^ ((x * x) &gt;&gt; 1)) - (12344321 * x * x * x) - ((1234321 - x) ^ (123454321 &gt;&gt; 2) / (x - 12321) - ((x + (x * x * x) ^ (x * x)) / (x + 123))) * x + 456789 / (x + 9) + 87654 + (32 &lt;&lt; (x + 1))) &gt;&gt; 19) + 1) 秒解 11]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 4 Quine]]></title>
    <url>%2Fp%2F9124.html</url>
    <content type="text"><![CDATA[题目描述写一个程序，使其能输出自己的源代码。 代码中必须至少包含十个可见字符。 输入格式输入文件为空。 输出格式你的源代码。 这是一个有趣的问题，Google一下 AC代码1234567#include &lt;stdio.h&gt;char *s = "#include &lt;stdio.h&gt;%c%cchar *s = %c%s%c;%c%cint main()&#123;%c%c%c%c%cprintf(s,10,10,34,s,34,10,10,10,32,32,32,32,10,10);%c&#125;%c";int main()&#123; printf(s,10,10,34,s,34,10,10,10,32,32,32,32,10,10);&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>mark</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3 Copycat]]></title>
    <url>%2Fp%2F671d.html</url>
    <content type="text"><![CDATA[题目描述这道题用于测试文件输入输出，请注意使用文件输入输出，而非标准输入输出。 输入一个正整数 $a$，输出这个数 $a$。 输入格式第一行一个 $T$ 正整数 ，表示有 $T$ 组测试数据。接下来 $T$ 行，每行一个正整数 $a$ 。 输出格式输出$T$行，每行一个正整数$a$。 样例样例输入 112343123 样例输出 1123123 样例输入 21211000000000000000000000000000000000 样例输出 211000000000000000000000000000000000 数据范围与提示对于所有测试点，$1\leq T \leq 10, 1 \leq a \leq 10^{1000}$。 子任务 1（10 分）$1\leq a \leq 3$；子任务 2（20 分）$1\leq a \leq 100000$；子任务 3（70 分）没有附加限制。 AC代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; freopen("copycat.in","r",stdin); freopen("copycat.out","w",stdout); int T;cin&gt;&gt;T; string a; while(T--)&#123; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2 Hello World]]></title>
    <url>%2Fp%2Ff77e.html</url>
    <content type="text"><![CDATA[题目描述输出 Hello, World!，大小写不限。 输入格式无输入。 输出格式一行 Hello, World!，大小写不限。 样例样例输出 11Hello, World! 样例输出 21hello, WORLD! AC代码1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello, world!"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 1 A+B]]></title>
    <url>%2Fp%2F1c57.html</url>
    <content type="text"><![CDATA[题目描述输入 $a$ 和 $b$，输出 $a$ + $b$ 的结果。 输入格式一行两个正整数 $a$ 和 $b$ 。 输出格式一行一个正整数$a$ + $b$。 样例样例输入11 2 样例输出13 数据范围与提示对于100%的数据，1$\leq a,b \leq 10^6$。 AC代码12345678#include&lt;bits/stdc++.h&gt; int main()&#123; int a,b; scanf("%d %d", &amp;a, &amp;b); printf("%d",a + b); return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树]]></title>
    <url>%2Fp%2F8905.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX19SRulbRaJ0AohDkBWN3OIy6/nvz7e/6QKylV/FWhQux0Cpim3L/Y0/MtFnOlX/jbj3ErhvyMTyYgvKnWHAUre7lsCpFl4q9uuulMtgwl5/gWVpqEJnOsxlaJGRueDUABjKnPDoTX7wRUVULYJUlDa5VvBOw1tBOpJrJ3GDEIOVL+c9Wx8p+krhjdFzqzd3aV7ef2EYHMIG8g==]]></content>
      <categories>
        <category>-- 数据结构</category>
      </categories>
      <tags>
        <tag>-- Trie树 -- 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 421]]></title>
    <url>%2Fp%2Ffbbb.html</url>
    <content type="text"><![CDATA[421. 数组中两个数的最大异或值给定一个非空数组，数组中元素为 $a_0, a_1, a_2, … , a_{n-1}$，其中 $0 \leq a_i &lt; 231$ 。 找到 $a_i$ 和$a_j$ 最大的异或 (XOR) 运算结果，其中$0 \leq i, j &lt; n$ 。 你能在O(n)的时间解决这个问题吗？ 示例: 12345输入: [3, 10, 5, 25, 2, 8]输出: 28解释: 最大的结果是 5 ^ 25 = 28. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：贪心]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>贪心</tag>
        <tag>Trie树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算方法绪论概述]]></title>
    <url>%2Fp%2F926f.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>计算方法</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python and Regex]]></title>
    <url>%2Fp%2Fa80d.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Python核心编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Games Creator]]></title>
    <url>%2Fp%2Fc0eb.html</url>
    <content type="text"><![CDATA[水果消消乐 微光城市]]></content>
      <categories>
        <category>Unity Games</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的那些插件]]></title>
    <url>%2Fp%2Feeb6.html</url>
    <content type="text"><![CDATA[pdf插件 安装插件 1npm install --save hexo-pdf 可以新增一个页面用来存放pdf 1hexo new page pdf_Library 增添pdf的链接可以在source/pdf_Library中找到index.md文件，编辑该文件: 12341.外部链接&#123; % pdf http://...... % &#125;2.内部(本地)链接&#123; % pdf XXXX/XXX/.../*.pdf % &#125; maths类插件 动画人物插件 …]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo插件</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习-纯CSS创作矩形旋转loader特效]]></title>
    <url>%2Fp%2F16be.html</url>
    <content type="text"><![CDATA[文章来源地址:大佬链接效果链接 代码解读定义dom,一个包含3个span的容器:12345&lt;div class=&quot;loader&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 居中显示:1234567html, body &#123; height: 100%; display: flex; align-items: center; justify-content: center; background-color: black;&#125; 设置容器的尺寸:12345.loader &#123; width: 150px; height: 150px; position: relative;&#125; 设置矩形的边框样式:123456.loader span &#123; position: absolute; box-sizing: border-box; border: 10px solid dimgray; border-radius: 2px;&#125; 设置3个矩形的尺寸:12345678910111213141516.loader span:nth-child(1) &#123; width: 100%; height: 100%;&#125;.loader span:nth-child(2) &#123; width: 70%; height: 70%; margin: 15%;&#125;.loader span:nth-child(3) &#123; width: 40%; height: 40%; margin: 30%;&#125; 用伪元素绘制左上和右下装饰条:123456789101112131415161718.loader span::before,.loader span::after &#123; content: &apos;&apos;; position: absolute; width: 10px; height: 50%; background-color: gold;&#125;.loader span::before &#123; top: -10px; left: -10px;&#125;.loader span::after &#123; bottom: -10px; right: -10px;&#125; 定义动画效果:123456789@keyframes rotating &#123; from &#123; transform: rotateY(0deg); &#125; to &#123; transform: rotateY(360deg); &#125;&#125; 把动画应用到3个矩形上:123456789101112131415.loader span &#123; animation: rotating linear infinite;&#125;.loader span:nth-child(1) &#123; animation-duration: 4s;&#125;.loader span:nth-child(2) &#123; animation-duration: 2s;&#125;.loader span:nth-child(3) &#123; animation-duration: 1s;&#125; 最后设置3个矩形的堆叠顺序:1234567891011.loader span:nth-child(1) &#123; z-index: 3;&#125;.loader span:nth-child(2) &#123; z-index: 2;&#125;.loader span:nth-child(3) &#123; z-index: 1;&#125; 知识点梳理 @keyframes https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes]]></content>
      <categories>
        <category>CSS学习</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>CSS3</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Game is not Games]]></title>
    <url>%2Fp%2Ff024.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+0PRrylla6+mSRQJho2Xv7u/j4KmMzgZ491+E3eX0bxvwJIAOYMb5ljkSM5NIeZA7CJk5nWpoDM1Fk8oVLa8zbQe7PJPx446up7PBMZPz+ARDmW6y+tIBFOYEK0IrNcy4BnscR8dpyU5e2Vs3AfsNbgtrp9pmEoOPNYFRv+6uWv1IVFJRh2hqzjhZEZbx2nlK8wncD91lAv5gxkBQphVldwyo/meiVUfeW57JDZmD8zBHkGHmuyXCrGptCT/hVpA9ZwOBQh0ksMcKn7GVnSJogWWcT+dRQ9OMLNFoDYFnVgHEYq1kqHQMoJqs+D2cRlJO20RIAseFhvpLEevRO6bThbhQi2P6UN2HjOzfcU3J6wlcAMYQkdzpqrU1Bn/5mfdFM3bwTa65Gji5y2Jar7OuSzOkdlPPachkhkrQNUd4zyaT7mONVJvRQ9T41LhC+GRBhpWTxsvpe+AnqMlIhCx+JSg51iI8AGdIGXjgcTfXagbb8WGLHG/f+KR5X7hZ+GiOq7PFNR7hAH5F+BnrnNN0UkXDfQIa/etUcaRbRnG8QqL4+zLIFioOO8ZjYWtWShF1bZDNnv0qi4lduXJE/LzFFJ8Pj/B5bhdispoLRTlnyXKGdq6SsxiZ6kbvolVnrpWTafPAEmiks6oyFU1BbY011ePvG4LOY0TdCvJM+j0SMI6nWYOwEYoupCLlRxtI4GEr9mjIlPygaJZ2B17AwiXAQG5kH3S/OE+Soa7XMO8lE93m1ygHsAmqwIjNMePWD2RujXMUbELmsOouayEOKP52Q+OsxwmrcYZsmpXsj8+dZR/OIcctHVQKk2nbsLouLQIfqYVlNg67mMe9PPKer0P5j+bytB4j6AReFawfc8d1A17T1rvuNsKuIyNYk5ImVwn5cvYHgeazxiKwBtA8dogdSIXC6b/iVXZlGZO/Z7jqNiIdkMJWKq6G5k8Oz03dTBBNRP/0vTjLkxcPbjycGsBq8dZ7/blDsiUHnDXV4XENApiXPnNMIe5Ra076dn4o+i3HnkJA24VEF+gWco8O2Tx1Ey4J/5Rs22UUMfTHB/jTksmihuAiVYqBwKF+QwYjjN4QTJawCFGd7EQ==]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Strategy Games</tag>
        <tag>Games Strategy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab整理]]></title>
    <url>%2Fp%2Fb14c.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fp%2F3eeb.html</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server12$ hexo server$ hexo s More info: Server Generate static files12$ hexo generate$ hexo g More info: Generating Deploy to remote sites12$ hexo deploy$ hexo d Another way1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment]]></content>
      <categories>
        <category>Hello_World</category>
      </categories>
      <tags>
        <tag>Hello_World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calculus-从入门到放弃]]></title>
    <url>%2Fp%2F5ba9.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+0YdWoYJv/Z28/qeBgfDRLX5i72L2WwbxpJAN+sNwH5uUBYeBnXgOkIWXzFiNQCqQYey6UUsl99DIid5EGeR1iensNtt1yVDYF3j4BhBb5zWrrMe/CFglXMqokD0nQEp2wZuf+NuJqzQ6vnCw3tng2WbDKqMH/5erXawifLT3SGNCsb4wC0XFiuF0xQD834DRft3OgNC49L2N2MKzgcB/TunOUXR1zSmwj4yYQKtT8WHVeigByvXfEdkkIO6h9VLzfetCJrKFZ0IxAp3qWF4WwyVtHSEYSboj+7peUUoe/R2akf+mTatr6CXUu5HsHV28jDdtCjNz2XZTXHpd3sibW1wZ+4fKWayqv/3gNNta0F0dVxt/FYdZFdW5qM4KmsRQG2Pre6eSATmtRT6/Fy551JG6nv1qwmDudGs0h0p0MjnmErQwPOrgNcRyuK/VDci6kueVJbTA1tCfeORP54HT+YQcvD+MkyLnrfl9AFQ8DxHvC+BDbfXmPGmwCRIocId2HTFPx4/xnIQ5p1FamVGvoJL/7axbmqCQ2D8UwurI+VgQ5rt7Q6v/vURXF9FtEKBB2bpl8Yippi6m05AW2UNrdxghMInjh48snwaUOfo9efNrFuPdXTYWnpassIKj+FbVPvrpAAIpUhg==]]></content>
      <categories>
        <category>Advanced mathematics</category>
      </categories>
      <tags>
        <tag>Maths</tag>
        <tag>Calculus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习2]]></title>
    <url>%2Fp%2Ffe97.html</url>
    <content type="text"><![CDATA[Italics and BoldTo make a phrase italic in Markdown, you can surround words with an underscore (_ ). For example, _this_(this )word would become italic. Similarly, to make phrases bold in Markdown, you can surround words with two asterisks ( ** ). This will **really**(really) get your point across. Of course, you can use _both italics and bold_ in the same line. You can also span them **across multiple words**. Finally,we’re going to make some words bold and italic.In general, it doesn’t matter which order you place the asterisks or underscores. HeadersTo make headers in Markdown, you preface the phrase with a hash mark (#). You place the same number of hash marks as the size of the header you want.For example:123456# Header one## Header two### Header three#### Header four##### Header five###### Header six 效果为 It’s up to you to decide when it’s appropriate to use which header. In general, headers one and six should be used sparingly. You can’t really make a header bold, but you can italicize certain words.(Obviously,(_)is good!) LinksThere are two different link types in Markdown, but both of them render the exact same way. The first link style is called an inline link. To create an inline link, you wrap the link text in brackets ( [ ] ), and then you wrap the link in parenthesis ( ( ) ). For example, to create a hyperlink to www.github.com, with a link text that says, Visit GitHub!, you’d write this in Markdown: [Visit GitHub!](www.github.com). You can add emphasis to link texts, if you like. Although it might make for an awkward experience, you can make links within headings, too. That’s all there is to writing inline links. The other link type is called a reference link. As the name implies, the link is actually a reference to another place in the document. Here’s an example of what we mean: 123456Here&apos;s [a link to something else][another place].Here&apos;s [yet another link][another-link].And now back to [the first link][another place].[another place]: www.github.com[another-link]: www.google.com The “references” above are the second set of brackets: [another place] and [another-link]. At the bottom of a Markdown document, these brackets are defined as proper links to outside websites. An advantage of the reference link style is that multiple links to the same place only need to be updated once. For example, if we decide to make all of the [another place] links go somewhere else, we only have to change the single reference link. Reference links don’t appear in the rendered Markdown. You define them by providing the same tag name wrapped in brackets, followed by a colon, followed by the link. ImagesIf you know how to create links in Markdown, you can create images, too. The syntax is nearly the same. Images also have two styles, just like links, and both of them render the exact same way. The difference between links and images is that images are prefaced with an exclamation point ( ! ). The first image style is called an inline image link. To create an inline image link, enter an exclamation point ( ! ), wrap the alt text in brackets ( [ ] ), and then wrap the link in parenthesis ( ( ) ). (Alt text is a phrase or sentence that describes the image for the visually impaired.) For example, to create an inline image link to the link (a bannekat picture from the github). https://octodex.github.com/images/bannekat.png, with an alt text that says, Benjamin Bannekat, you’d write this in Markdown:![Benjamin Bannekat](https://octodex.github.com/images/bannekat.png). Although you don’t need to add alt text, it will make your content accessible to your audience, including people who are visually impaired, use screen readers, or do not have high speed internet connections. For a reference image, you’ll follow the same pattern as a reference link. You’ll precede the Markdown with an exclamation point, then provide two brackets for the alt text, and then two more for the image tag. At the bottom of your Markdown page, you’ll define an image for the tag. BlockquotesIf you need to call special attention to a quote from another source, or design a pull quote for a magazine article, then Markdown’s blockquote syntax will be useful. A blockquote is a sentence or paragraph that’s been specially formatted to draw attention to the reader. For example: “The sin of doing nothing is the deadliest of all the seven sins. It has been said that for evil men to accomplish their purpose it is only necessary that good men should do nothing.” To create a block quote, all you have to do is preface a line with the “greater than” caret (&gt;). For example:1234&gt; &quot;In a few moments he was barefoot, his stockings folded in his pockets andhis canvas shoes dangling by their knotted laces over his shoulders and,picking a pointed salt-eaten stick out of the jetsam among the rocks, heclambered down the slope of the breakwater.&quot; You can also place a caret character on each line of the quote. This is particularly useful if your quote spans multiple paragraphs. Block quotes can contain other Markdown elements, such as italics, images, or links. ListsThere are two types of lists in the known universe: unordered and ordered. That’s a fancy way of saying that there are lists with bullet points, and lists with numbers. To create an unordered list, you’ll want to preface each item in the list with an asterisk ( * ). Each list item also gets its own line. For example, a grocery list in Markdown might look like this:1234* Milk* Eggs* Salmon* Butter All right! That’s how you write an unordered list. Now, let’s talk about ordered ones. An ordered list is prefaced with numbers, instead of asterisks. Take a look at this recipe: Crack three eggs over a bowl Pour a gallon of milk into the bowl Rub the salmon vigorously with butter Drop the salmon into the egg-milk bowl To write that in Markdown, you’d do this:12341. Crack three eggs over a bowl2. Pour a gallon of milk into the bowl3. Rub the salmon vigorously with butter4. Drop the salmon into the egg-milk bowl You can choose to add italics, bold, or links within lists, as you might expect. Occasionally, you might find the need to make a list with more depth, or, to nest one list within another. Have no fear, because the Markdown syntax is exactly the same. All you have to do is to remember to indent each asterisk one space more than the preceding item. For example, in the following list, we’re going to add some sub-lists to each “main” list item, describing the people in detail:123456789* Tintin * A reporter * Has poofy orange hair * Friends with the world&apos;s most awesome dog* Haddock * A sea captain * Has a fantastic beard * Loves whiskey * Possibly also scotch? When rendered, this list turns into the following grouping: Tintin A reporter Has poofy orange hair Friends with the world’s most awesome dog Haddock A sea captain Has a fantastic beard Loves whiskey Possibly also scotch? While you could continue to indent and add sub-lists indefinitely, it’s usually a good idea to stop after three levels; otherwise, your text becomes a mess. There’s one more trick to lists and indentation that we’ll explore, and that deals with the case of paragraphs. Suppose you want to create a bullet list that requires some additional context (but not another list). To create this sort of text, your paragraph must start on a line all by itself underneath the bullet point, and it must be indented by at least one space. Notice that the first two items have a single space. This looks a bit odd, so you might want to indent properly to match the characters up (like items three and four). In these paragraphs, you can include all sorts of other Markdown elements, like blockquotes, or even other lists! ParagraphsEach dot ( · ) represents a space on the keyboard.You can accomplish a soft break by inserting two spaces after each new line.]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习1]]></title>
    <url>%2Fp%2Fffd7.html</url>
    <content type="text"><![CDATA[列表在Markdown中只需要在文字的前面加上-即可，如下所示:123- 文本1- 文本2- 文本3 如果希望获得一个有序列表，只需修改为1. 2. 3.即可，如下所示:1231. 文本12. 文本23. 文本3 注:-、1.和文本之间需要保留一个字符的空格。 链接和图片在Markdown中，插入链接不需要其他按钮，只需要使用[显示文本](链接地址)这样即可，例如:[爸爸的博客](https://vingtdylan.github.io/)效果如下:爸爸的博客 类似的，在Markdown中，插入图片不需要其他按钮，只需要使用![](链接地址)这样即可，例如:![](https://vingtdylan.github.io)效果如下: 引用在写作的时候经常需要引用他人的文字，这时候需要添加引用格式，在Markdown中，只需添加一个&gt;即可，例如:&gt;那些年你冒险的梦注:&gt;和文本之间仍需要一个字符的空格效果如下: 那些年你冒险的梦 粗体和斜体Markdown中的粗体和斜体只需要用*或者**将文本包含起来即可，例如:**那些年**你很*冒险的梦*效果如下:那些年你很冒险的梦 代码引用当行使用(`)将语句包起来，如果引用多行语句，则用(```)包含文本即可，例如`hello world`和` ` ``#include&lt;iostream&gt;``using namespace std``int main(){}`` ` `显示效果依次为:hello world123#include&lt;iostream&gt;using namespace std;int main()&#123;&#125; 特别提示，在代码块中打出``` ````需要用4个`` ` ``包含3个`` ` ``.12### 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 1234567891011显示效果为:| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |注:表格上方必须为一个空行### 显示链接中带括号的图片 ![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20(n_{i})+11234567显示效果为:![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20(n_&#123;i&#125;)+1`Hexo中显示有问题...`### 分割线另起一行，连续输入三个`*`即可 第一行内容 第二行内容`效果如下:第一行内容 第二行内容]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习-纯CSS实现按钮文字滑动特效]]></title>
    <url>%2Fp%2F2c4.html</url>
    <content type="text"><![CDATA[文章来源地址:大佬链接效果链接 代码解读定义DOM，在一个容器定义按钮的文字，每个字母都使用一个span，每个span又有一个data-text属性，具体如下:12345678&lt;div class=&quot;box&quot;&gt; &lt;span data-text=&quot;B&quot;&gt;B&lt;/span&gt; &lt;span data-text=&quot;U&quot;&gt;U&lt;/span&gt; &lt;span data-text=&quot;T&quot;&gt;T&lt;/span&gt; &lt;span data-text=&quot;T&quot;&gt;T&lt;/span&gt; &lt;span data-text=&quot;O&quot;&gt;O&lt;/span&gt; &lt;span data-text=&quot;N&quot;&gt;N&lt;/span&gt;&lt;/div&gt; 按钮居中设置:123456html, body &#123; height: 100%; display: flex; align-items: center; justify-content: center;&#125; 然后设置按钮的尺寸和文字样式:123456789.box &#123; width: 200px; height: 60px; border: 2px solid black; text-align: center; font-size: 30px; line-height: 60px; font-family: sans-serif;&#125; 需要将按钮的每个字母元素都设置为行内块元素，这只是为了方便后面单独处理动态效果:1234.box span &#123; display: inline-block; color: blue;&#125; 将字母交错显示在按钮容器之外,这里可以将第奇数个元素显示在上，第偶数个元素显示在下:1234567.box span:nth-child(odd) &#123; transform: translateY(-100%);&#125;.box span:nth-child(even) &#123; transform: translateY(100%);&#125; 用伪元素给每个字母增加一个副本12345.box span::before &#123; content: attr(data-text); position: absolute; color: red;&#125; 然后让伪元素也交错显示，位置与其原始元素相对:1234567.box span:nth-child(odd)::before &#123; transform: translateY(100%);&#125;.box span:nth-child(even)::before &#123; transform: translateY(-100%);&#125; 为增加鼠标划过样式，设置过渡时间:1234567.box:hover span &#123; transform: translateY(0);&#125;.box span &#123; transition: 0.5s;&#125; 最后一步，隐藏容器外的内容:123.box &#123; overflow: hidden;&#125; 知识点梳理flex布局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较好的一个学习总结:链接跳转处 justify-content属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于设置或者检索弹性盒子元素在主轴(横轴)方向上的对齐方式。可以参看菜鸟教程 百分比%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS中的百分比计算方法 伪元素(Pseudo-elements)-&gt;before,after&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W3School上的讲解 translateY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQery之家的解释 data-*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于嵌套自定义数据,移步W3School content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于插入生成内容,链接跳转 nth-child&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常见的选择器了，再好好复习一下吧,链接跳转]]></content>
      <categories>
        <category>CSS学习</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>CSS3</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
