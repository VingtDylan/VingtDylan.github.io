<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LeetCode 101]]></title>
    <url>%2Fp%2F9aaa.html</url>
    <content type="text"><![CDATA[101. 对称二叉树难度: easy 给定一个二叉树，检查它是否是镜像对称的。 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。 12345 1 / \ 2 2 / \ / \3 4 4 3 但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的: 12345 1 / \2 2 \ \ 3 3 进阶： 你可以运用递归和迭代两种方法解决这个问题吗？ 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/symmetric-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码迭代水一下 1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSymmetric(TreeNode* root) &#123; if(!root)return true; return isSymmetricSubTree(root-&gt;left,root-&gt;right); &#125; bool isSymmetricSubTree(TreeNode* left, TreeNode* right)&#123; if(!left &amp;&amp; !right)return true; if(!left || !right)return false; if(left-&gt;val != right-&gt;val)return false; return isSymmetricSubTree(left-&gt;left,right-&gt;right) &amp;&amp; isSymmetricSubTree(left-&gt;right,right-&gt;left); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 84]]></title>
    <url>%2Fp%2Ff8ef.html</url>
    <content type="text"><![CDATA[84. 柱状图中最大的矩形难度:hard 给定 n 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。 求在该柱状图中，能够勾勒出来的矩形的最大面积。 以上是柱状图的示例，其中每个柱子的宽度为 1，给定的高度为 [2,1,5,6,2,3]。 图中阴影部分为所能勾勒出的最大矩形面积，其面积为 10 个单位。 示例: 12输入: [2,1,5,6,2,3]输出: 10 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/largest-rectangle-in-histogram著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码monostack单调栈 1234567891011121314151617181920class Solution &#123;public: int largestRectangleArea(vector&lt;int&gt;&amp; heights) &#123; int res = 0; stack&lt;int&gt; stk; heights.insert(heights.begin(),0); heights.push_back(0); for(int i = 0; i &lt; heights.size(); i++)&#123; while(!stk.empty() &amp;&amp; heights[stk.top()] &gt; heights[i])&#123; int cur = stk.top(); stk.pop(); int left = stk.top() + 1; int right = i - 1; res = max((right - left + 1) * heights[cur], res); &#125; stk.push(i); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 198]]></title>
    <url>%2Fp%2Fcc6c.html</url>
    <content type="text"><![CDATA[198. 打家劫舍难度: easy 你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。 给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。 示例 1: 1234输入: [1,2,3,1]输出: 4解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。 偷窃到的最高金额 = 1 + 3 = 4 。 示例 2: 1234输入: [2,7,9,3,1]输出: 12解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。 偷窃到的最高金额 = 2 + 9 + 1 = 12 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/house-robber著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码普通dp即可 1234567891011121314class Solution &#123;public: int rob(vector&lt;int&gt;&amp; nums) &#123; if(nums.empty())return 0; if(nums.size() == 1)return nums[0]; vector&lt;int&gt; dp(nums.size()); dp[0] = nums[0]; dp[1] = max(nums[0], nums[1]); for(int i = 2; i &lt; nums.size(); i++)&#123; dp[i] = max(dp[i - 1], dp[i - 2] + nums[i]); &#125; return dp.back(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 394]]></title>
    <url>%2Fp%2F9cd.html</url>
    <content type="text"><![CDATA[394. 字符串解码难度: medium 给定一个经过编码的字符串，返回它解码后的字符串。 编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。 你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。 此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。 示例: 123s = &quot;3[a]2[bc]&quot;, 返回 &quot;aaabcbc&quot;.s = &quot;3[a2[c]]&quot;, 返回 &quot;accaccacc&quot;.s = &quot;2[abc]3[cd]ef&quot;, 返回 &quot;abcabccdcdcdef&quot;. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/decode-string著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425262728293031class Solution &#123;public: string decodeString(string s) &#123; string t = ""; stack&lt;int&gt; k; stack&lt;string&gt; str; int n = s.size(); int count = 0; for(int i = 0; i &lt; n; i++)&#123; if(s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9')&#123; count = 10 * count + s[i] - '0'; &#125;else if(s[i] == '[')&#123; k.push(count); str.push(t); count = 0; t.clear(); &#125;else if(s[i] == ']')&#123; int num = k.top(); k.pop(); while(num--)&#123; str.top() += t; &#125; t = str.top(); str.pop(); &#125;else&#123; t += s[i]; &#125; &#125; return str.empty() ? t : str.top(); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>深度优先搜索</tag>
        <tag>栈</tag>
        <tag>LeetCOde</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 974]]></title>
    <url>%2Fp%2F6be9.html</url>
    <content type="text"><![CDATA[974. 和可被 K 整除的子数组难度: medium 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。 示例： 12345输入：A = [4,5,0,-2,-3,1], K = 5输出：7解释：有 7 个子数组满足其元素之和可被 K = 5 整除：[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3] 提示： 1 &lt;= A.length &lt;= 30000 -10000 &lt;= A[i] &lt;= 10000 2 &lt;= K &lt;= 10000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sums-divisible-by-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码果然低端前缀和走不远，跟LeetCode 560差不多，注意负数的问题就是了 这就是同余的力量吧 123456789101112131415161718192021222324252627282930class Solution &#123;public: int subarraysDivByK(vector&lt;int&gt;&amp; A, int K) &#123; /*TLE int n = A.size(); vector&lt;int&gt; dp(n + 1); for(int i = 1; i &lt; n + 1; i++)&#123; dp[i] = dp[i - 1] + A[i - 1]; &#125; int res = 0; for(int i = 1; i &lt; dp.size(); i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if((dp[j] - dp[i]) % K == 0)&#123; res++; &#125; &#125; &#125; return res; */ int res = 0, sum = 0, n = A.size(); unordered_map&lt;int,int&gt; mp&#123;&#123;0,1&#125;&#125;; for(int i = 0; i &lt; n; i++)&#123; sum += (A[i] % K + K) % K; sum %= K; res += mp[sum]; mp[sum]++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 287]]></title>
    <url>%2Fp%2F58dd.html</url>
    <content type="text"><![CDATA[287. 寻找重复数难度: medium 给定一个包含 n + 1 个整数的数组 nums，其数字都在 1 到 n 之间（包括 1 和 n），可知至少存在一个重复的整数。假设只有一个重复的整数，找出这个重复的数。 示例 1: 12输入: [1,3,4,2,2]输出: 2 示例 2: 12输入: [3,1,3,4,2]输出: 3 说明： 不能更改原数组（假设数组是只读的）。 只能使用额外的 O(1) 的空间。 时间复杂度小于 O(n2) 。 数组中只有一个重复的数字，但它可能不止重复出现一次。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/find-the-duplicate-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码弱智的我第一次还以为重复的数字只出现一次，所以累加和…tui 123456789101112131415161718192021222324class Solution &#123;public: int findDuplicate(vector&lt;int&gt;&amp; nums) &#123; int left = 1, right = (int)nums.size() - 1; while(left &lt; right)&#123; int mid = left + right &gt;&gt; 1; int co = count(nums,mid); if(co &lt;= mid)&#123; left = mid + 1; &#125;else&#123; right = mid; &#125; &#125; return left; &#125; int count(vector&lt;int&gt;&amp; nums, int target)&#123; int res = 0; for(auto num : nums)&#123; res += target &gt;= num; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二分查找</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 146]]></title>
    <url>%2Fp%2F98e9.html</url>
    <content type="text"><![CDATA[146. LRU缓存机制难度: medium 运用你所掌握的数据结构，设计和实现一个 LRU (最近最少使用) 缓存机制。它应该支持以下操作： 获取数据 get 和 写入数据 put 。 获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。写入数据 put(key, value) - 如果密钥已经存在，则变更其数据值；如果密钥不存在，则插入该组「密钥/数据值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。 进阶: 你是否可以在 O(1) 时间复杂度内完成这两种操作？ 示例: 1234567891011LRUCache cache = new LRUCache( 2 /* 缓存容量 */ );cache.put(1, 1);cache.put(2, 2);cache.get(1); // 返回 1cache.put(3, 3); // 该操作会使得密钥 2 作废cache.get(2); // 返回 -1 (未找到)cache.put(4, 4); // 该操作会使得密钥 1 作废cache.get(1); // 返回 -1 (未找到)cache.get(3); // 返回 3cache.get(4); // 返回 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lru-cache著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码使用了splice函数 list中排序，越是最近，放在头部 存储key和list迭代器的映射，方便使用find查找 超过capacity时，清除末尾即可 123456789101112131415161718192021222324252627282930313233343536class LRUCache &#123;public: LRUCache(int capacity) &#123; cap = capacity; &#125; int get(int key) &#123; auto iter = mp.find(key); if(iter == mp.end())return -1; l.splice(l.begin(), l, iter-&gt;second); return iter-&gt;second-&gt;second; &#125; void put(int key, int value) &#123; auto iter = mp.find(key); if(iter != mp.end()) l.erase(iter-&gt;second); l.push_front(make_pair(key, value)); mp[key] = l.begin(); if(mp.size() &gt; cap)&#123; int k = l.rbegin()-&gt;first; l.pop_back(); mp.erase(k); &#125; &#125;private: int cap; list&lt;pair&lt;int,int&gt;&gt; l; unordered_map&lt;int,list&lt;pair&lt;int,int&gt;&gt;::iterator&gt; mp;&#125;;/** * Your LRUCache object will be instantiated and called as such: * LRUCache* obj = new LRUCache(capacity); * int param_1 = obj-&gt;get(key); * obj-&gt;put(key,value); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 4]]></title>
    <url>%2Fp%2F6b6a.html</url>
    <content type="text"><![CDATA[4. 寻找两个正序数组的中位数难度: hard 给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。 请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。 你可以假设 nums1 和 nums2 不会同时为空。 示例 1: 1234nums1 = [1, 3]nums2 = [2]则中位数是 2.0 示例 2: 1234nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/median-of-two-sorted-arrays著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码查找两次 m = nums1.size(), n = nums2.size() trick: 中位数则为:((m+n+1)/2 + (m+n+2)/2)/2.0 对空间的优化以后补充(如果想起来的话) 细节的优化处真是有点烦人 1234567891011121314151617181920212223class Solution &#123;public: double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123; int m = nums1.size(), n = nums2.size(); int mean1 = (m + n + 1) / 2, mean2 = (m + n + 2) / 2; return (process(nums1,nums2,mean1) + process(nums1,nums2,mean2))/ 2.0; &#125; int process(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2,int k)&#123; if(nums1.empty())return nums2[k - 1]; if(nums2.empty())return nums1[k - 1]; if(k == 1)return min(nums1[0],nums2[0]); //divide and conquer int midk1 = min((int)nums1.size(), k / 2); int midk2 = min((int)nums2.size(), k / 2); if(nums1[midk1 - 1] &gt; nums2[midk2 - 1])&#123; return process(nums1,vector&lt;int&gt;(nums2.begin() + midk2, nums2.end()), k - midk2); &#125;else&#123; return process(vector&lt;int&gt;(nums1.begin() + midk1, nums1.end()), nums2, k - midk1); &#125; return 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>mark</tag>
        <tag>二分查找</tag>
        <tag>分治算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 76]]></title>
    <url>%2Fp%2Fc96b.html</url>
    <content type="text"><![CDATA[76. 最小覆盖子串难度: hard 给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。 示例： 12输入: S = &quot;ADOBECODEBANC&quot;, T = &quot;ABC&quot;输出: &quot;BANC&quot; 说明： 如果 S 中不存这样的子串，则返回空字符串 &quot;&quot;。 如果 S 中存在这样的子串，我们保证它是唯一的答案。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-window-substring著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425class Solution &#123;public: string minWindow(string s, string t) &#123; unordered_map&lt;char,int&gt; mp; for(char c : t)mp[c]++; int len = s.size(), target = t.size(); int count = 0, left = 0; int length = INT_MAX, minleft = -1; for(int i = 0; i &lt; len; i++)&#123; if(--mp[s[i]] &gt;= 0)&#123; count++; &#125; while(count == target)&#123; int temp = i - left + 1; if(temp &lt; length)&#123; length = temp; minleft = left; &#125; if(++mp[s[left]] &gt; 0)count--; left++; &#125; &#125; return minleft == -1 ? "" : s.substr(minleft,length); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>字符串</tag>
        <tag>mark</tag>
        <tag>双指针</tag>
        <tag>Sliding Window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 105]]></title>
    <url>%2Fp%2F59ab.html</url>
    <content type="text"><![CDATA[105. 从前序与中序遍历序列构造二叉树难度: medium 根据一棵树的前序遍历与中序遍历构造二叉树。 注意:你可以假设树中没有重复的元素。 例如，给出 12前序遍历 preorder = [3,9,20,15,7]中序遍历 inorder = [9,3,15,20,7] 返回如下的二叉树： 12345 3 / \9 20 / \ 15 7 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码写个递归拉到了，迭代懒得写，以后补吧 同样的问题还有很多，需要说明的是，迭代才有点难度，尤其是涉及后序遍历相关的问题 1234567891011121314151617181920212223242526272829303132333435/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* buildTree(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder) &#123; if(preorder.empty() || inorder.empty() || preorder.size() != inorder.size())return NULL; int len1 = preorder.size(), len2 = inorder.size(); return process(preorder, inorder, 0, len1 - 1, 0, len2 - 1); &#125; TreeNode* process(vector&lt;int&gt;&amp; preorder, vector&lt;int&gt;&amp; inorder,int l1, int r1, int l2, int r2)&#123; if(l1 &gt; r1 || l2 &gt; r2)return NULL; int rootValue = preorder[l1]; TreeNode* root = new TreeNode(rootValue); TreeNode* leftNode = NULL, *rightNode = NULL; int index = l2; while(inorder[index] != rootValue &amp;&amp; index &lt;= r2)index++; if(index &gt; l2)&#123; leftNode = process(preorder, inorder, l1 + 1, l1 + index - l2, l2, index - 1); &#125; if(index &lt; r2)&#123; rightNode = process(preorder, inorder, l1 + index - l2 + 1, r1, index + 1, r2); &#125; root-&gt;left = leftNode; root-&gt;right = rightNode; return root; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>深度优先搜索</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 5]]></title>
    <url>%2Fp%2Fabab.html</url>
    <content type="text"><![CDATA[5. 最长回文子串难度: medium 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例 1： 123输入: &quot;babad&quot;输出: &quot;bab&quot;注意: &quot;aba&quot; 也是一个有效答案。 示例 2： 12输入: &quot;cbbd&quot;输出: &quot;bb&quot; 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-palindromic-substring著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码动态规划1234567891011121314151617181920class Solution &#123;public: string longestPalindrome(string s) &#123; if(s.empty())return ""; int n = s.size(); vector&lt;vector&lt;int&gt;&gt; dp(n, vector&lt;int&gt;(n, 0)); int len = 1, st = 0; for(int i = 0; i &lt; n; i++)&#123; dp[i][i] = 1; for(int j = 0; j &lt; i; j++)&#123; dp[j][i] = (s[j] == s[i]) &amp;&amp; (i - j &lt; 2 || dp[j + 1][i - 1]); if(dp[j][i] &amp;&amp; len &lt; i - j + 1)&#123; len = i - j + 1; st = j; &#125; &#125; &#125; return s.substr(st, len); &#125;&#125;; 马拉车算法(Manacher’s Algorithm)参考马拉车算法 1234567891011121314151617181920212223242526272829class Solution &#123;public: string longestPalindrome(string s) &#123; string newS = "$#"; for(char c : s)&#123; newS += c; newS += '#'; &#125; newS += '@'; int n = newS.size(); vector&lt;int&gt; p(n); int id = 0, mx = 0; int len = 1, idx = 0; for(int j = 1; j &lt; n - 1; j++)&#123; p[j] = mx &gt; j ? min(p[2 * id - j], mx - j) : 1; while(newS[j + p[j]] == newS[j - p[j]])p[j]++; if(mx &lt; p[j] + j)&#123; mx = p[j] + j; id = j; &#125; if(len &lt; p[j] - 1)&#123; len = p[j] - 1; idx = j; &#125; &#125; int st = (idx - len) / 2; return s.substr(st, len); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>字符串</tag>
        <tag>mark</tag>
        <tag>马拉车算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 101 最大流]]></title>
    <url>%2Fp%2F69d2.html</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1371]]></title>
    <url>%2Fp%2Fb28.html</url>
    <content type="text"><![CDATA[1371. 每个元音包含偶数次的最长子字符串难度: medium 给你一个字符串 s ，请你返回满足以下条件的最长子字符串的长度：每个元音字母，即 ‘a’，’e’，’i’，’o’，’u’ ，在子字符串中都恰好出现了偶数次。 示例 1： 123输入：s = &quot;eleetminicoworoep&quot;输出：13解释：最长子字符串是 &quot;leetminicowor&quot; ，它包含 e，i，o 各 2 个，以及 0 个 a，u 。 示例 2： 123输入：s = &quot;leetcodeisgreat&quot;输出：5解释：最长子字符串是 &quot;leetc&quot; ，其中包含 2 个 e 。 示例 3： 123输入：s = &quot;bcbcbc&quot;输出：6解释：这个示例中，字符串 &quot;bcbcbc&quot; 本身就是最长的，因为所有的元音 a，e，i，o，u 都出现了 0 次。 提示： 1 &lt;= s.length &lt;= 5 x 10^5 s 只包含小写英文字母。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/divisor-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425class Solution &#123;public: int findTheLongestSubstring(string s) &#123; int res = 0, flag = 0; vector&lt;int&gt; position(32, -1); position[0] = 0; for(int i = 0; i &lt; s.size(); i++)&#123; char c = s[i]; switch(c)&#123; case 'a': flag ^= 1 &lt;&lt; 0; break; case 'e': flag ^= 1 &lt;&lt; 1; break; case 'i': flag ^= 1 &lt;&lt; 2; break; case 'o': flag ^= 1 &lt;&lt; 3; break; case 'u': flag ^= 1 &lt;&lt; 4; break; default:break; &#125; if(position[flag] == -1)&#123; position[flag] = i + 1; &#125;else&#123; res = max(res, i - position[flag] + 1); &#125; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
        <tag>前缀和</tag>
        <tag>状态压缩</tag>
        <tag>mark</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 680]]></title>
    <url>%2Fp%2F5bdd.html</url>
    <content type="text"><![CDATA[680. 验证回文字符串 Ⅱ难度: easy 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串。 示例 1: 12输入: &quot;aba&quot;输出: True 示例 2: 123输入: &quot;abca&quot;输出: True解释: 你可以删除c字符。 注意: 字符串只包含从 a-z 的小写字母。字符串的最大长度是50000。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/valid-palindrome-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617class Solution &#123;public: bool validPalindrome(string s) &#123; if(s.size() &lt;= 1)return true; return valid(s, 0, s.size() - 1, 0); &#125; bool valid(string&amp; s, int left, int right, int c)&#123; if(left &gt;= right)return true; if(s[left] == s[right])return valid(s, left + 1, right - 1, c); else&#123; if(c &gt; 0)return false; c++; return valid(s,left + 1, right, c) || valid(s,left, right - 1); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 152]]></title>
    <url>%2Fp%2Fcbe9.html</url>
    <content type="text"><![CDATA[152. 乘积最大子数组难度: medium 给你一个整数数组 nums ，请你找出数组中乘积最大的连续子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。 示例 1: 123输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2: 123输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-product-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415class Solution &#123;public: int maxProduct(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int res = nums[0]; vector&lt;int&gt; dp1(n,0);dp1[0] = nums[0]; vector&lt;int&gt; dp2(n,0);dp2[0] = nums[0]; for(int i = 1; i &lt; n; i++)&#123; dp1[i] = max(max(nums[i], dp1[i - 1] * nums[i]), dp2[i - 1] * nums[i]); dp2[i] = min(min(nums[i], dp1[i - 1] * nums[i]), dp2[i - 1] * nums[i]); res = max(dp1[i],res); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 210]]></title>
    <url>%2Fp%2Fca9a.html</url>
    <content type="text"><![CDATA[210. 课程表 II难度: medium 现在你总共有 n 门课需要选，记为 0 到 n-1。 在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1] 给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。 可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。 示例 1: 123输入: 2, [[1,0]] 输出: [0,1]解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。 示例 2: 1234输入: 4, [[1,0],[2,0],[3,1],[3,2]]输出: [0,1,2,3] or [0,2,1,3]解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。 因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。 说明: 输入的先决条件是由边缘列表表示的图形，而不是邻接矩阵。详情请参见图的表示法。 你可以假定输入的先决条件中没有重复的边。 提示: 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。 通过 DFS 进行拓扑排序 - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。 拓扑排序也可以通过 BFS 完成。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/course-schedule-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 分析1.很明显的拓扑排序问题 有向无环图结点的线性排序 2.BFS算法step1:统计图中每个节点的入度，生成入度表 indegrees。step2:借助一个队列 queue，将所有入度为0的节点入队。step3:当queue非空时，依次将队首节点出队，依次将队首节点的所有邻接节点cur的入度-1，即 indegrees[cur] -= 1;当入度-1后邻接节点cur的入度为0，说明cur所有的前驱节点已经被 “删除”，此时将cur入队 3.DFS算法略了，懒得打，网上有很多解析 AC代码BFS12345678910111213141516171819202122232425262728class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; res; vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;(0)); vector&lt;int&gt; indegrees(numCourses,0); for(auto &amp; pre : prerequisites)&#123; graph[pre[1]].push_back(pre[0]); indegrees[pre[0]]++; &#125; queue&lt;int&gt; q; for(int i = 0; i &lt; numCourses; i++)&#123; if(indegrees[i] == 0)q.push(i); &#125; while(!q.empty())&#123; int t = q.front(); res.push_back(t); q.pop(); for(auto &amp;a: graph[t])&#123; indegrees[a]--; if(indegrees[a] == 0) q.push(a); &#125; &#125; if(res.size() != numCourses)return &#123;&#125;; return res; &#125;&#125;; DFS12345678910111213141516171819202122232425262728293031323334353637class Solution &#123;public: vector&lt;int&gt; findOrder(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) &#123; vector&lt;int&gt; res; vector&lt;vector&lt;int&gt;&gt; graph(numCourses,vector&lt;int&gt;(0)); vector&lt;int&gt; visited(numCourses); bool circle = false; for(auto &amp; pre : prerequisites)&#123; graph[pre[1]].push_back(pre[0]); &#125; for(int i = 0; i &lt; numCourses &amp;&amp; !circle; i++)&#123; if(!visited[i])&#123; dfs(i,res,graph,visited,circle); &#125; &#125; if(circle)return &#123;&#125;; reverse(res.begin(),res.end()); return res; &#125; void dfs(int x, vector&lt;int&gt;&amp; res, vector&lt;vector&lt;int&gt;&gt;&amp; graph, vector&lt;int&gt;&amp; visited, bool&amp; circle)&#123; visited[x] = 1; for(int v: graph[x])&#123; if(visited[v] == 0)&#123; dfs(v,res,graph,visited,circle); if(circle)&#123; return; &#125; &#125;else if(visited[v] == 1)&#123; circle = true; return; &#125; &#125; visited[x]= 2; res.push_back(x); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
        <tag>广度优先搜索</tag>
        <tag>mark</tag>
        <tag>图</tag>
        <tag>拓扑排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 25]]></title>
    <url>%2Fp%2F9828.html</url>
    <content type="text"><![CDATA[25. K 个一组翻转链表难度: hard 给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。 k 是一个正整数，它的值小于或等于链表的长度。 如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。 示例： 给你这个链表：1-&gt;2-&gt;3-&gt;4-&gt;5 当 k = 2 时，应当返回: 2-&gt;1-&gt;4-&gt;3-&gt;5 当 k = 3 时，应当返回: 3-&gt;2-&gt;1-&gt;4-&gt;5 说明： 你的算法只能使用常数的额外空间。 你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/reverse-nodes-in-k-group著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路递归不递归都随便吧，按照题意实现而已 1.非递归123456789101112131415161718192021222324252627282930313233343536373839/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k == 1)return head; ListNode* dummy = new ListNode(-1); dummy-&gt;next = head; ListNode* pre = dummy; ListNode* cur = head; for(int i = 1; cur; i++)&#123; if(i % k == 0)&#123; pre = reverse(pre, cur-&gt;next); cur = pre-&gt;next; &#125;else&#123; cur = cur-&gt;next; &#125; &#125; return dummy-&gt;next; &#125; ListNode* reverse(ListNode* pre, ListNode* last)&#123; ListNode* dummy = pre-&gt;next; ListNode* cur = dummy-&gt;next; while(cur != last)&#123; dummy-&gt;next = cur-&gt;next; cur-&gt;next = pre-&gt;next; pre-&gt;next = cur; cur = dummy-&gt;next; &#125; return dummy; &#125;&#125;; 2.递归123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* reverseKGroup(ListNode* head, int k) &#123; if(!head || k == 1)return head; ListNode* cur = head; for(int i = 0; i &lt; k; i++)&#123; if(!cur)return head; cur = cur-&gt;next; &#125; ListNode* dummy = reverse(head, cur); head-&gt;next = reverseKGroup(cur, k); return dummy; &#125; ListNode* reverse(ListNode* head, ListNode* tail)&#123; ListNode* pre = tail; while(head != tail)&#123; ListNode* temp = head-&gt;next; head-&gt;next = pre; pre = head; head = temp; &#125; return pre; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 560]]></title>
    <url>%2Fp%2F3b29.html</url>
    <content type="text"><![CDATA[560. 和为K的子数组难度: medium 给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。 示例 1 : 12输入:nums = [1,1,1], k = 2输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。 说明 : 数组的长度为 [1, 20,000]。 数组中元素的范围是 [-1000, 1000] ，且整数 k 的范围是 [-1e7, 1e7]。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subarray-sum-equals-k著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930class Solution &#123;public: int subarraySum(vector&lt;int&gt;&amp; nums, int k) &#123; // TLE // TLE的输入太过酸爽 // int res = 0; // int n = nums.size(); // vector&lt;int&gt; sums(n); // sums[0] = nums[0]; // for(int i = 1; i &lt; n; i++)&#123; // sums[i] = sums[i - 1] + nums[i]; // &#125; // for(int i = 0; i &lt; n; i++)&#123; // if(sums[i] == k)res++; // for(int j = i - 1; j &gt;= 0; j--)&#123; // if(sums[i] - sums[j] == k) // res++; // &#125; // &#125; // return res; int res = 0, sum = 0, n = nums.size(); unordered_map&lt;int,int&gt; mp&#123;&#123;0,1&#125;&#125;; for(int i = 0; i &lt; n; i++)&#123; sum += nums[i]; res += mp[sum - k]; mp[sum]++; &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数组</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 136]]></title>
    <url>%2Fp%2Fa8eb.html</url>
    <content type="text"><![CDATA[136. 只出现一次的数字难度: easy 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。 说明： 你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？ 示例 1: 12输入: [2,2,1]输出: 1 示例 2: 12输入: [4,1,2,1,2]输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/single-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码至于其他思路哈希表啥的都很简单，懒得写了，因为没啥技术含量 123456789class Solution &#123;public: int singleNumber(vector&lt;int&gt;&amp; nums) &#123; int res = 0; for(int num : nums) res ^= num; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 102]]></title>
    <url>%2Fp%2F9bea.html</url>
    <content type="text"><![CDATA[102. 二叉树的层序遍历难度: medium 给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。 示例：二叉树：[3,9,20,null,null,15,7], 12345 3 / \9 20 / \ 15 7 返回其层次遍历结果： 12345[ [3], [9,20], [15,7]] 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/binary-tree-level-order-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码迭代(BFS)123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; if(!root)return &#123;&#125;; vector&lt;vector&lt;int&gt;&gt; res; queue&lt;TreeNode*&gt; q; q.push(root); while(!q.empty())&#123; vector&lt;int&gt; level; int len = q.size(); for(int i = 0; i &lt; len; i++)&#123; TreeNode* node = q.front(); q.pop(); level.push_back(node-&gt;val); if(node-&gt;left) q.push(node-&gt;left); if(node-&gt;right) q.push(node-&gt;right); &#125; res.push_back(level); &#125; return res; &#125;&#125;; 递归(DFS)12345678910111213141516171819202122232425/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) &#123; vector&lt;vector&lt;int&gt;&gt; res; traverse(root,res,0); return res; &#125; void traverse(TreeNode* root, vector&lt;vector&lt;int&gt;&gt;&amp; res, int level)&#123; if(!root)return; if(res.size() == level)res.push_back(&#123;&#125;); res[level].push_back(root-&gt;val); traverse(root-&gt;left,res,level + 1); traverse(root-&gt;right,res,level + 1); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>广度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 155]]></title>
    <url>%2Fp%2F9a8.html</url>
    <content type="text"><![CDATA[155. 最小栈难度: medium 设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。 push(x) —— 将元素 x 推入栈中。 pop() —— 删除栈顶的元素。 top() —— 获取栈顶元素。 getMin() —— 检索栈中的最小元素。 示例: 12345678910111213141516输入：[&quot;MinStack&quot;,&quot;push&quot;,&quot;push&quot;,&quot;push&quot;,&quot;getMin&quot;,&quot;pop&quot;,&quot;top&quot;,&quot;getMin&quot;][[],[-2],[0],[-3],[],[],[],[]]输出：[null,null,null,null,-3,null,0,-2]解释：MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); --&gt; 返回 -3.minStack.pop();minStack.top(); --&gt; 返回 0.minStack.getMin(); --&gt; 返回 -2. 提示： pop、top 和 getMin 操作总是在 非空栈 上调用。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/min-stack著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码双栈或者记录“曾经”的最小值，注意相同的值 双栈123456789101112131415161718192021222324252627282930313233343536class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; &#125; void push(int x) &#123; stk1.push(x); if(stk2.empty() || x &lt;= stk2.top())stk2.push(x); &#125; void pop() &#123; if(stk1.top() == stk2.top())stk2.pop(); stk1.pop(); &#125; int top() &#123; return stk1.top(); &#125; int getMin() &#123; return stk2.top(); &#125;private: stack&lt;int&gt; stk1,stk2;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */ 曾经的最小值1234567891011121314151617181920212223242526272829303132333435363738394041424344class MinStack &#123;public: /** initialize your data structure here. */ MinStack() &#123; minm = INT_MAX; &#125; void push(int x) &#123; if(x &lt;= minm)&#123; stk.push(minm); minm = x; &#125; stk.push(x); &#125; void pop() &#123; int t = stk.top(); stk.pop(); if(t == minm)&#123; minm = stk.top(); stk.pop(); &#125; &#125; int top() &#123; return stk.top(); &#125; int getMin() &#123; return minm; &#125;private: stack&lt;int&gt; stk; int minm;&#125;;/** * Your MinStack object will be instantiated and called as such: * MinStack* obj = new MinStack(); * obj-&gt;push(x); * obj-&gt;pop(); * int param_3 = obj-&gt;top(); * int param_4 = obj-&gt;getMin(); */]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>设计</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 50]]></title>
    <url>%2Fp%2Fabea.html</url>
    <content type="text"><![CDATA[50. Pow(x, n)难度: medium 实现 pow(x, n) ，即计算 x 的 n 次幂函数。 示例 1: 12输入: 2.00000, 10输出: 1024.00000 示例 2: 12输入: 2.10000, 3输出: 9.26100 示例 3: 123输入: 2.00000, -2输出: 0.25000解释: 2-2 = 1/22 = 1/4 = 0.25 说明: -100.0 &lt; x &lt; 100.0 n 是 32 位有符号整数，其数值范围是 [−231, 231 − 1] 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/powx-n著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码快速幂迭代也不难，懒得写了 注意INT_MIN这个点就行了，也就是1/pow(x,-n)是要考虑范围的 顺便，快速幂是二分查找的意思么？感觉牵强 12345678910111213class Solution &#123;public: double myPow(double x, int n) &#123; // x == 0??? // n = -2147483648 if(n == 0)return 1.0; if(n == 1)return x; double half = myPow(x, n / 2); if(n % 2 == 0)return half * half; if(n &gt; 0)return half * half * x; return half * half / x; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 236]]></title>
    <url>%2Fp%2Fa81b.html</url>
    <content type="text"><![CDATA[236. 二叉树的最近公共祖先难度: medium 给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。 百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。” 例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4] 示例 1: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1输出: 3解释: 节点 5 和节点 1 的最近公共祖先是节点 3。 示例 2: 123输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4输出: 5解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。 说明: 所有节点的值都是唯一的。 p、q 为不同节点且均存在于给定的二叉树中。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码1234567891011121314151617181920/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) &#123; if(!root || p == root || q == root) return root; TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&gt;right, p ,q); if(left &amp;&amp; right)return root; return left ? left : right; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 69]]></title>
    <url>%2Fp%2F5d2a.html</url>
    <content type="text"><![CDATA[69. x 的平方根难度: easy 实现 int sqrt(int x) 函数。 计算并返回 x 的平方根，其中 x 是非负整数。 由于返回类型是整数，结果只保留整数的部分，小数部分将被舍去。 示例 1: 12输入: 4输出: 2 示例 2: 1234输入: 8输出: 2说明: 8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/sqrtx著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码强行回顾一波… 袖珍计算器算法12345678class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; int ans = exp(0.5 * log(x)); return (long long)(ans + 1) * (ans + 1) &lt;= x ? ans + 1 : ans; &#125;&#125;; 牛顿切线1234567891011class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; double x0 = x / 2.0; while(abs(x0 - (x / x0)) &gt; 1e-7)&#123; x0 = (x0 + x / x0) / 2; &#125; return (int)x0; &#125;&#125;; 二分查找12345678910111213class Solution &#123;public: int mySqrt(int x) &#123; if(x == 0)return 0; double left = 0.0, right = x; while(right - left &gt;= 1e-7)&#123; double mid = (left + right) / 2.0; if(mid * mid &gt; x)right = mid; else left = mid; &#125; return (int)(right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>— LeetCode - 二分查找 -  数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 590]]></title>
    <url>%2Fp%2Fcb2c.html</url>
    <content type="text"><![CDATA[590. N叉树的后序遍历难度: easy 给定一个 N 叉树，返回其节点值的后序遍历。 例如，给定一个 3叉树 : 返回其后序遍历: [5,6,3,2,4,1]. 说明: 递归法很简单，你可以使用迭代法完成此题吗? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-ary-tree-postorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码12345678910111213141516171819202122232425262728293031323334353637/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; postorder(Node* root) &#123; vector&lt;int&gt; res; process(root, res); return res; &#125; void process(Node* root, vector&lt;int&gt;&amp; res)&#123; if(!root)return; for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; process(root-&gt;children[i],res); &#125; res.push_back(root-&gt;val); &#125;&#125;; 迭代(可以但没必要)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 589]]></title>
    <url>%2Fp%2F5ded.html</url>
    <content type="text"><![CDATA[589. N叉树的前序遍历难度: easy 给定一个 N 叉树，返回其节点值的前序遍历。 例如，给定一个 3叉树 : 返回其前序遍历: [1,3,5,6,2,4]。 说明: 递归法很简单，你可以使用迭代法完成此题吗? 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/n-ary-tree-preorder-traversal著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码123456789101112131415161718192021222324252627282930313233343536/*// Definition for a Node.class Node &#123;public: int val; vector&lt;Node*&gt; children; Node() &#123;&#125; Node(int _val) &#123; val = _val; &#125; Node(int _val, vector&lt;Node*&gt; _children) &#123; val = _val; children = _children; &#125;&#125;;*/class Solution &#123;public: vector&lt;int&gt; preorder(Node* root) &#123; vector&lt;int&gt; res; process(root, res); return res; &#125; void process(Node* root, vector&lt;int&gt;&amp; res)&#123; if(!root)return; res.push_back(root-&gt;val); for(int i = 0; i &lt; root-&gt;children.size(); i++)&#123; process(root-&gt;children[i],res); &#125; &#125;&#125;; 迭代(可以但没必要)]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 95]]></title>
    <url>%2Fp%2Fa82f.html</url>
    <content type="text"><![CDATA[95. 不同的二叉搜索树 II难度: medium 给定一个整数 n ，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例: 1234567891011121314151617输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]]解释:以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/unique-binary-search-trees-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码常规分治 12345678910111213141516171819202122232425262728293031323334/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: vector&lt;TreeNode*&gt; generateTrees(int n) &#123; if(n &lt; 1)return &#123;&#125;; return divide(1, n); &#125; vector&lt;TreeNode*&gt; divide(int left, int right)&#123; if(left &gt; right)return &#123;nullptr&#125;; vector&lt;TreeNode*&gt; res; for(int i = left; i &lt;= right; i++)&#123; auto leftTree = divide(left, i - 1); auto rightTree = divide(i + 1, right); for(auto leftSubTree : leftTree)&#123; for(auto rightSubTree: rightTree)&#123; TreeNode* root = new TreeNode(i); root-&gt;left = leftSubTree; root-&gt;right = rightSubTree; res.push_back(root); &#125; &#125; &#125; return res; &#125;&#125;; 强行动规不想写了，用一个二维$vector$,$vec[i][j]$记录区间i到j所有可以生成的BST的根节点。]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 1025]]></title>
    <url>%2Fp%2F98da.html</url>
    <content type="text"><![CDATA[1025. 除数博弈难度: easy 爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。 最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作： 选出任一 x，满足 0 &lt; x &lt; N 且 N % x == 0 。 用 N - x 替换黑板上的数字 N 。 如果玩家无法执行这些操作，就会输掉游戏。 只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。 示例 1： 123输入：2输出：true解释：爱丽丝选择 1，鲍勃无法进行操作。 示例 2： 123输入：3输出：false解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。 提示： 1 &lt;= N &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/divisor-game著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码常规动态规划 123456789101112131415161718192021class Solution &#123;public: bool divisorGame(int N) &#123; if(N &lt; 2)return false; vector&lt;int&gt; dp(N + 1); dp[1] = false;dp[2] = true; for(int i = 3; i &lt;= N; i++)&#123; dp[i] = false; for(int j = 1; j &lt; i; j++)&#123; if(i % j)continue; else&#123; if(!dp[i - j])&#123; dp[i] = true; break; &#125; &#125; &#125; &#125; return dp[N]; &#125;&#125;; 优化一下1-&gt;false 2-&gt;true 3-&gt;false 4-&gt;true(4,3,2-&gt;false) 猜想:奇数-&gt;false;偶数-&gt;true 证明: $dp[2k-1] = false, dp[2k] = true$ $k = 1$时，显然成立 假设$k \leq m$时，成立 则$k\leq m + 1$时，显然 $(2m+1) \% x = 0 \rightarrow x = 2n + 1$$dp[2m+ 1] = !dp[2m +1 - x] = !dp[2 * n] = false$ $dp[2m + 1] = !dp[2m + 2 - 1] = !dp[2*m + 1] = true$成立 123456class Solution &#123;public: bool divisorGame(int N) &#123; return N % 2 == 0; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 223]]></title>
    <url>%2Fp%2F3bda.html</url>
    <content type="text"><![CDATA[223. 矩形面积难度: medium 在二维平面上计算出两个由直线构成的矩形重叠后形成的总面积。 每个矩形由其左下顶点和右上顶点坐标表示，如图所示。 示例: 12输入: -3, 0, 3, 4, 0, -1, 9, 2输出: 45 说明: 假设矩形面积不会超出 int 的范围。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/rectangle-area著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码简单题… 12345678910111213141516class Solution &#123;public: int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) &#123; int overlap; if(E &gt;= C || G &lt;= A || F &gt;= D || H &lt;= B)&#123; overlap = 0; &#125;else&#123; int x1 = max(A,E); int x2 = min(C,G); int y1 = max(B,F); int y2 = min(D,H); overlap = (x2 - x1) * (y2 - y1); &#125; return (C - A) * (D - B) - overlap + (G - E) * (H - F); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>数学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 222]]></title>
    <url>%2Fp%2Ffb1b.html</url>
    <content type="text"><![CDATA[222. 完全二叉树的节点个数难度: medium 给出一个完全二叉树，求出该树的节点个数。 说明： 完全二叉树的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。 示例: 12345678输入: 1 / \ 2 3 / \ /4 5 6输出: 6 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/count-complete-tree-nodes著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码???这题有意义？ 12345678910111213141516/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; if(!root)return 0; return 1 + countNodes(root-&gt;left) + countNodes(root-&gt;right); &#125;&#125;; 二分代码1234567891011121314151617181920212223/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: int countNodes(TreeNode* root) &#123; int res = 0; int h = getHeight(root); if(h &lt; 0)return 0; if(getHeight(root-&gt;right) == h - 1)return (1 &lt;&lt; h) + countNodes(root-&gt;right); return (1 &lt;&lt; (h - 1)) + countNodes(root-&gt;left); &#125; int getHeight(TreeNode* root)&#123; return root ? 1 + getHeight(root-&gt;left) : -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
        <tag>二分查找</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 221]]></title>
    <url>%2Fp%2Ffa5b.html</url>
    <content type="text"><![CDATA[221. 最大正方形难度: medium 在一个由 0 和 1 组成的二维矩阵内，找到只包含 1 的最大正方形，并返回其面积。 示例: 12345678输入: 1 0 1 0 01 0 1 1 11 1 1 1 11 0 0 1 0输出: 4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximal-square著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC 代码1234567891011121314151617181920class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())return 0; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; dp(m * n); int res = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 0; j &lt; n; j++)&#123; if(i == 0 || j == 0) dp[i * n + j] = matrix[i][j] - '0'; else if(matrix[i][j] == '1')&#123; dp[i * n + j] = min(dp[i * n + j - 1], min(dp[(i - 1) *n + j - 1], dp[(i - 1) * n + j])) + 1; &#125; res = max(res, dp[i * n + j]); &#125; &#125; return res * res; &#125;&#125;; 优化一下好像优化的不咋样… 1234567891011121314151617181920212223class Solution &#123;public: int maximalSquare(vector&lt;vector&lt;char&gt;&gt;&amp; matrix) &#123; if(matrix.empty() || matrix[0].empty())return 0; int m = matrix.size(); int n = matrix[0].size(); vector&lt;int&gt; dp(n + 1); int res = 0, pre = 0; for(int i = 0; i &lt; m; i++)&#123; for(int j = 1; j &lt;= n; j++)&#123; int temp = dp[j]; if(matrix[i][j - 1] == '1')&#123; dp[j] = min(dp[j],min(dp[j - 1], pre)) + 1; res = max(res, dp[j]); &#125;else&#123; dp[j] = 0; &#125; pre = temp; &#125; &#125; return res * res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 572]]></title>
    <url>%2Fp%2F6aa9.html</url>
    <content type="text"><![CDATA[572. 另一个树的子树难度: easy 给定两个非空二叉树 s 和 t，检验 s 中是否包含和 t 具有相同结构和节点值的子树。s 的一个子树包括 s 的一个节点和这个节点的所有子孙。s 也可以看做它自身的一棵子树。 示例 1:给定的树 s:12345 3 / \ 4 5 / \1 2 给定的树 t：123 4 / \1 2 返回 true，因为 t 与 s 的一个子树拥有相同的结构和节点值。 示例 2:给定的树 s： 1234567 3 / \ 4 5 / \1 2 / 0 给定的树 t：123 4 / \1 2 返回 false。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/subtree-of-another-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码区分好”相同”与”真子树” 123456789101112131415161718192021222324/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isSubtree(TreeNode* s, TreeNode* t) &#123; if (!s) return false; if (isSame(s, t)) return true; else return isSubtree(s-&gt;left, t) || isSubtree(s-&gt;right, t); &#125; bool isSame(TreeNode* s, TreeNode* t)&#123; if (!s &amp;&amp; !t) return true; if (!s || !t) return false; if (s-&gt;val != t-&gt;val) return false; return isSame(s-&gt;left, t-&gt;left) &amp;&amp; isSame(s-&gt;right, t-&gt;right); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 983]]></title>
    <url>%2Fp%2F59ad.html</url>
    <content type="text"><![CDATA[983. 最低票价难度: medium 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。 火车票有三种不同的销售方式： 一张为期一天的通行证售价为 costs[0] 美元； 一张为期七天的通行证售价为 costs[1] 美元； 一张为期三十天的通行证售价为 costs[2] 美元。 通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。 返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。 示例 1： 12345678输入：days = [1,4,6,7,8,20], costs = [2,7,15]输出：11解释： 例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。你总共花了 $11，并完成了你计划的每一天旅行。 示例 2： 1234567输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]输出：17解释：例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划： 在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。 你总共花了 $17，并完成了你计划的每一天旅行。 提示： 1 &lt;= days.length &lt;= 365 1 &lt;= days[i] &lt;= 365 days 按顺序严格递增 costs.length == 3 1 &lt;= costs[i] &lt;= 1000 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/minimum-cost-for-tickets著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路动态规划 第i天需要旅行 dp[i] = dp[i - 1] dp[i] = min(dp[i - 1] + cost[0], dp[i - 7] + cost[1], dp[i-30] + cost[2]) 越界时dp[i] = 0 不能遍历到最后一天就结束，原因:“浪费时间可能省钱” AC代码1234567891011121314151617181920class Solution &#123;public: int mincostTickets(vector&lt;int&gt;&amp; days, vector&lt;int&gt;&amp; costs) &#123; //dp[i] min cost in pre i days; vector&lt;int&gt; dp(366, INT_MAX); for(int day : days)dp[day] = 0; dp[0] = 0; int last = days.back(); for(int i = 1; i &lt;= 365; i++)&#123; if(dp[i] == INT_MAX) dp[i] = dp[i - 1]; else&#123; dp[i] = dp[i - 1] + costs[0]; dp[i] = min(dp[i], costs[1] + (i &gt;= 7 ? dp[i - 7] : 0)); dp[i] = min(dp[i], costs[2] + (i &gt;= 30 ? dp[i - 30] : 0)); &#125; &#125; return dp[last]; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 98]]></title>
    <url>%2Fp%2F6dee.html</url>
    <content type="text"><![CDATA[98. 验证二叉搜索树难度: medium 给定一个二叉树，判断其是否是一个有效的二叉搜索树。 假设一个二叉搜索树具有如下特征： 节点的左子树只包含小于当前节点的数。 节点的右子树只包含大于当前节点的数。 所有左子树和右子树自身必须也是二叉搜索树。 示例 1: 12345输入: 2 / \ 1 3输出: true 示例 2: 123456789输入: 5 / \ 1 4 / \ 3 6输出: false解释: 输入为: [5,1,4,null,null,3,6]。 根节点的值为 5 ，但是其右子节点值为 4 。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/validate-binary-search-tree著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路白给题 AC代码12345678910111213141516171819202122/** * Definition for a binary tree node. * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: bool isValidBST(TreeNode* root) &#123; if(!root)return true; return isValid(root, LONG_MIN, LONG_MAX); &#125; bool isValid(TreeNode* root, long minn, long maxx)&#123; if(!root)return true; if(root-&gt;val &lt;= minn || root-&gt;val &gt;= maxx)return false; return isValid(root-&gt;left, minn, root-&gt;val) &amp;&amp; isValid(root-&gt;right, root-&gt;val, maxx); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>深度优先搜索</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 45]]></title>
    <url>%2Fp%2F382b.html</url>
    <content type="text"><![CDATA[45. 跳跃游戏 II难度: hard 给定一个非负整数数组，你最初位于数组的第一个位置。 数组中的每个元素代表你在该位置可以跳跃的最大长度。 你的目标是使用最少的跳跃次数到达数组的最后一个位置。 示例: 1234输入: [2,3,1,1,4]输出: 2解释: 跳到最后一个位置的最小跳跃数是 2。 从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。 说明: 假设你总是可以到达数组的最后一个位置。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/jump-game-ii著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处 思路记录每一步活动范围内可以到达的新的活动范围，最小是走一步，最大时走nums[i] + i 步。 AC代码123456789101112131415161718class Solution &#123;public: int jump(vector&lt;int&gt;&amp; nums) &#123; if(nums.size() &lt; 2)return 0; int n = (int)nums.size(); int cur = 0, step = 0, last = 0; while(cur &lt; n - 1)&#123; int fur = 0; for(int i = last; i &lt;= cur; i++)&#123; fur = max(fur, nums[i] + i); &#125; step++; last = cur + 1;cur = fur; if(cur &gt;= n - 1)break; &#125; return cur &gt;= n - 1 ? step : -1; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 53]]></title>
    <url>%2Fp%2Faaaa.html</url>
    <content type="text"><![CDATA[53. 最大子序和难度 easy 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为6。 进阶: 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-subarray著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 AC代码 O(n)很容易 1234567891011121314class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; int n = nums.size(); int maxSum = nums[0]; int sum = 0; for(int i = 0; i &lt; n; i++)&#123; if(sum &lt; 0)sum = nums[i]; else sum += nums[i]; maxSum = max(maxSum, sum); &#125; return maxSum; &#125;&#125;; 分治算法，并不觉得很强 左子数组max1, 右子数组max2, 从中间向左右延伸max3，求三者最大即可。 123456789101112131415161718192021222324class Solution &#123;public: int maxSubArray(vector&lt;int&gt;&amp; nums) &#123; return divide(nums, 0, (int)nums.size() - 1); &#125; int divide(vector&lt;int&gt;&amp; nums, int left, int right)&#123; if(left &gt;= right)return nums[left]; int mid = left + (right - left) / 2; int max1 = divide(nums, left, mid - 1); int max2 = divide(nums, mid + 1, right); int max3 = nums[mid], tempMax = max3; for(int i = mid - 1; i &gt;= left; i--)&#123; tempMax += nums[i]; max3 = max(max3, tempMax); &#125; tempMax = max3; for(int i = mid + 1; i &lt;= right; i++)&#123; tempMax += nums[i]; max3 = max(max3, tempMax); &#125; return max(max3, max(max1, max2)); &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>分治</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 3]]></title>
    <url>%2Fp%2Fa92b.html</url>
    <content type="text"><![CDATA[3. 无重复字符的最长子串难度: medium 给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例 1: 123输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。 示例 2: 123输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。 示例 3: 1234输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。 请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路hash记录字符的索引，size = i - left，left表示当前不重复的子串的最左元素的索引 AC代码12345678910111213class Solution &#123;public: int lengthOfLongestSubstring(string s) &#123; vector&lt;int&gt; vec(128, -1); int res = 0, left = -1; for(int i = 0; i &lt; s.size(); i++)&#123; left = max(left, vec[s[i]]); vec[s[i]] = i; res = max(res, i - left); &#125; return res; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>哈希表</tag>
        <tag>双指针</tag>
        <tag>sliding window</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 100 矩阵乘法]]></title>
    <url>%2Fp%2F3d8b.html</url>
    <content type="text"><![CDATA[Loj 100题目描述这是一道模板题。 分别给定 $n \times p$ 和 $p \times m$ 的两个矩阵 $A$ 和 $B$，求 $A\times B$。 输入格式第一行三个正整数 $n$ 、$p$ 、$m$，表示矩阵的长宽。之后的 $n$ 行，每行 $p$ 个整数，表示矩阵 $A$。之后的 $p$ 行，每行 $m$ 个整数，表示矩阵 $B$。 输出格式输出 $n$ 行，每行 $m$ 个整数，表示矩阵 $A \times B$，每个数模 $10^9 +7$ 输出。 样例样例输入123456783 4 5-2 -8 -9 8-10 0 6 -8-10 -6 6 94 -7 5 -5 910 -2 -10 5 5-3 -7 -3 8 -2-6 7 7 3 -2 样例输出123999999898 149 153 999999929 999999951999999997 999999979 999999883 74 999999921999999835 103 55 95 999999857 数据范围与提示$1 \leq n, p, m \leq 500, -10^9 \leq A_{i,j},B_{i,j} \leq 10^9$ AC代码测试数据很坑，注意long long范围，以及mod 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;iostream&gt;#include&lt;stdio.h&gt;using namespace std;const int maxn = 500;const long long mod = 1e9 + 7;int n,p,m;long long a[maxn][maxn];long long b[maxn][maxn];int main()&#123; scanf("%d %d %d",&amp;n,&amp;p,&amp;m); for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; p; j++)&#123; scanf("%lld",&amp;a[i][j]); a[i][j] = (a[i][j] + mod) % mod; &#125; &#125; for(int i = 0; i &lt; p; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; scanf("%lld",&amp;b[i][j]); b[i][j] = (b[i][j] + mod) % mod; &#125; &#125; for(int i = 0; i &lt; n; i++)&#123; for(int j = 0; j &lt; m; j++)&#123; long long res = 0ll; int k; for(k = 0; k &lt; p; k++)&#123; res = res + a[i][k] * b[k][j] % mod; res %= mod; &#125; cout&lt;&lt;res; if(j &lt; m - 1) cout&lt;&lt;" "; &#125; cout&lt;&lt;endl; &#125; return 0;&#125;/*3 4 5605484667 -184715359 -844798432 303281860154160217 251340539 503442468 -585835226-605901720 -111757647 145470433 -60142328583215279 444795017 210075636 921181746 560215639-392073611 -248331514 -984830557 766445752 -888503479811152088 -721594655 299338374 779359743 -766800655-68463587 -878021890 -370611066 502520549 -952228*/]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Template problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 21]]></title>
    <url>%2Fp%2F5b29.html</url>
    <content type="text"><![CDATA[21. 合并两个有序链表难度: easy 将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例 12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/merge-two-sorted-lists著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路低配版mergesort，很简单，不多说。 AC代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) &#123; ListNode* dummy = new ListNode(-1); ListNode* cur = dummy; while(l1 &amp;&amp; l2)&#123; if(l1-&gt;val &lt; l2-&gt;val)&#123; cur-&gt;next = l1; l1 = l1-&gt;next; &#125;else&#123; cur-&gt;next = l2; l2 = l2-&gt;next; &#125; cur = cur-&gt;next; &#125; if(l1)cur-&gt;next = l1; if(l2)cur-&gt;next = l2; return dummy-&gt;next; &#125;&#125;;]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 7 InputTest]]></title>
    <url>%2Fp%2Ff7ec.html</url>
    <content type="text"><![CDATA[题目描述输入 $3\times 10^6$ 个$[0,2^m)$中均匀随机的十进制整数，输出它们的异或和。 输入格式输入共 $3\times 10^6$ 行，每行一个整数。 输出格式输出共一行一个整数表示它们的异或和。 数据范围与提示共5组数据， 分别为 1, 3, 15, 31, 63 。 AC代码12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; long long res = 0; long long c =3 * 1000000; long long a; while(c--)&#123; cin&gt;&gt;a; res ^= a; &#125; cout&lt;&lt;res&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 6 GuessNumber]]></title>
    <url>%2Fp%2F45c0.html</url>
    <content type="text"><![CDATA[题目描述这是一个交互题的模板。 系统会随机生成 个数 ，你需要猜测出这 个数的值。暴力枚举 / 二分 / 随机猜测等方法都可以解决这个问题，但得分将依猜测次数而定。 交互方式使用 C++ 与 C++11 的选手将可以利用系统给出的交互库来进行交互。 使用其他语言的选手也不必担心，我们提供了一个友好的交互接口，你将能够轻而易举地通过标准输入 / 输出来进行交互。 不使用交互库为了更清晰地演示交互题的使用方法，我们设计了三种操作： get_num：获取需要猜测的数字数量 n 。本操作不包含参数。 guess：猜测某个数字。本操作包含 2 个参数：需要猜测的数字的序号（从 0 开始）以及猜测值。当你猜测的值小于实际值时，返回值为 -1；当你猜测的值大于实际值时，返回值为 1；当恰好猜对时，返回值为 0。 submit：提交猜测结果。本操作包含 n个参数，即 个数的猜测结果。本操作没有返回值。 当你想要进行某个操作时，请向标准输出流中写入如下格式的字符串： 1&lt;操作名称&gt; &lt;操作参数 1&gt; &lt;操作参数 2&gt; ... &lt;操作参数 n&gt; 你必须在请求后追加换行符；多余的空白字符将被自动忽略。 在收到用户程序发送的请求后，交互器会向用户程序的标准输入流中发送返回值。你只需在你的程序中使用通常的办法读入这个值，就好像是从控制台或文件中读取内容一样。交互器将在发送返回值后再附加一个换行符 \n，以便于用户程序读入。本题目的操作返回值都是数字，因此直接读入数字即可。 请注意，很多语言的输入 / 输出库都会带有缓存，请在写入操作请求后手动刷新缓存，以确保请求顺利递送。 C++ 语言可以这样刷新缓存（std::endl 会自动刷新缓存）： 12std::cout &lt;&lt; std::flush;// 或 std::cout &lt;&lt; value &lt;&lt; std::endl; 提交猜测结果后，即可结束程序。交互器退出时，如果用户程序还在运行，就会被立即终止，但不会引发超时错误。 使用交互库对于 C++ 与 C++11 选手，我们提供交互库 interaction.h，你将可以通过题目上方的「附加文件」下载到这个交互库。正式比赛时交互库也将是公开的。 当然，你可以选择不使用交互库，自己通过标准输入输出来通信。 C++ 与 C++11 的 interaction.h 将包含三个原型如下的函数： 123int get_num();int guess(int index, int x);void submit(const std::vector&lt;int&gt; &amp;resultv); 参数的意义及返回值请参见上面的描述。 附注 1 文件说明「附加文件」中的 interaction.h 为供用户调用的交互库；interactor.cpp 为交互器。 附注 2 C 与 C++ #include 说明#include 表示在标准库及默认搜索目录中寻找将要 include 的文件；#include &quot;file&quot; 表示先在当前目录中搜索文件，然后再到默认搜索目录中搜寻。 在提交交互题时，请使用 #include &quot;interaction.h&quot;。 输入格式输入文件是供交互器使用的；一般用户无需在意这里的内容，只需关心如何与交互器交互即可。 第一行一个正整数 n，表示有 n 个数，第二行 n 个正整数表示要猜的序列。 样例样例输入1251 2 3 4 5 数据范围与提示数量 $1 \leq n \leq 100$；要猜测的数字 $0 \leq A_i \leq 1000000$。 请尽量保证你的猜测次数在 $1000n$ 之内，对于每个测试点 x，设你的猜测次数为 ，则你的得分为 $\text{max}(\text{min}(100,(950-\frac{x}{n})-100))/950\times100),0)$。 每次猜测均为 I / O 操作，消耗时间较多，如果猜测次数过多将导致超时。 AC代码12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define maxn 1000000int guess(int i)&#123; int l= 0,r= maxn; int m; int flag; while (l &lt; r)&#123; m = (l + r) &gt;&gt; 1; printf("guess %d %d\n", i, m); fflush(stdout); scanf("%d", &amp;flag); switch (flag)&#123; case -1: l = m + 1; break; case 1: r = m - 1; break; case 0: return m; &#125; &#125; return l;&#125;int main()&#123; int n, a[100]; printf("get_num\n"); fflush(stdout); scanf("%d", &amp;n); for (int i = 0; i&lt; n; i++) a[i] = guess(i); printf("submit"); for (int i = 0; i&lt; n; i++) printf(" %d", a[i]); printf("\n"); fflush(stdout);&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>二分查找</tag>
        <tag>双指针</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 5 GuessDate]]></title>
    <url>%2Fp%2Fca9d.html</url>
    <content type="text"><![CDATA[题目描述给你一个提示，请猜测对应的日期。假设日期 x 用 1, 2, …, n中的一个整数表示。 在任意一个数据点输出 0 都可以得到一定的同情分。 输入格式第一行一个整数 n ，表示日期 x 的范围是 1, 2, …, n。 第二行一个字符串，为一个关于日期 x 的 Python 表达式，表示给出的提示。 输出格式对于每个测试点，请将对应答案写入 date#.usr 中，并填入网页下方提交答案处，或者以 zip 压缩包形式上传。 样例样例输入1210abs(x - 7) == 4 样例输出13 数据范围与提示本题中给出的 Python 表达式与 C++ 语义相同。表达式中 x 是一个整型变量，当 x 为正确答案时，表达式求值为 True；否则为 False。保证答案惟一。 注： Python 中 a ** b 表示计算 $a^b$。 pi 的值为 3.1415926535897932；三角函数使用弧度制。 给出的表达式可以直接在 Python 中 from math import * 后求值。 本题的测试数据中，in 文件是输出 0可得的分数百分比；out 文件是正确日期。在上传提交答案类题目时，如果 Special Judge 不需要 in/out 文件，可在 data.yml 中对应省略 inputFile/outputFile 项。 不保证 答案是一个公历日期。 AC思路date1.usr题目: 121231x * (x - 31) == 815184 - x 解方程，不bb 1918 date2.usr题目 1220021231(x ** x % 911) + (x ^ (x % 1248679)) == 20000000 我直接费马定理整一下，然后范围内暴力 1234567891011121320010911for(long long i = 18750412; i &lt;= 20021231 ;i++)&#123; long long t1 = i % 911, t2 = i % 910; long long res = 1; for(long long k = 1; k &lt;= t2; k++)&#123; res = (res * t1) % 911; &#125; long long m = i ^ (i % 1248679); if(res + m == 20000000)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125;&#125; date3.usr题目 121234567890abs(2e9 - max(abs(x - 1e9), abs(x - 2e9), abs(x - 3e9))) &lt;= 10 and abs(sin(pi * (x + 25) / 32)) &lt;= 1e-8 不超过21个数字，暴力 1234567891,000,000,007const double pi = 3.141592653589793;for(long long i = 1000000000 - 10; i &lt;= 1000000000 + 10; i++)&#123; if(abs(sin(pi * (i + 25) / 32)) &lt;= 1e-8)&#123; cout&lt;&lt;i&lt;&lt;endl; break; &#125; &#125; date4.usr题目 121463030063184x * ((x &amp; -x) + ((x - (x &amp; -x)) &amp; -(x - (x &amp; -x)))) == 1463030063184 好题,对lowbit进行枚举，代回去检验 123456789101112131415161718192021222324121919171932#define low(x) ((x) &amp; (-x)) #define n 1463030063184int m = log2(n);long long lowx, lowy, t, x, tlowx, tlowy, s;for(int i = 0; i &lt;= m; i++)&#123; for(int j = 0; j &lt;= m; j++)&#123; lowx = 2 &lt;&lt; i; lowy = 2 &lt;&lt; j; t = lowx + lowy; if(n % t)continue; x = n / t; tlowx = low(x); if(tlowx != lowx) continue; tlowy = low((x - tlowx)); if(tlowy != lowy) continue; s = x * (tlowx + tlowy); if(s == n)&#123; cout&lt;&lt;x&lt;&lt;endl; break; &#125; &#125;&#125; date5.usr题目 121not not not not not not not not x and not (((x + (x ^ 998244353) + (((((x + 123) % 456 * 789) ^ 987) - x * 654) ^ (321 * (x % 2))) - (987654321 ^ ((x * x) &gt;&gt; 1)) - (12344321 * x * x * x) - ((1234321 - x) ^ (123454321 &gt;&gt; 2) / (x - 12321) - ((x + (x * x * x) ^ (x * x)) / (x + 123))) * x + 456789 / (x + 9) + 87654 + (32 &lt;&lt; (x + 1))) &gt;&gt; 19) + 1) 秒解 11]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>数学</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 4 Quine]]></title>
    <url>%2Fp%2F9124.html</url>
    <content type="text"><![CDATA[题目描述写一个程序，使其能输出自己的源代码。 代码中必须至少包含十个可见字符。 输入格式输入文件为空。 输出格式你的源代码。 这是一个有趣的问题，Google一下 AC代码1234567#include &lt;stdio.h&gt;char *s = "#include &lt;stdio.h&gt;%c%cchar *s = %c%s%c;%c%cint main()&#123;%c%c%c%c%cprintf(s,10,10,34,s,34,10,10,10,32,32,32,32,10,10);%c&#125;%c";int main()&#123; printf(s,10,10,34,s,34,10,10,10,32,32,32,32,10,10);&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>mark</tag>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 3 Copycat]]></title>
    <url>%2Fp%2F671d.html</url>
    <content type="text"><![CDATA[题目描述这道题用于测试文件输入输出，请注意使用文件输入输出，而非标准输入输出。 输入一个正整数 $a$，输出这个数 $a$。 输入格式第一行一个 $T$ 正整数 ，表示有 $T$ 组测试数据。接下来 $T$ 行，每行一个正整数 $a$ 。 输出格式输出$T$行，每行一个正整数$a$。 样例样例输入 112343123 样例输出 1123123 样例输入 21211000000000000000000000000000000000 样例输出 211000000000000000000000000000000000 数据范围与提示对于所有测试点，$1\leq T \leq 10, 1 \leq a \leq 10^{1000}$。 子任务 1（10 分）$1\leq a \leq 3$；子任务 2（20 分）$1\leq a \leq 100000$；子任务 3（70 分）没有附加限制。 AC代码123456789101112131415#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; freopen("copycat.in","r",stdin); freopen("copycat.out","w",stdout); int T;cin&gt;&gt;T; string a; while(T--)&#123; cin&gt;&gt;a; cout&lt;&lt;a&lt;&lt;endl; &#125; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 2 Hello World]]></title>
    <url>%2Fp%2Ff77e.html</url>
    <content type="text"><![CDATA[题目描述输出 Hello, World!，大小写不限。 输入格式无输入。 输出格式一行 Hello, World!，大小写不限。 样例样例输出 11Hello, World! 样例输出 21hello, WORLD! AC代码1234567#include&lt;bits/stdc++.h&gt;using namespace std;int main()&#123; cout&lt;&lt;"hello, world!"&lt;&lt;endl; return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Loj 1 A+B]]></title>
    <url>%2Fp%2F1c57.html</url>
    <content type="text"><![CDATA[题目描述输入 $a$ 和 $b$，输出 $a$ + $b$ 的结果。 输入格式一行两个正整数 $a$ 和 $b$ 。 输出格式一行一个正整数$a$ + $b$。 样例样例输入11 2 样例输出13 数据范围与提示对于100%的数据，1$\leq a,b \leq 10^6$。 AC代码12345678#include&lt;bits/stdc++.h&gt; int main()&#123; int a,b; scanf("%d %d", &amp;a, &amp;b); printf("%d",a + b); return 0;&#125;]]></content>
      <categories>
        <category>Loj</category>
      </categories>
      <tags>
        <tag>Loj</tag>
        <tag>Test Problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Trie树]]></title>
    <url>%2Fp%2F8905.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+tp9x8tEKZEIxnoM/Qhm5vwmxP3ITEt8pZTr/SazB5beEQAPY328D8FpYo+3wmY2dOyq1Tbmb6G+a/V8xZToqrAKK/dpg+HwTtNLl0rwUYVKUfaD5SXCXZ/4248haWiMqi30go1nl79MmrmC1qccRb2fEAS8VV1bj39zRspl21xesUyee9f6MkhBAhtZ3FheCxnvar7cHKzw==]]></content>
      <categories>
        <category>-- 数据结构</category>
      </categories>
      <tags>
        <tag>-- Trie树 -- 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode 421]]></title>
    <url>%2Fp%2Ffbbb.html</url>
    <content type="text"><![CDATA[421. 数组中两个数的最大异或值给定一个非空数组，数组中元素为 $a_0, a_1, a_2, … , a_{n-1}$，其中 $0 \leq a_i &lt; 231$ 。 找到 $a_i$ 和$a_j$ 最大的异或 (XOR) 运算结果，其中$0 \leq i, j &lt; n$ 。 你能在O(n)的时间解决这个问题吗？ 示例: 12345输入: [3, 10, 5, 25, 2, 8]输出: 28解释: 最大的结果是 5 ^ 25 = 28. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 思路：贪心]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>位运算</tag>
        <tag>Trie树</tag>
        <tag>贪心</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算方法绪论概述]]></title>
    <url>%2Fp%2F926f.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>计算方法</category>
      </categories>
      <tags>
        <tag>计算方法</tag>
        <tag>概述</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python and Regex]]></title>
    <url>%2Fp%2Fa80d.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Python核心编程</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Regex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Games Creator]]></title>
    <url>%2Fp%2Fc0eb.html</url>
    <content type="text"><![CDATA[水果消消乐 微光城市]]></content>
      <categories>
        <category>Unity Games</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Unity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo的那些插件]]></title>
    <url>%2Fp%2Feeb6.html</url>
    <content type="text"><![CDATA[pdf插件 安装插件 1npm install --save hexo-pdf 可以新增一个页面用来存放pdf 1hexo new page pdf_Library 增添pdf的链接可以在source/pdf_Library中找到index.md文件，编辑该文件: 12341.外部链接&#123; % pdf http://...... % &#125;2.内部(本地)链接&#123; % pdf XXXX/XXX/.../*.pdf % &#125; maths类插件 动画人物插件 …]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo插件</tag>
        <tag>博客优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习-纯CSS创作矩形旋转loader特效]]></title>
    <url>%2Fp%2F16be.html</url>
    <content type="text"><![CDATA[文章来源地址:大佬链接效果链接 代码解读定义dom,一个包含3个span的容器:12345&lt;div class=&quot;loader&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 居中显示:1234567html, body &#123; height: 100%; display: flex; align-items: center; justify-content: center; background-color: black;&#125; 设置容器的尺寸:12345.loader &#123; width: 150px; height: 150px; position: relative;&#125; 设置矩形的边框样式:123456.loader span &#123; position: absolute; box-sizing: border-box; border: 10px solid dimgray; border-radius: 2px;&#125; 设置3个矩形的尺寸:12345678910111213141516.loader span:nth-child(1) &#123; width: 100%; height: 100%;&#125;.loader span:nth-child(2) &#123; width: 70%; height: 70%; margin: 15%;&#125;.loader span:nth-child(3) &#123; width: 40%; height: 40%; margin: 30%;&#125; 用伪元素绘制左上和右下装饰条:123456789101112131415161718.loader span::before,.loader span::after &#123; content: &apos;&apos;; position: absolute; width: 10px; height: 50%; background-color: gold;&#125;.loader span::before &#123; top: -10px; left: -10px;&#125;.loader span::after &#123; bottom: -10px; right: -10px;&#125; 定义动画效果:123456789@keyframes rotating &#123; from &#123; transform: rotateY(0deg); &#125; to &#123; transform: rotateY(360deg); &#125;&#125; 把动画应用到3个矩形上:123456789101112131415.loader span &#123; animation: rotating linear infinite;&#125;.loader span:nth-child(1) &#123; animation-duration: 4s;&#125;.loader span:nth-child(2) &#123; animation-duration: 2s;&#125;.loader span:nth-child(3) &#123; animation-duration: 1s;&#125; 最后设置3个矩形的堆叠顺序:1234567891011.loader span:nth-child(1) &#123; z-index: 3;&#125;.loader span:nth-child(2) &#123; z-index: 2;&#125;.loader span:nth-child(3) &#123; z-index: 1;&#125; 知识点梳理 @keyframes https://developer.mozilla.org/en-US/docs/Web/CSS/@keyframes]]></content>
      <categories>
        <category>CSS学习</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>CSS3</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Game is not Games]]></title>
    <url>%2Fp%2Ff024.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX19qSd55lQ+Kqsu8mq4qVdRSNXdQAhehDPk/tNXxVI3iW4X6HrOseYLsrRllcFPmnhmYgHERg6YveKod50CnjsXmyjKG8sqGocNUiWy4i/cNLIP3DQyKzo/cFChLssf4NdeSVtLBHh78wZ3+9EMVdUGC3dKljoh+VhpqmjW8+8IA6UMcpRpdrPluwxVX61ArAX9b8q0FrNSaXUvCj7v327l+4cQYNdUr2VTFm5fXCej0HHH6UCs7sNZJh2pn5KCow1KGEIcjrCEcGopYjFGaGVOk5rlYCjqXcWDH8goJ3Akedf0dgngC1FsHDLj30xCDAMWBsi4b/9h7smVvIYQ8YFoIOQfFzNNUAG8QlPmHlpNiaFWz0lbav0pQ7sUFMADWWiUTYznItdJ2QT4Sk2pncFCPNuWc9ZcuYYaiR3RSKEDjRV091FZlRp3BscivWI2hpjxVw/fC5jLvcn0aYyhKYq+rmBiLoP2h4zuQ8dxGq60DK80xRd7N7c/dROEbxWVZ4ncAX8ePnqILru/1hANszJNjB3NSWbMQN2hzYo9+wBWPB2sBeV6h+gucyH7n07o6TtYtItvOrJ9sNf/RHep/avsigQQisTzRpt80DH1sYRqEN5QEiK2kTLClSOE99IoVVoLsVCRuT9rnFZ963hYaz6TXsgSnWhgylwb9RGgyyIgH8O8xJkq01EZcwX3YKxAvQksuuH9WDDwomB2Lr4Ap7z0jeBHMucWDKCTmYl+71bDWsMjXBPqX9kpL/eKjZglKEKeu6XVYcDo4fn9G8mLn/+taZeRC1TtNpFkSZEbYnrPlGTWi4S7m62zC//OY5ZWGSZ0Sx5/sm8otxcgaM5FXcf1PqLPRFN7U1ZphfF7wobdtugoFKtywCaNw5zxBsAfnpOLNsGKREuF39A2D29sNaaPmJ5L1812x02AM44e0pK2QQ9/qct9gz8YWKOYjTWODT4Z/nZSXFPp/SxFxldNh9SB0uCspEqr5Se3FVLHdtTEg2yobzdK4PKK383Gl5rLUlU4AYzNSmdSQYFL8NhcQkwbH8Vq3llefznAauhQofHuCCgBt9X75m7hGJmmTWSjvRodDm5c9I4B6ZA==]]></content>
      <categories>
        <category>博弈论</category>
      </categories>
      <tags>
        <tag>Games</tag>
        <tag>Strategy Games</tag>
        <tag>Games Strategy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Matlab整理]]></title>
    <url>%2Fp%2Fb14c.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! 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]]></content>
      <categories>
        <category>Matlab</category>
      </categories>
      <tags>
        <tag>Matlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fp%2F3eeb.html</url>
    <content type="text"><![CDATA[Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server12$ hexo server$ hexo s More info: Server Generate static files12$ hexo generate$ hexo g More info: Generating Deploy to remote sites12$ hexo deploy$ hexo d Another way1$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d More info: Deployment]]></content>
      <categories>
        <category>Hello_World</category>
      </categories>
      <tags>
        <tag>Hello_World</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Calculus-从入门到放弃]]></title>
    <url>%2Fp%2F5ba9.html</url>
    <content type="text"><![CDATA[Please enter the password to read the blog. Incorrect Password! No content to display! U2FsdGVkX1+i2BrXn1tHoLb3sLPo6F0oVSQWESyGlblwNe3m1z6/97wz65TJ2BRFPONQ0NC6dmkMe1aLj6Gj0CrXvozT6EPPUQTU9xYTs9LBWhDGVVkIyQ5lQo1u1PDK470PHISt0F6akj64Cto4yEsXaqRl6fd+fUk2l3F10JypnLisq5ekXXyYjzqGbp36o+1iju9nXDu7WfFgLVqdcfmacx6qjEfBp4gNbudLvGZc1pfs2bKfpJEiXC1jhJKAzcpxuTTldPWKeHgZc+LDu05dKViG95JPJTIvLHceytop3LWgFEd8sXIwHXtvo1srj/BhZ3D5aLLoI7E5k5YjY4LrJPwi84LYA93W7wKX3RuaOHn2fHiheo4DNGm7kdRYGKlJ8KzLsWKUWGVb1Z8dc0ruz3HZMYj2hMp0eY+xknccu6Hqh6UMbMnt3V9rFhiKhMj2066yx3eX+scC2/ID2tnD13Is/2kMR+tAOkjdtpIABShyPY92oysC/eKWTU1tTamsPAp+C7Xpu6/eTbsSpuOvJFMaGS6X/RprJGkohv4etMVAhFPA8JCvtqxvjhzePBXdFQ+SY428k+lSkHLUlhna2GDX93K0lmNuWOCCrQ/VJAg6Z7C8Wt3op4yjCsIGCkvyo7XE0FILg/nTifLL+g==]]></content>
      <categories>
        <category>Advanced mathematics</category>
      </categories>
      <tags>
        <tag>Maths</tag>
        <tag>Calculus</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习2]]></title>
    <url>%2Fp%2Ffe97.html</url>
    <content type="text"><![CDATA[Italics and BoldTo make a phrase italic in Markdown, you can surround words with an underscore (_ ). For example, _this_(this )word would become italic. Similarly, to make phrases bold in Markdown, you can surround words with two asterisks ( ** ). This will **really**(really) get your point across. Of course, you can use _both italics and bold_ in the same line. You can also span them **across multiple words**. Finally,we’re going to make some words bold and italic.In general, it doesn’t matter which order you place the asterisks or underscores. HeadersTo make headers in Markdown, you preface the phrase with a hash mark (#). You place the same number of hash marks as the size of the header you want.For example:123456# Header one## Header two### Header three#### Header four##### Header five###### Header six 效果为 It’s up to you to decide when it’s appropriate to use which header. In general, headers one and six should be used sparingly. You can’t really make a header bold, but you can italicize certain words.(Obviously,(_)is good!) LinksThere are two different link types in Markdown, but both of them render the exact same way. The first link style is called an inline link. To create an inline link, you wrap the link text in brackets ( [ ] ), and then you wrap the link in parenthesis ( ( ) ). For example, to create a hyperlink to www.github.com, with a link text that says, Visit GitHub!, you’d write this in Markdown: [Visit GitHub!](www.github.com). You can add emphasis to link texts, if you like. Although it might make for an awkward experience, you can make links within headings, too. That’s all there is to writing inline links. The other link type is called a reference link. As the name implies, the link is actually a reference to another place in the document. Here’s an example of what we mean: 123456Here&apos;s [a link to something else][another place].Here&apos;s [yet another link][another-link].And now back to [the first link][another place].[another place]: www.github.com[another-link]: www.google.com The “references” above are the second set of brackets: [another place] and [another-link]. At the bottom of a Markdown document, these brackets are defined as proper links to outside websites. An advantage of the reference link style is that multiple links to the same place only need to be updated once. For example, if we decide to make all of the [another place] links go somewhere else, we only have to change the single reference link. Reference links don’t appear in the rendered Markdown. You define them by providing the same tag name wrapped in brackets, followed by a colon, followed by the link. ImagesIf you know how to create links in Markdown, you can create images, too. The syntax is nearly the same. Images also have two styles, just like links, and both of them render the exact same way. The difference between links and images is that images are prefaced with an exclamation point ( ! ). The first image style is called an inline image link. To create an inline image link, enter an exclamation point ( ! ), wrap the alt text in brackets ( [ ] ), and then wrap the link in parenthesis ( ( ) ). (Alt text is a phrase or sentence that describes the image for the visually impaired.) For example, to create an inline image link to the link (a bannekat picture from the github). https://octodex.github.com/images/bannekat.png, with an alt text that says, Benjamin Bannekat, you’d write this in Markdown:![Benjamin Bannekat](https://octodex.github.com/images/bannekat.png). Although you don’t need to add alt text, it will make your content accessible to your audience, including people who are visually impaired, use screen readers, or do not have high speed internet connections. For a reference image, you’ll follow the same pattern as a reference link. You’ll precede the Markdown with an exclamation point, then provide two brackets for the alt text, and then two more for the image tag. At the bottom of your Markdown page, you’ll define an image for the tag. BlockquotesIf you need to call special attention to a quote from another source, or design a pull quote for a magazine article, then Markdown’s blockquote syntax will be useful. A blockquote is a sentence or paragraph that’s been specially formatted to draw attention to the reader. For example: “The sin of doing nothing is the deadliest of all the seven sins. It has been said that for evil men to accomplish their purpose it is only necessary that good men should do nothing.” To create a block quote, all you have to do is preface a line with the “greater than” caret (&gt;). For example:1234&gt; &quot;In a few moments he was barefoot, his stockings folded in his pockets andhis canvas shoes dangling by their knotted laces over his shoulders and,picking a pointed salt-eaten stick out of the jetsam among the rocks, heclambered down the slope of the breakwater.&quot; You can also place a caret character on each line of the quote. This is particularly useful if your quote spans multiple paragraphs. Block quotes can contain other Markdown elements, such as italics, images, or links. ListsThere are two types of lists in the known universe: unordered and ordered. That’s a fancy way of saying that there are lists with bullet points, and lists with numbers. To create an unordered list, you’ll want to preface each item in the list with an asterisk ( * ). Each list item also gets its own line. For example, a grocery list in Markdown might look like this:1234* Milk* Eggs* Salmon* Butter All right! That’s how you write an unordered list. Now, let’s talk about ordered ones. An ordered list is prefaced with numbers, instead of asterisks. Take a look at this recipe: Crack three eggs over a bowl Pour a gallon of milk into the bowl Rub the salmon vigorously with butter Drop the salmon into the egg-milk bowl To write that in Markdown, you’d do this:12341. Crack three eggs over a bowl2. Pour a gallon of milk into the bowl3. Rub the salmon vigorously with butter4. Drop the salmon into the egg-milk bowl You can choose to add italics, bold, or links within lists, as you might expect. Occasionally, you might find the need to make a list with more depth, or, to nest one list within another. Have no fear, because the Markdown syntax is exactly the same. All you have to do is to remember to indent each asterisk one space more than the preceding item. For example, in the following list, we’re going to add some sub-lists to each “main” list item, describing the people in detail:123456789* Tintin * A reporter * Has poofy orange hair * Friends with the world&apos;s most awesome dog* Haddock * A sea captain * Has a fantastic beard * Loves whiskey * Possibly also scotch? When rendered, this list turns into the following grouping: Tintin A reporter Has poofy orange hair Friends with the world’s most awesome dog Haddock A sea captain Has a fantastic beard Loves whiskey Possibly also scotch? While you could continue to indent and add sub-lists indefinitely, it’s usually a good idea to stop after three levels; otherwise, your text becomes a mess. There’s one more trick to lists and indentation that we’ll explore, and that deals with the case of paragraphs. Suppose you want to create a bullet list that requires some additional context (but not another list). To create this sort of text, your paragraph must start on a line all by itself underneath the bullet point, and it must be indented by at least one space. Notice that the first two items have a single space. This looks a bit odd, so you might want to indent properly to match the characters up (like items three and four). In these paragraphs, you can include all sorts of other Markdown elements, like blockquotes, or even other lists! ParagraphsEach dot ( · ) represents a space on the keyboard.You can accomplish a soft break by inserting two spaces after each new line.]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown学习1]]></title>
    <url>%2Fp%2Fffd7.html</url>
    <content type="text"><![CDATA[列表在Markdown中只需要在文字的前面加上-即可，如下所示:123- 文本1- 文本2- 文本3 如果希望获得一个有序列表，只需修改为1. 2. 3.即可，如下所示:1231. 文本12. 文本23. 文本3 注:-、1.和文本之间需要保留一个字符的空格。 链接和图片在Markdown中，插入链接不需要其他按钮，只需要使用[显示文本](链接地址)这样即可，例如:[爸爸的博客](https://vingtdylan.github.io/)效果如下:爸爸的博客 类似的，在Markdown中，插入图片不需要其他按钮，只需要使用![](链接地址)这样即可，例如:![](https://vingtdylan.github.io)效果如下: 引用在写作的时候经常需要引用他人的文字，这时候需要添加引用格式，在Markdown中，只需添加一个&gt;即可，例如:&gt;那些年你冒险的梦注:&gt;和文本之间仍需要一个字符的空格效果如下: 那些年你冒险的梦 粗体和斜体Markdown中的粗体和斜体只需要用*或者**将文本包含起来即可，例如:**那些年**你很*冒险的梦*效果如下:那些年你很冒险的梦 代码引用当行使用(`)将语句包起来，如果引用多行语句，则用(```)包含文本即可，例如`hello world`和` ` ``#include&lt;iostream&gt;``using namespace std``int main(){}`` ` `显示效果依次为:hello world123#include&lt;iostream&gt;using namespace std;int main()&#123;&#125; 特别提示，在代码块中打出``` ````需要用4个`` ` ``包含3个`` ` ``.12### 表格 Tables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 1234567891011显示效果为:| Tables | Are | Cool || ------------- |:-------------:| -----:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 |注:表格上方必须为一个空行### 显示链接中带括号的图片 ![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20(n_{i})+11234567显示效果为:![][1][1]: http://latex.codecogs.com/gif.latex?\prod%20(n_&#123;i&#125;)+1`Hexo中显示有问题...`### 分割线另起一行，连续输入三个`*`即可 第一行内容 第二行内容`效果如下:第一行内容 第二行内容]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习-纯CSS实现按钮文字滑动特效]]></title>
    <url>%2Fp%2F2c4.html</url>
    <content type="text"><![CDATA[文章来源地址:大佬链接效果链接 代码解读定义DOM，在一个容器定义按钮的文字，每个字母都使用一个span，每个span又有一个data-text属性，具体如下:12345678&lt;div class=&quot;box&quot;&gt; &lt;span data-text=&quot;B&quot;&gt;B&lt;/span&gt; &lt;span data-text=&quot;U&quot;&gt;U&lt;/span&gt; &lt;span data-text=&quot;T&quot;&gt;T&lt;/span&gt; &lt;span data-text=&quot;T&quot;&gt;T&lt;/span&gt; &lt;span data-text=&quot;O&quot;&gt;O&lt;/span&gt; &lt;span data-text=&quot;N&quot;&gt;N&lt;/span&gt;&lt;/div&gt; 按钮居中设置:123456html, body &#123; height: 100%; display: flex; align-items: center; justify-content: center;&#125; 然后设置按钮的尺寸和文字样式:123456789.box &#123; width: 200px; height: 60px; border: 2px solid black; text-align: center; font-size: 30px; line-height: 60px; font-family: sans-serif;&#125; 需要将按钮的每个字母元素都设置为行内块元素，这只是为了方便后面单独处理动态效果:1234.box span &#123; display: inline-block; color: blue;&#125; 将字母交错显示在按钮容器之外,这里可以将第奇数个元素显示在上，第偶数个元素显示在下:1234567.box span:nth-child(odd) &#123; transform: translateY(-100%);&#125;.box span:nth-child(even) &#123; transform: translateY(100%);&#125; 用伪元素给每个字母增加一个副本12345.box span::before &#123; content: attr(data-text); position: absolute; color: red;&#125; 然后让伪元素也交错显示，位置与其原始元素相对:1234567.box span:nth-child(odd)::before &#123; transform: translateY(100%);&#125;.box span:nth-child(even)::before &#123; transform: translateY(-100%);&#125; 为增加鼠标划过样式，设置过渡时间:1234567.box:hover span &#123; transform: translateY(0);&#125;.box span &#123; transition: 0.5s;&#125; 最后一步，隐藏容器外的内容:123.box &#123; overflow: hidden;&#125; 知识点梳理flex布局&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;比较好的一个学习总结:链接跳转处 justify-content属性&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于设置或者检索弹性盒子元素在主轴(横轴)方向上的对齐方式。可以参看菜鸟教程 百分比%&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CSS中的百分比计算方法 伪元素(Pseudo-elements)-&gt;before,after&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;W3School上的讲解 translateY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;jQery之家的解释 data-*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于嵌套自定义数据,移步W3School content&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;用于插入生成内容,链接跳转 nth-child&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常见的选择器了，再好好复习一下吧,链接跳转]]></content>
      <categories>
        <category>CSS学习</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>CSS3</tag>
        <tag>web</tag>
      </tags>
  </entry>
</search>
