<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Pytorch-CV</title>
      <link href="/p/bf66.html"/>
      <url>/p/bf66.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="IoU"><a href="#IoU" class="headerlink" title="IoU"></a>IoU</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_area</span>(<span class="params">boxes</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Computes the area of a set of bounding boxes, which are specified by its</span></span><br><span class="line"><span class="string">    (x1, y1, x2, y2) coordinates.</span></span><br><span class="line"><span class="string">    Args:</span></span><br><span class="line"><span class="string">        boxes (Tensor[N, 4]): boxes for which the area will be computed. They</span></span><br><span class="line"><span class="string">            are expected to be in (x1, y1, x2, y2) format</span></span><br><span class="line"><span class="string">    Returns:</span></span><br><span class="line"><span class="string">        area (Tensor[N]): area for each box</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span> (boxes[:, <span class="number">2</span>] - boxes[:, <span class="number">0</span>]) * (boxes[:, <span class="number">3</span>] - boxes[:, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># modified from torchvision to also return the union</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">box_iou</span>(<span class="params">boxes1, boxes2</span>):</span></span><br><span class="line">    area1 = box_area(boxes1)</span><br><span class="line">    area2 = box_area(boxes2)</span><br><span class="line"></span><br><span class="line">    lt = torch.<span class="built_in">max</span>(boxes1[:, <span class="literal">None</span>, :<span class="number">2</span>], boxes2[:, :<span class="number">2</span>])  <span class="comment"># [N,M,2]</span></span><br><span class="line">    rb = torch.<span class="built_in">min</span>(boxes1[:, <span class="literal">None</span>, <span class="number">2</span>:], boxes2[:, <span class="number">2</span>:])  <span class="comment"># [N,M,2]</span></span><br><span class="line"></span><br><span class="line">    wh = (rb - lt).clamp(<span class="built_in">min</span>=<span class="number">0</span>)  <span class="comment"># [N,M,2]</span></span><br><span class="line">    inter = wh[:, :, <span class="number">0</span>] * wh[:, :, <span class="number">1</span>]  <span class="comment"># [N,M]</span></span><br><span class="line"></span><br><span class="line">    union = area1[:, <span class="literal">None</span>] + area2 - inter</span><br><span class="line"></span><br><span class="line">    iou = inter / union</span><br><span class="line">    <span class="keyword">return</span> iou, union</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用函数 </tag>
            
            <tag> CV </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CPP-Interview</title>
      <link href="/p/bed2.html"/>
      <url>/p/bed2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><del>八股文记不住</del></p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Review.md</title>
      <link href="/p/4427.html"/>
      <url>/p/4427.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://mp.weixin.qq.com/s/P2oEWTlCGmAdrJib4GZLUQ">最全综述 | 图像目标检测 (qq.com)</a></p><p>目标检测算法取得了很大的突破。比较流行的算法可以分为两类，一类是基于Region Proposal的R-CNN系算法（R-CNN，Fast R-CNN, Faster R-CNN等），它们是two-stage的，需要先算法产生目标候选框，也就是目标位置，然后再对候选框做分类与回归。而另一类是Yolo，SSD这类one-stage算法，其仅仅使用一个卷积神经网络CNN直接预测不同目标的类别与位置。第一类方法是准确度高一些，但是速度慢，但是第二类算法是速度快，但是准确性要低一些。这可以在下图中看到。<img src="/p/4427/objectdetectionreview2.jpg" alt="图片"></p><h2 id="R-CNN"><a href="#R-CNN" class="headerlink" title="R-CNN"></a>R-CNN</h2><h2 id="Fast-R-CNN"><a href="#Fast-R-CNN" class="headerlink" title="Fast R-CNN"></a>Fast R-CNN</h2><h2 id="Faster-R-CNN"><a href="#Faster-R-CNN" class="headerlink" title="Faster R-CNN"></a>Faster R-CNN</h2><h2 id="Mask-R-CNN"><a href="#Mask-R-CNN" class="headerlink" title="Mask R-CNN"></a>Mask R-CNN</h2>]]></content>
      
      
      <categories>
          
          <category> Object Detection </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Object Detection </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习500问-ch2</title>
      <link href="/p/16a6.html"/>
      <url>/p/16a6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="机器学习基础"><a href="#机器学习基础" class="headerlink" title="机器学习基础"></a>机器学习基础</h2><p>机器学习的基本概念、监督学习、分类算法、逻辑回归、代价函数、损失函数、LDA、PCA、决策树、支持向量机、EM算法、聚类和降维以及模型评估有哪些方法、指标等等。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="大话理解机器学习本质"><a href="#大话理解机器学习本质" class="headerlink" title="大话理解机器学习本质"></a>大话理解机器学习本质</h3><p>对于一个任务及其表现的度量方法，设计一种算法，让算法能够提取中数据所蕴含的规律，这就叫机器学习。</p><ul><li>输入机器的数据是带有标签的，就称作有监督学习。</li><li>如果数据是无标签的，就是无监督学习。</li></ul><h3 id="什么是神经网络"><a href="#什么是神经网络" class="headerlink" title="什么是神经网络"></a>什么是神经网络</h3><p>神经网络就是按照一定规则将多个神经元连接起来的网络。不同的神经网络，具有不同的连接规则。例如全连接(Full Connected, FC)神经网络，它的规则包括：</p><p>（1）有三种层：输入层，输出层，隐藏层。</p><p>（2）同一层的神经元之间没有连接。</p><p>（3）fully connected的含义：第 N 层的每个神经元和第 N-1 层的所有神经元相连，第 N-1 层神经元的输出就是第 N 层神经元的输入。</p><p>（4）每个连接都有一个权值。</p><h3 id="各种常见算法图示"><a href="#各种常见算法图示" class="headerlink" title="各种常见算法图示"></a>各种常见算法图示</h3><div class="table-container"><table><thead><tr><th style="text-align:center">回归算法</th><th style="text-align:center">聚类算法</th><th style="text-align:center">正则化方法</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/p/16a6/2.1/1.jpg" alt></td><td style="text-align:center"><img src="/p/16a6/2.1/2.jpg" alt></td><td style="text-align:center"><img src="/p/16a6/2.1/3.jpg" alt></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">决策树学习</th><th style="text-align:center">贝叶斯方法</th><th style="text-align:center">基于核的算法</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/p/16a6/2.2.4.png" alt></td><td style="text-align:center"><img src="/p/16a6/2.1/5.jpg" alt></td><td style="text-align:center"><img src="/p/16a6/2.1/6.jpg" alt></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">聚类算法</th><th style="text-align:center">关联规则学习</th><th style="text-align:center">人工神经网络</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/p/16a6/2.1/7.jpg" alt></td><td style="text-align:center"><img src="/p/16a6/2.2.8.png" alt></td><td style="text-align:center"><img src="/p/16a6/2.2.09.png" alt></td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">深度学习</th><th style="text-align:center">降低维度算法</th><th style="text-align:center">集成算法</th></tr></thead><tbody><tr><td style="text-align:center"><img src="/p/16a6/2.2.10.png" alt></td><td style="text-align:center"><img src="/p/16a6/2.2.11.png" alt></td><td style="text-align:center"><img src="/p/16a6/2.2.12.png" alt></td></tr></tbody></table></div><h3 id="计算图的导数计算"><a href="#计算图的导数计算" class="headerlink" title="计算图的导数计算?"></a>计算图的导数计算?</h3><p>计算图导数计算是反向传播，利用链式法则和隐式函数求导。</p><p>假设 $z = f(u,v)$ 在点 $(u,v)$ 处偏导连续，$(u,v)$是关于 $t$ 的函数，在 $t$ 点可导，求 $z$ 在 $t$ 点的导数。</p><p>根据链式法则有</p><script type="math/tex; mode=display">\frac{dz}{dt}=\frac{\partial z}{\partial u}.\frac{du}{dt}+\frac{\partial z}{\partial v}                .\frac{dv}{dt}</script><h3 id="理解局部最优与全局最优"><a href="#理解局部最优与全局最优" class="headerlink" title="理解局部最优与全局最优"></a>理解局部最优与全局最优</h3><p>优化问题一般分为局部最优和全局最优。其中，</p><p>（1）局部最优，就是在函数值空间的一个有限区域内寻找最小值；而全局最优，是在函数值空间整个区域寻找最小值问题。</p><p>（2）函数局部最小点是它的函数值小于或等于附近点的点，但是有可能大于较远距离的点。</p><p>（3）全局最小点是那种它的函数值小于或等于所有的可行点。</p><h3 id="大数据与深度学习之间的关系"><a href="#大数据与深度学习之间的关系" class="headerlink" title="大数据与深度学习之间的关系"></a>大数据与深度学习之间的关系</h3><p><strong>大数据</strong>通常被定义为“超出常用软件工具捕获，管理和处理能力”的数据集。<br><strong>机器学习</strong>关心的问题是如何构建计算机程序使用经验自动改进。<br><strong>数据挖掘</strong>是从数据中提取模式的特定算法的应用，在数据挖掘中，重点在于算法的应用，而不是算法本身。</p><p><strong>机器学习和数据挖掘</strong>之间的关系如下：<br>数据挖掘是一个过程，在此过程中机器学习算法被用作提取数据集中的潜在有价值模式的工具。<br>大数据与深度学习关系总结如下：</p><p>（1）深度学习是一种模拟大脑的行为。可以从所学习对象的机制以及行为等等很多相关联的方面进行学习，模仿类型行为以及思维。</p><p>（2）深度学习对于大数据的发展有帮助。深度学习对于大数据技术开发的每一个阶段均有帮助，不管是数据的分析还是挖掘还是建模，只有深度学习，这些工作才会有可能一一得到实现。</p><p>（3）深度学习转变了解决问题的思维。很多时候发现问题到解决问题，走一步看一步不是一个主要的解决问题的方式了，在深度学习的基础上，要求我们从开始到最后都要基于一个目标，为了需要优化的那个最终目标去进行处理数据以及将数据放入到数据应用平台上去，这就是端到端（End to End）。</p><p>（4）大数据的深度学习需要一个框架。在大数据方面的深度学习都是从基础的角度出发的，深度学习需要一个框架或者一个系统。总而言之，将你的大数据通过深度分析变为现实，这就是深度学习和大数据的最直接关系。</p><h2 id="机器学习学习方式"><a href="#机器学习学习方式" class="headerlink" title="机器学习学习方式"></a>机器学习学习方式</h2><h3 id="监督学习"><a href="#监督学习" class="headerlink" title="监督学习"></a>监督学习</h3><p>特点：监督学习是使用已知正确答案的示例来训练网络。已知数据和其一一对应的标签，训练一个预测模型，将输入数据映射到标签的过程。<br>常见应用场景：监督式学习的常见应用场景如分类问题和回归问题。<br>算法举例：常见的有监督机器学习算法包括支持向量机(Support Vector Machine, SVM)，朴素贝叶斯(Naive Bayes)，逻辑回归(Logistic Regression)，K近邻(K-Nearest Neighborhood, KNN)，决策树(Decision Tree)，随机森林(Random Forest)，AdaBoost以及线性判别分析(Linear Discriminant Analysis, LDA)等。深度学习(Deep Learning)也是大多数以监督学习的方式呈现。</p><h3 id="非监督式学习"><a href="#非监督式学习" class="headerlink" title="非监督式学习"></a>非监督式学习</h3><p>定义：在非监督式学习中，数据并不被特别标识，适用于你具有数据集但无标签的情况。学习模型是为了推断出数据的一些内在结构。<br>常见应用场景：常见的应用场景包括关联规则的学习以及聚类等。<br>算法举例：常见算法包括Apriori算法以及k-Means算法。</p><h3 id="半监督式学习"><a href="#半监督式学习" class="headerlink" title="半监督式学习"></a>半监督式学习</h3><p>特点：在此学习方式下，输入数据部分被标记，部分没有被标记，这种学习模型可以用来进行预测。<br>常见应用场景：应用场景包括分类和回归，算法包括一些对常用监督式学习算法的延伸，通过对已标记数据建模，在此基础上，对未标记数据进行预测。<br>算法举例：常见算法如图论推理算法（Graph Inference）或者拉普拉斯支持向量机（Laplacian SVM）等。</p><h3 id="弱监督学习"><a href="#弱监督学习" class="headerlink" title="弱监督学习"></a>弱监督学习</h3><p>特点：弱监督学习可以看做是有多个标记的数据集合，次集合可以是空集，单个元素，或包含多种情况（没有标记，有一个标记，和有多个标记）的多个元素。 数据集的标签是不可靠的，这里的不可靠可以是标记不正确，多种标记，标记不充分，局部标记等。已知数据和其一一对应的弱标签，训练一个智能算法，将输入数据映射到一组更强的标签的过程。标签的强弱指的是标签蕴含的信息量的多少，比如相对于分割的标签来说，分类的标签就是弱标签。<br>算法举例：举例，给出一张包含气球的图片，需要得出气球在图片中的位置及气球和背景的分割线，这就是已知弱标签学习强标签的问题。<br>在企业数据应用的场景下， 人们最常用的可能就是监督式学习和非监督式学习的模型。 在图像识别等领域，由于存在大量的非标识的数据和少量的可标识数据， 目前半监督式学习是一个很热的话题。</p><h3 id="监督学习有哪些步骤"><a href="#监督学习有哪些步骤" class="headerlink" title="监督学习有哪些步骤"></a>监督学习有哪些步骤</h3><p>监督学习是使用已知正确答案的示例来训练网络，每组训练数据有一个明确的标识或结果。</p><p><strong>步骤1：数据集的创建和分类</strong></p><p><strong>步骤2：数据增强（Data Augmentation）</strong></p><p><strong>步骤3：特征工程（Feature Engineering）</strong><br>一般来讲，特征工程包含特征提取和特征选择。常见的手工特征(Hand-Crafted Feature)有尺度不变特征变换(Scale-Invariant Feature Transform, SIFT)，方向梯度直方图(Histogram of Oriented Gradient, HOG)等。</p><p>由于手工特征是启发式的，其算法设计背后的出发点不同，将这些特征组合在一起的时候有可能会产生冲突，如何将组合特征的效能发挥出来，使原始数据在特征空间中的判别性最大化，就需要用到特征选择的方法。</p><p>在深度学习方法大获成功之后，人们很大一部分不再关注特征工程本身。因为，最常用到的卷积神经网络(Convolutional Neural Networks, CNNs)本身就是一种特征提取和选择的引擎。<strong>研究者提出的不同的网络结构、正则化、归一化方法实际上就是深度学习背景下的特征工程。</strong></p><p><strong>步骤4：构建预测模型和损失</strong><br>将原始数据映射到特征空间之后，也就意味着我们得到了比较合理的输入。下一步就是构建合适的预测模型得到对应输入的输出。而如何保证模型的输出和输入标签的一致性，就需要构建模型预测和标签之间的损失函数，常见的损失函数(Loss Function)有交叉熵、均方差等。通过优化方法不断迭代，使模型从最初的初始化状态一步步变化为有预测能力的模型的过程，实际上就是学习的过程。</p><p><strong>步骤5：训练</strong><br>选择合适的模型和超参数进行初始化，其中超参数比如支持向量机中核函数、误差项惩罚权重等。当模型初始化参数设定好后，将制作好的特征数据输入到模型，通过合适的优化方法不断缩小输出与标签之间的差距，当迭代过程到了截止条件，就可以得到训练好的模型。<strong>优化方法最常见的就是梯度下降法及其变种，使用梯度下降法的前提是优化目标函数对于模型是可导的。</strong></p><p><strong>步骤6：验证和模型选择</strong><br>训练完训练集图片后，需要进行模型测试。利用验证集来验证模型是否可以准确地挑选出含有气球在内的照片。<br>在此过程中，通常会通过调整和模型相关的各种事物（超参数）来重复步骤2和3，诸如里面有多少个节点，有多少层，使用怎样的激活函数和损失函数，如何在反向传播阶段积极有效地训练权值等等。</p><p><strong>步骤7：测试及应用</strong><br>当有了一个准确的模型，就可以将该模型部署到你的应用程序中。你可以将预测功能发布为API（Application Programming Interface, 应用程序编程接口）调用，并且你可以从软件中调用该API，从而进行推理并给出相应的结果。</p><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><p>分类模型是认为模型的输出是离散的，例如大自然的生物被划分为不同的种类，是离散的。</p><p>回归模型的输出是连续的，例如人的身高变化过程是一个连续过程，而不是离散的。</p><h3 id="常用分类算法的优缺点？"><a href="#常用分类算法的优缺点？" class="headerlink" title="常用分类算法的优缺点？"></a>常用分类算法的优缺点？</h3><p>常用分类算法的优缺点。</p><div class="table-container"><table><thead><tr><th style="text-align:left">算法</th><th style="text-align:left">优点</th><th style="text-align:left">缺点</th></tr></thead><tbody><tr><td style="text-align:left">Bayes 贝叶斯分类法</td><td style="text-align:left">1）所需估计的参数少，对于缺失数据不敏感。<br>2）有着坚实的数学基础，以及稳定的分类效率。</td><td style="text-align:left">1）需要假设属性之间相互独立，这往往并不成立。（喜欢吃番茄、鸡蛋，却不喜欢吃番茄炒蛋）。<br>2）需要知道先验概率。<br>3）分类决策存在错误率。</td></tr><tr><td style="text-align:left">Decision Tree决策树</td><td style="text-align:left">1）不需要任何领域知识或参数假设。<br>2）适合高维数据。<br>3）简单易于理解。<br>4）短时间内处理大量数据，得到可行且效果较好的结果。<br>5）能够同时处理数据型和常规性属性。</td><td style="text-align:left">1）对于各类别样本数量不一致数据，信息增益偏向于那些具有更多数值的特征。<br>2）易于过拟合。<br>3）忽略属性之间的相关性。<br>4）不支持在线学习。</td></tr><tr><td style="text-align:left">SVM支持向量机</td><td style="text-align:left">1）可以解决小样本下机器学习的问题。<br>2）提高泛化性能。<br>3）可以解决高维、非线性问题。超高维文本分类仍受欢迎。<br>4）避免神经网络结构选择和局部极小的问题。</td><td style="text-align:left">1）对缺失数据敏感。<br>2）内存消耗大，难以解释。<br>3）运行和调参略烦人。</td></tr><tr><td style="text-align:left">KNN K近邻</td><td style="text-align:left">1）思想简单，理论成熟，既可以用来做分类也可以用来做回归； <br>2）可用于非线性分类；<br> 3）训练时间复杂度为O(n)； <br>4）准确度高，对数据没有假设，对outlier不敏感；</td><td style="text-align:left">1）计算量太大。<br>2）对于样本分类不均衡的问题，会产生误判。<br>3）需要大量的内存。<br>4）输出的可解释性不强。</td></tr><tr><td style="text-align:left">Logistic Regression逻辑回归</td><td style="text-align:left">1）速度快。<br>2）简单易于理解，直接看到各个特征的权重。<br>3）能容易地更新模型吸收新的数据。<br>4）如果想要一个概率框架，动态调整分类阀值。</td><td style="text-align:left">特征处理复杂。需要归一化和较多的特征工程。</td></tr><tr><td style="text-align:left">Neural Network 神经网络</td><td style="text-align:left">1）分类准确率高。<br>2）并行处理能力强。<br>3）分布式存储和学习能力强。<br>4）鲁棒性较强，不易受噪声影响。</td><td style="text-align:left">1）需要大量参数（网络拓扑、阀值、阈值）。<br>2）结果难以解释。<br>3）训练时间过长。</td></tr><tr><td style="text-align:left">Adaboosting</td><td style="text-align:left">1）adaboost是一种有很高精度的分类器。<br>2）可以使用各种方法构建子分类器，Adaboost算法提供的是框架。<br>3）当使用简单分类器时，计算出的结果是可以理解的。而且弱分类器构造极其简单。<br>4）简单，不用做特征筛选。<br>5）不用担心overfitting。</td><td style="text-align:left">对outlier比较敏感</td></tr></tbody></table></div><h3 id="分类算法的评估方法"><a href="#分类算法的评估方法" class="headerlink" title="分类算法的评估方法"></a>分类算法的评估方法</h3><ul><li><p><strong>几个常用术语</strong><br>现在假设分类目标只有两类，计为正例（positive）和负例（negative）分别是：</p><ul><li>True positives(TP):  被正确地划分为正例的个数，即实际为正例且被分类器划分为正例的实例数；</li><li>False positives(FP): 被错误地划分为正例的个数，即实际为负例但被分类器划分为正例的实例数；</li><li>False negatives(FN):被错误地划分为负例的个数，即实际为正例但被分类器划分为负例的实例数；</li><li><p>True negatives(TN): 被正确地划分为负例的个数，即实际为负例且被分类器划分为负例的实例数。</p><p>四个术语的混淆矩阵</p></li></ul></li></ul><p><img src="/p/16a6/2.9/1.png" alt></p><ul><li><p><strong>评价指标</strong></p><ul><li><p>正确率（accuracy）</p><p>正确率是我们最常见的评价指标，accuracy = (TP+TN)/(P+N)，正确率是被分对的样本数在所有样本数中的占比，通常来说，正确率越高，分类器越好。</p></li><li><p>错误率（error rate)</p><p>错误率则与正确率相反，描述被分类器错分的比例，error rate = (FP+FN)/(P+N)，对某一个实例来说，分对与分错是互斥事件，所以accuracy =1 -  error rate。</p></li><li><p>灵敏度（sensitivity）<br>sensitivity = TP/P，表示的是所有正例中被分对的比例，衡量了分类器对正例的识别能力。</p></li><li><p>特异性（specificity)</p><p>specificity = TN/N，表示的是所有负例中被分对的比例，衡量了分类器对负例的识别能力。</p></li><li><p><strong>精度（precision）</strong></p><p>precision=TP/(TP+FP)，精度是精确性的度量，表示被分为正例的示例中实际为正例的比例。</p></li><li><p><strong>召回率（recall）</strong></p><p>召回率是覆盖面的度量，度量有多个正例被分为正例，recall=TP/(TP+FN)=TP/P=sensitivity，可以看到召回率与灵敏度是一样的。</p></li></ul></li></ul><ul><li><p>其他评价指标</p><ul><li>计算速度：分类器训练和预测需要的时间；</li><li>鲁棒性：处理缺失值和异常值的能力；</li><li>可扩展性：处理大数据集的能力；</li><li><p>可解释性：分类器的预测标准的可理解性，像决策树产生的规则就是很容易理解的，而神经网络的一堆参数就不好理解，我们只好把它看成一个黑盒子。</p></li><li><p>精度和召回率反映了分类器分类性能的两个方面。如果综合考虑查准率与查全率，可以得到新的评价指标<strong>F1-score，也称为综合分类率：$F1=\frac{2 \times precision \times recall}{precision + recall}$。</strong></p></li></ul><p>为了综合多个类别的分类情况，评测系统整体性能，经常采用的还有微平均F1（micro-averaging）和宏平均F1（macro-averaging ）两种指标。</p><p>（1）宏平均F1与微平均F1是以两种不同的平均方式求的全局F1指标。</p><p>（2）宏平均F1的计算方法先对每个类别单独计算F1值，再取这些F1值的算术平均值作为全局指标。</p><p>（3）微平均F1的计算方法是先累加计算各个类别的a、b、c、d的值，再由这些值求出F1值。</p><p>（4）由两种平均F1的计算方式不难看出，宏平均F1平等对待每一个类别，所以它的值主要受到稀有类别的影响，而微平均F1平等考虑文档集中的每一个文档，所以它的值受到常见类别的影响比较大。</p></li></ul><ul><li><p><strong>ROC曲线和PR曲线</strong></p><p>  <a href="https://zhuanlan.zhihu.com/p/104917232">知乎链接</a></p><p>  ROC曲线是（Receiver Operating Characteristic Curve，受试者工作特征曲线）的简称，是以灵敏度（真阳性率）为纵坐标，以1减去特异性（假阳性率）为横坐标绘制的性能评价曲线。</p><p>  可以将不同模型对同一数据集的ROC曲线绘制在同一笛卡尔坐标系中，ROC曲线越靠近左上角，说明其对应模型越可靠。也可以通过ROC曲线下面的面积（Area Under Curve, AUC）来评价模型，AUC越大，模型越可靠。</p></li></ul><p><img src="/p/16a6/2.7.3.png" alt></p><p>PR曲线是Precision Recall Curve的简称，描述的是precision和recall之间的关系，以recall为横坐标，precision为纵坐标绘制的曲线。该曲线的所对应的面积AUC实际上是目标检测中常用的评价指标平均精度（Average Precision, AP）。AP越高，说明模型性能越好。</p><h3 id="正确率能很好的评估分类算法吗"><a href="#正确率能很好的评估分类算法吗" class="headerlink" title="正确率能很好的评估分类算法吗"></a>正确率能很好的评估分类算法吗</h3><h3 id="什么样的分类器是最好的"><a href="#什么样的分类器是最好的" class="headerlink" title="什么样的分类器是最好的"></a>什么样的分类器是最好的</h3><p>对某一个任务，某个具体的分类器不可能同时满足或提高所有上面介绍的指标。<br>如果一个分类器能正确分对所有的实例，那么各项指标都已经达到最优，但这样的分类器往往不存在。比如之前说的地震预测，既然不能百分百预测地震的发生，但实际情况中能容忍一定程度的误报。假设在1000次预测中，共有5次预测发生了地震，真实情况中有一次发生了地震，其他4次则为误报。正确率由原来的999/1000=99.9下降为996/1000=99.6。召回率由0/1=0%上升为1/1=100%。对此解释为，虽然预测失误了4次，但真的地震发生前，分类器能预测对，没有错过，这样的分类器实际意义更为重大，正是我们想要的。在这种情况下，在一定正确率前提下，要求分类器的召回率尽量高。</p><h2 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h2><h3 id="回归划分"><a href="#回归划分" class="headerlink" title="回归划分"></a>回归划分</h3><p>广义线性模型家族里，依据因变量不同，可以有如下划分：</p><p>（1）如果是连续的，就是多重线性回归。</p><p>（2）如果是二项分布，就是逻辑回归。</p><p>（3）如果是泊松（Poisson）分布，就是泊松回归。</p><p>（4）如果是负二项分布，就是负二项回归。</p><p>（5）逻辑回归的因变量可以是二分类的，也可以是多分类的，但是二分类的更为常用，也更加容易解释。所以实际中最常用的就是二分类的逻辑回归。</p><h3 id="逻辑回归适用性"><a href="#逻辑回归适用性" class="headerlink" title="逻辑回归适用性"></a>逻辑回归适用性</h3><p>逻辑回归可用于以下几个方面：</p><p>（1）用于概率预测。用于可能性预测时，得到的结果有可比性。比如根据模型进而预测在不同的自变量情况下，发生某病或某种情况的概率有多大。</p><p>（2）用于分类。实际上跟预测有些类似，也是根据模型，判断某人属于某病或属于某种情况的概率有多大，也就是看一下这个人有多大的可能性是属于某病。进行分类时，仅需要设定一个阈值即可，可能性高于阈值是一类，低于阈值是另一类。</p><p>（3）寻找危险因素。寻找某一疾病的危险因素等。</p><p>（4）仅能用于线性问题。只有当目标和特征是线性关系时，才能用逻辑回归。在应用逻辑回归时注意两点：一是当知道模型是非线性时，不适用逻辑回归；二是当使用逻辑回归时，应注意选择和目标为线性关系的特征。</p><p>（5）各特征之间不需要满足条件独立假设，但各个特征的贡献独立计算。</p><h3 id="生成模型和判别模型的区别"><a href="#生成模型和判别模型的区别" class="headerlink" title="生成模型和判别模型的区别"></a>生成模型和判别模型的区别</h3><p>生成模型：由数据学习联合概率密度分布P(X,Y)，然后求出条件概率分布P(Y|X)作为预测的模型，即生成模型：P(Y|X)= P(X,Y)/ P(X)（贝叶斯概率）。基本思想是首先建立样本的联合概率概率密度模型P(X,Y)，然后再得到后验概率P(Y|X)，再利用它进行分类。典型的生成模型有朴素贝叶斯，隐马尔科夫模型等</p><p>判别模型：由数据直接学习决策函数Y=f(X)或者条件概率分布P(Y|X)作为预测的模型，即判别模型。基本思想是有限样本条件下建立判别函数，不考虑样本的产生模型，直接研究预测模型。典型的判别模型包括k近邻，感知机，决策树，支持向量机等。这些模型的特点都是输入属性X可以直接得到后验概率P(Y|X)，输出条件概率最大的作为最终的类别（对于二分类任务来说，实际得到一个score，当score大于threshold时则为正类，否则为负类）。</p><p>举例：</p><ul><li>判别式模型举例：要确定一个羊是山羊还是绵羊，用判别模型的方法是从历史数据中学习到模型，然后通过提取这只羊的特征来预测出这只羊是山羊的概率，是绵羊的概率。</li><li>生成式模型举例：利用生成模型是根据山羊的特征首先学习出一个山羊的模型，然后根据绵羊的特征学习出一个绵羊的模型，然后从这只羊中提取特征，放到山羊模型中看概率是多少，在放到绵羊模型中看概率是多少，哪个大就是哪个。</li></ul><p>联系和区别：</p><ul><li>生成方法的特点：上面说到，生成方法学习联合概率密度分布P(X,Y)，所以就可以从统计的角度表示数据的分布情况，能够反映同类数据本身的相似度。但它不关心到底划分各类的那个分类边界在哪。生成方法可以还原出联合概率分布P(Y,X)，而判别方法不能。生成方法的学习收敛速度更快，即当样本容量增加的时候，学到的模型可以更快的收敛于真实模型，当存在隐变量时，仍可以用生成方法学习。此时判别方法就不能用。</li><li>判别方法的特点：判别方法直接学习的是决策函数Y=f(X)或者条件概率分布P(Y|X)。不能反映训练数据本身的特性。但它寻找不同类别之间的最优分类面，反映的是异类数据之间的差异。直接面对预测，往往学习的准确率更高。由于直接学习P(Y|X)或P(X)，可以对数据进行各种程度上的抽象、定义特征并使用特征，因此可以简化学习问题。</li><li>最后，由生成模型可以得到判别模型，但由判别模型得不到生成模型。</li></ul><h3 id="逻辑回归与朴素贝叶斯有什么区别"><a href="#逻辑回归与朴素贝叶斯有什么区别" class="headerlink" title="逻辑回归与朴素贝叶斯有什么区别"></a>逻辑回归与朴素贝叶斯有什么区别</h3><p>逻辑回归与朴素贝叶斯区别有以下几个方面：</p><p>（1）逻辑回归是判别模型， 朴素贝叶斯是生成模型，所以生成和判别的所有区别它们都有。</p><p>（2）朴素贝叶斯属于贝叶斯，逻辑回归是最大似然，两种概率哲学间的区别。</p><p>（3）朴素贝叶斯需要条件独立假设。</p><p>（4）逻辑回归需要求特征参数间是线性的。</p><h3 id="线性回归与逻辑回归的区别"><a href="#线性回归与逻辑回归的区别" class="headerlink" title="线性回归与逻辑回归的区别"></a>线性回归与逻辑回归的区别</h3><p>线性回归与逻辑回归的区别如下描述：</p><p>（1）线性回归的样本的输出，都是连续值，$ y\in (-\infty ,+\infty )$，而逻辑回归中 $y\in (0,1)$，只能取0和1。</p><p>（2）对于拟合函数也有本质上的差别： </p><ul><li>线性回归：$f(x)=\theta ^{T}x=\theta _{1}x _{1}+\theta _{2}x _{2}+…+\theta _{n}x _{n}$</li><li>逻辑回归：$f(x)=P(y=1|x;\theta )=g(\theta ^{T}x)$，其中，$g(z)=\frac{1}{1+e^{-z}}$</li></ul><p>可以看出，线性回归的拟合函数，是对f(x)的输出变量y的拟合，而逻辑回归的拟合函数是对为1类样本的概率的拟合。<br>那么，为什么要以1类样本的概率进行拟合呢，为什么可以这样拟合呢？<br>$\theta ^{T}x=0$就相当于是1类和0类的决策边界：<br>当$\theta ^{T}x&gt;0$，则y&gt;0.5；若$\theta ^{T}x\rightarrow +\infty $，则$y \rightarrow  1 $，即y为1类; </p><p>当$\theta ^{T}x&lt;0$，则y&lt;0.5；若$\theta ^{T}x\rightarrow -\infty $，则$y \rightarrow  0 $，即y为0类; </p><p>这个时候就能看出区别，在线性回归中$\theta ^{T}x$为预测值的拟合函数；而在逻辑回归中$\theta ^{T}x$为决策边界。下表2-3为线性回归和逻辑回归的区别。</p><p>表2-3 线性回归和逻辑回归的区别</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">线性回归</th><th style="text-align:center">逻辑回归</th></tr></thead><tbody><tr><td style="text-align:center">目的</td><td style="text-align:center">预测</td><td style="text-align:center">分类</td></tr><tr><td style="text-align:center">$y^{(i)}$</td><td style="text-align:center">未知</td><td style="text-align:center">（0,1）</td></tr><tr><td style="text-align:center">函数</td><td style="text-align:center">拟合函数</td><td style="text-align:center">预测函数</td></tr><tr><td style="text-align:center">参数计算方式</td><td style="text-align:center">最小二乘法</td><td style="text-align:center">极大似然估计</td></tr></tbody></table></div><p>下面具体解释一下： </p><ol><li>拟合函数和预测函数什么关系呢？简单来说就是将拟合函数做了一个逻辑函数的转换，转换后使得$y^{(i)} \in (0,1)$;</li><li>最小二乘和最大似然估计可以相互替代吗？回答当然是不行了。我们来看看两者依仗的原理：最大似然估计是计算使得数据出现的可能性最大的参数，依仗的自然是Probability。而最小二乘是计算误差损失。</li></ol><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><h3 id="为什么需要代价函数"><a href="#为什么需要代价函数" class="headerlink" title="为什么需要代价函数"></a>为什么需要代价函数</h3><ol><li>为了得到训练逻辑回归模型的参数，需要一个代价函数，通过训练代价函数来得到参数。</li><li>用于找到最优解的目的函数。</li></ol><h3 id="代价函数作用原理"><a href="#代价函数作用原理" class="headerlink" title="代价函数作用原理"></a>代价函数作用原理</h3><p>在回归问题中，通过代价函数来求解最优解，常用的是平方误差代价函数。假设函数图像如图2-4所示，当参数发生变化时，假设函数状态也会随着变化。</p><p><img src="/p/16a6/2.16/1.jpg" alt></p><p>图2-4  $h(x) = A + Bx$函数示意图<br>想要拟合图中的离散点，我们需要尽可能找到最优的$A$和$B$来使这条直线更能代表所有数据。如何找到最优解呢，这就需要使用代价函数来求解，以平方误差代价函数为例，假设函数为$h(x)=\theta_0x$。</p><p><strong>平方误差代价函数的主要思想</strong>就是将实际数据给出的值与拟合出的线的对应值做差，求出拟合出的直线与实际的差距。在实际应用中，为了避免因个别极端数据产生的影响，采用类似方差再取二分之一的方式来减小个别数据的影响。因此，引出代价函数：</p><script type="math/tex; mode=display">J(\theta_0, \theta_1) = \frac{1}{m}\sum_{i=1}^m(h(x^{(i)})-y^{(i)})^2</script><p><strong>最优解即为代价函数的最小值</strong>$\min J(\theta_0, \theta_1)$。如果是1个参数，代价函数一般通过二维曲线便可直观看出。如果是2个参数，代价函数通过三维图像可看出效果，参数越多，越复杂。<br>当参数为2个时，代价函数是三维图像，如下图2-5所示。</p><p><img src="/p/16a6/2.16/2.jpg" alt></p><p>图2-5  代价函数三维图像</p><h3 id="为什么代价函数要非负"><a href="#为什么代价函数要非负" class="headerlink" title="为什么代价函数要非负"></a>为什么代价函数要非负</h3><p>目标函数存在一个下界，在优化过程当中，如果优化算法能够使目标函数不断减小，根据单调有界准则，这个优化算法就能证明是收敛有效的。</p><p>只要设计的目标函数有下界，基本上都可以，代价函数非负更为方便。</p><h3 id="常见代价函数"><a href="#常见代价函数" class="headerlink" title="常见代价函数"></a>常见代价函数</h3><p>（1）<strong>二次代价函数（quadratic cost）</strong>：</p><script type="math/tex; mode=display">J = \frac{1}{2n}\sum_x\Vert y(x)-a^L(x)\Vert^2</script><p>其中，$J$表示代价函数，$x$表示样本，$y$表示实际值，$a$表示输出值，$n$表示样本的总数。使用一个样本为例简单说明，此时二次代价函数为：</p><script type="math/tex; mode=display">J = \frac{(y-a)^2}{2}</script><p>假如使用梯度下降法（Gradient descent）来调整权值参数的大小，权值$w$和偏置$b$的梯度推导如下：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial w}=(y-a)\sigma'(z)x\;,\frac{\partial J}{\partial b}=(y-a)\sigma'(z)</script><p>其中，$z$表示神经元的输入，$\sigma$表示激活函数。权值$w$和偏置$b$的梯度跟激活函数的梯度成正比，激活函数的梯度越大，权值$w$和偏置$b$的大小调整得越快，训练收敛得就越快。</p><p><em>注</em>：神经网络常用的激活函数为sigmoid函数，该函数的曲线如下图2-6所示：</p><p><img src="/p/16a6/2.18/1.jpg" alt></p><p>图2-6 sigmoid函数曲线</p><p>如上图所示，对0.88和0.98两个点进行比较：</p><ul><li>假设目标是收敛到1.0。0.88离目标1.0比较远，梯度比较大，权值调整比较大。0.98离目标1.0比较近，梯度比较小，权值调整比较小。调整方案合理。</li><li>假如目标是收敛到0。0.88离目标0比较近，梯度比较大，权值调整比较大。0.98离目标0比较远，梯度比较小，权值调整比较小。调整方案不合理。</li><li>原因：在使用sigmoid函数的情况下, 初始的代价（误差）越大，导致训练越慢。</li></ul><p>（2）<strong>交叉熵代价函数（cross-entropy）</strong>：</p><script type="math/tex; mode=display">J = -\frac{1}{n}\sum_x[y\ln a + (1-y)\ln{(1-a)}]</script><p>其中，$J$表示代价函数，$x$表示样本，$y$表示实际值，$a$表示输出值，$n$表示样本的总数。<br>权值$w$和偏置$b$的梯度推导如下：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)</script><p>当误差越大时，梯度就越大，权值$w$和偏置$b$调整就越快，训练的速度也就越快。<br><strong>二次代价函数适合输出神经元是线性的情况，交叉熵代价函数适合输出神经元是S型函数的情况。</strong></p><p>（3）<strong>对数似然代价函数（log-likelihood cost）</strong>：<br>对数似然函数常用来作为softmax回归的代价函数。深度学习中普遍的做法是将softmax作为最后一层，此时常用的代价函数是对数似然代价函数。<br>对数似然代价函数与softmax的组合和交叉熵与sigmoid函数的组合非常相似。对数似然代价函数在二分类时可以化简为交叉熵代价函数的形式。<br>在tensorflow中：</p><ul><li>与sigmoid搭配使用的交叉熵函数：<code>tf.nn.sigmoid_cross_entropy_with_logits()</code>。</li><li>与softmax搭配使用的交叉熵函数：<code>tf.nn.softmax_cross_entropy_with_logits()</code>。</li></ul><p>在pytorch中：</p><ul><li>与sigmoid搭配使用的交叉熵函数：<code>torch.nn.BCEWithLogitsLoss()</code>。</li><li>与softmax搭配使用的交叉熵函数：<code>torch.nn.CrossEntropyLoss()</code>。</li></ul><p>对数似然函数：</p><p>我们将似然函数作为机器学习模型的损失函数，并且用在分类问题中。这时似然函数是直接作用于模型的输出的（损失函数就是为了衡量当前参数下model的预测值predict距离真实值label的大小，所以似然函数用作损失函数时当然也是为了完成该任务），所以对于似然函数来说，这里的样本集就成了label集（而不是机器学习意义上的样本集X了），这里的参数也不是机器学习model 的参数，而是predict值。</p><p>其实作为损失函数的似然函数并不关心你当前的机器学习model的参数是怎样的，毕竟它此时所接收的输入只有两部分：<strong>1、predict。2、label 。3、分布模型（predict服从的分布）</strong>。</p><p>显然这里的label就是似然函数的观测值，即样本集。<strong>而它眼里的模型，当然就是predict这个随机变量所服从的概率分布模型。它的目的，就是衡量predict背后的模型对于当前观测值的解释程度。而每个样本的predict值，恰恰就是它所服从的分布模型的参数。</strong></p><p>比如此时我们的机器学习任务是一个4个类别的分类任务，机器学习model的输出就是当前样本X下的每个类别的概率，如predict=[0.1, 0.1, 0.7, 0.1]，而该样本的标签是类别3，表示成向量就是label=[0, 0, 1, 0]。那么label=[0, 0, 1, 0]就是似然函数眼里的样本，然后我们可以假设predict这个随机变量背后的模型是<strong>单次观测下的多项式分布</strong>，（<strong>因为softmax本身是基于多项式分布的</strong>）。    </p><p>回顾：</p><p>伯努利分布，也叫做（0，1）分布，贝努利分布可以看成是将一枚硬币（只有正反两个面，代表两个类别）向上扔出，出现某个面（类别）的概率情况，因此其概率密度函数为：</p><script type="math/tex; mode=display">f(x)=p^x(1-p)^{1-x}=\begin{cases}p,& x=1\\q,& x=0\end{cases}</script><p>这是理解似然函数做损失函数的关键！另外，贝努利分布的模型参数就是其中一个类别的发生概率。</p><p>而二项分布呢，就是将贝努利实验重复n次（各次实验之间是相互独立的）。</p><p>而多项式分布呢，就是将二项分布推广到多个面（类别）。</p><p><strong>所以，单次观测下的多项式分布就是贝努利分布的多类推广！即：</strong></p><script type="math/tex; mode=display">f_{mulit}(x;p)=\prod_{i=1}^C p_{i}^{xi}</script><p>其中，C代表类别数。p代表向量形式的模型参数，即各个类别的发生概率，如p=[0.1, 0.1, 0.7, 0.1]，则p1=0.1, p3=0.7等。即，<strong>多项式分布的模型参数就是各个类别的发生概率！</strong>x代表<strong>one-hot形式</strong>的观测值，如x=类别3，则x=[0, 0, 1, 0]。xi代表x的第i个元素，比如x=类别3时，x1=0，x2=0，x3=1，x4=0。</p><p>想一下，机器学习model对某个样本的输出，就代表各个类别发生的概率。但是，对于当前<strong>这一个</strong>样本而言，它肯定只能有<strong>一个类别</strong>，所以这一个样本就可以看成是一次实验（观察），而这次实验（观察）的结果要服从上述各个类别发生的概率，那不就是服从多项式分布嘛！而且是单次观察！各个类别发生的概率predict当然就是这个多项式分布的参数。</p><p><strong>总结一下，对于多类分类问题，似然函数就是衡量当前这个以predict为参数的单次观测下的多项式分布模型与样本值label之间的似然度。</strong></p><p>所以，根据似然函数的定义，单个样本的似然函数即：</p><script type="math/tex; mode=display">L = f_{mulit}(label;predict)</script><p>所以，整个样本集（或者一个batch）的似然函数即：</p><script type="math/tex; mode=display">L=\prod_{X}f_{multi}(label;predict)= \prod_{X}\prod_{i=1}^{C}predict(i)^{label(i)}</script><p>所以在累乘号前面加上log函数后，就成了所谓的对数似然函数：</p><script type="math/tex; mode=display">L=\sum_{X}\sum_{i=1}^{C}label(i)log(predict(i))</script><p>而最大化对数似然函数就等效于最小化负对数似然函数，所以前面加个负号就和交叉熵的形式相同的了。</p><p>交叉熵定义：对于某种分布的随机变量X~p(x), 有一个模型q(x)用于近似p(x)的概率分布，则分布X与模型q之间的交叉熵即：</p><script type="math/tex; mode=display">H(X,q)=-\sum_{x}p(x)logq(x)</script><p>这里X的分布模型即样本集label的真实分布模型，这里模型q(x)即想要模拟真实分布模型的机器学习模型。可以说交叉熵是直接衡量两个分布，或者说两个model之间的差异。而似然函数则是解释以model的输出为参数的某分布模型对样本集的解释程度。因此，可以说这两者是“同貌不同源”，但是“殊途同归”啦。</p><p>tips：</p><p>最大似然估计：</p><p>给定一堆数据，假如我们知道它是从某一种分布中随机取出来的，可是我们并不知道这个分布具体的参，即“模型已定，参数未知”。例如，我们知道这个分布是正态分布，但是不知道均值和方差；或者是二项分布，但是不知道均值。最大似然估计（MLE，Maximum Likelihood Estimation）就可以用来估计模型的参数。<strong>MLE的目标是找出一组参数，使得模型产生出观测数据的概率最大。</strong></p><h3 id="为什么用交叉熵代替二次代价函数"><a href="#为什么用交叉熵代替二次代价函数" class="headerlink" title="为什么用交叉熵代替二次代价函数"></a>为什么用交叉熵代替二次代价函数</h3><p>（1）<strong>为什么不用二次方代价函数</strong><br>由上一节可知，权值$w$和偏置$b$的偏导数为$\frac{\partial J}{\partial w}=(a-y)\sigma’(z)x$，$\frac{\partial J}{\partial b}=(a-y)\sigma’(z)$， 偏导数受激活函数的导数影响，sigmoid函数导数在输出接近0和1时非常小，会导致一些实例在刚开始训练时学习得非常慢。</p><p>（2）<strong>为什么要用交叉熵</strong><br>交叉熵函数权值$w$和偏置$b$的梯度推导为：</p><script type="math/tex; mode=display">\frac{\partial J}{\partial w_j}=\frac{1}{n}\sum_{x}x_j(\sigma{(z)}-y)\;，\frac{\partial J}{\partial b}=\frac{1}{n}\sum_{x}(\sigma{(z)}-y)</script><p>由以上公式可知，权重学习的速度受到$\sigma{(z)}-y$影响，更大的误差，就有更快的学习速度，避免了二次代价函数方程中因$\sigma’{(z)}$导致的学习缓慢的情况。</p><h2 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h2><h3 id="什么是损失函数"><a href="#什么是损失函数" class="headerlink" title="什么是损失函数"></a>什么是损失函数</h3><p>损失函数（Loss Function）又叫做误差函数，用来衡量算法的运行情况，估量模型的预测值与真实值的不一致程度，是一个非负实值函数，通常使用$<br>L(Y, f(x))$来表示。损失函数越小，模型的鲁棒性就越好。损失函数是经验风险函数的核心部分，也是结构风险函数重要组成部分。</p><h3 id="常见的损失函数"><a href="#常见的损失函数" class="headerlink" title="常见的损失函数"></a>常见的损失函数</h3><p>机器学习通过对算法中的目标函数进行不断求解优化，得到最终想要的结果。分类和回归问题中，通常使用损失函数或代价函数作为目标函数。<br>损失函数用来评价预测值和真实值不一样的程度。通常损失函数越好，模型的性能也越好。<br>损失函数可分为经验风险损失函数和结构风险损失函数。经验风险损失函数指预测结果和实际结果的差别，结构风险损失函数是在经验风险损失函数上加上正则项。<br>下面介绍常用的损失函数：</p><p>（1）<strong>0-1损失函数</strong><br>如果预测值和目标值相等，值为0，如果不相等，值为1。</p><script type="math/tex; mode=display">L(Y, f(x)) =\begin{cases}1,& Y\ne f(x)\\0,& Y = f(x)\end{cases}</script><p>一般的在实际使用中，相等的条件过于严格，可适当放宽条件：</p><script type="math/tex; mode=display">L(Y, f(x)) =\begin{cases}1,& |Y-f(x)|\geqslant T\\0,& |Y-f(x)|< T\end{cases}</script><p>（2）<strong>绝对值损失函数</strong><br>和0-1损失函数相似，绝对值损失函数表示为：</p><script type="math/tex; mode=display">L(Y, f(x)) = |Y-f(x)|</script><p>（3）<strong>平方损失函数</strong></p><script type="math/tex; mode=display">L(Y, f(x)) = \sum_N{(Y-f(x))}^2</script><p>这点可从最小二乘法和欧几里得距离角度理解。最小二乘法的原理是，最优拟合曲线应该使所有点到回归直线的距离和最小。</p><p>（4）<strong>对数损失函数</strong></p><script type="math/tex; mode=display">L(Y, P(Y|X)) = -\log{P(Y|X)}=-\frac{1}{N}\sum_{i=1}^N\sum_{j=1}^M y_{ij}log(p_{ij})</script><p>其中, Y 为输出变量, X为输入变量, L 为损失函数. N为输入样本量, M为可能的类别数, $y_{ij}$ 是一个二值指标, 表示类别 j 是否是输入实例 xi 的真实类别. $p_{ij}$ 为模型或分类器预测输入实例 xi 属于类别 j 的概率.</p><p>常见的逻辑回归使用的就是对数损失函数，有很多人认为逻辑回归的损失函数是平方损失，其实不然。逻辑回归它假设样本服从伯努利分布（0-1分布），进而求得满足该分布的似然函数，接着取对数求极值等。逻辑回归推导出的经验风险函数是最小化负的似然函数，从损失函数的角度看，就是对数损失函数。形式上等价于二分类的交叉熵损失函数。</p><p>（6）<strong>指数损失函数</strong><br>指数损失函数的标准形式为：</p><script type="math/tex; mode=display">L(Y, f(x)) = \exp(-Yf(x))</script><p>例如AdaBoost就是以指数损失函数为损失函数。</p><p>（7）<strong>Hinge损失函数</strong><br>Hinge损失函数的标准形式如下：</p><script type="math/tex; mode=display">L(y) = \max{(0, 1-ty)}</script><p>统一的形式：</p><script type="math/tex; mode=display">L(Y, f(x)) = \max{(0, Yf(x))}</script><p>其中y是预测值，范围为(-1,1)，t为目标值，其为-1或1。</p><p>在线性支持向量机中，最优化问题可等价于</p><script type="math/tex; mode=display">\underset{\min}{w,b}\sum_{i=1}^N (1-y_i(wx_i+b))+\lambda\Vert w\Vert ^2</script><p>上式相似于下式</p><script type="math/tex; mode=display">\frac{1}{m}\sum_{i=1}^{N}l(wx_i+by_i) + \Vert w\Vert ^2</script><p>其中$l(wx_i+by_i)$是Hinge损失函数，$\Vert w\Vert ^2$可看做为正则化项。</p><h3 id="逻辑回归为什么使用对数损失函数"><a href="#逻辑回归为什么使用对数损失函数" class="headerlink" title="逻辑回归为什么使用对数损失函数"></a>逻辑回归为什么使用对数损失函数</h3><p>假设逻辑回归模型</p><script type="math/tex; mode=display">P(y=1|x;\theta)=\frac{1}{1+e^{-\theta^{T}x}}</script><p>假设逻辑回归模型的概率分布是伯努利分布，其概率质量函数为：</p><script type="math/tex; mode=display">P(X=n)=\begin{cases}1-p, n=0\\ p,n=1\end{cases}</script><p>其似然函数为：</p><script type="math/tex; mode=display">L(\theta)=\prod_{i=1}^{m}P(y=1|x_i)^{y_i}P(y=0|x_i)^{1-y_i}</script><p>对数似然函数为：</p><script type="math/tex; mode=display">\ln L(\theta)=\sum_{i=1}^{m}[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln{P(y=0|x_i)}]\\  =\sum_{i=1}^m[y_i\ln{P(y=1|x_i)}+(1-y_i)\ln(1-P(y=1|x_i))]</script><p>对数函数在单个数据点上的定义为：</p><script type="math/tex; mode=display">cost(y,p(y|x))=-y\ln{p(y|x)-(1-y)\ln(1-p(y|x))}</script><p>则全局样本损失函数为：</p><script type="math/tex; mode=display">cost(y,p(y|x)) = -\sum_{i=1}^m[y_i\ln p(y_i|x_i)+(1-y_i)\ln(1-p(y_i|x_i))]</script><p>由此可看出，对数损失函数与极大似然估计的对数似然函数本质上是相同的。所以逻辑回归直接采用对数损失函数。</p><h3 id="对数损失函数是如何度量损失的"><a href="#对数损失函数是如何度量损失的" class="headerlink" title="对数损失函数是如何度量损失的"></a>对数损失函数是如何度量损失的</h3><p>例如，在高斯分布中，我们需要确定均值和标准差。<br>如何确定这两个参数？最大似然估计是比较常用的方法。最大似然的目标是找到一些参数值，这些参数值对应的分布可以最大化观测到数据的概率。<br>因为需要计算观测到所有数据的全概率，即所有观测到的数据点的联合概率。现考虑如下简化情况：</p><p>（1）假设观测到每个数据点的概率和其他数据点的概率是独立的。</p><p>（2）取自然对数。<br>假设观测到单个数据点$x_i(i=1,2,…n)$的概率为：</p><script type="math/tex; mode=display">P(x_i;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp         \left( - \frac{(x_i-\mu)^2}{2\sigma^2} \right)</script><p>（3）其联合概率为：</p><script type="math/tex; mode=display">P(x_1,x_2,...,x_n;\mu,\sigma)=\frac{1}{\sigma \sqrt{2\pi}}\exp         \left( - \frac{(x_1-\mu)^2}{2\sigma^2} \right) \\ \times         \frac{1}{\sigma \sqrt{2\pi}}\exp         \left( - \frac{(x_2-\mu)^2}{2\sigma^2} \right) \times ... \times        \frac{1}{\sigma \sqrt{2\pi}}\exp         \left( - \frac{(x_n-\mu)^2}{2\sigma^2} \right)</script><p>对上式取自然对数，可得：</p><script type="math/tex; mode=display"> \ln(P(x_1,x_2,...x_n;\mu,\sigma))=         \ln \left(\frac{1}{\sigma \sqrt{2\pi}} \right)           - \frac{(x_1-\mu)^2}{2\sigma^2}  \\ +          \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right)           - \frac{(x_2-\mu)^2}{2\sigma^2} +...+          \ln \left( \frac{1}{\sigma \sqrt{2\pi}} \right)           - \frac{(x_n-\mu)^2}{2\sigma^2}</script><p>根据对数定律，上式可以化简为：</p><script type="math/tex; mode=display">\ln(P(x_1,x_2,...x_n;\mu,\sigma))=-n\ln(\sigma)-\frac{n}{2} \ln(2\pi)\\         -\frac{1}{2\sigma^2}[(x_1-\mu)^2+(x_2-\mu)^2+...+(x_n-\mu)^2]</script><p>然后求导为：</p><script type="math/tex; mode=display">\frac{\partial\ln(P(x_1,x_2,...,x_n;\mu,\sigma))}{\partial\mu}=                 \frac{n}{\sigma^2}[\mu - (x_1+x_2+...+x_n)]</script><p>上式左半部分为对数损失函数。损失函数越小越好，因此我们令等式左半的对数损失函数为0，可得：</p><script type="math/tex; mode=display">\mu=\frac{x_1+x_2+...+x_n}{n}</script><p>同理，可计算$\sigma $。</p><h2 id="梯度下降"><a href="#梯度下降" class="headerlink" title="梯度下降"></a>梯度下降</h2><h3 id="机器学习中为什么需要梯度下降"><a href="#机器学习中为什么需要梯度下降" class="headerlink" title="机器学习中为什么需要梯度下降"></a>机器学习中为什么需要梯度下降</h3><p>梯度下降是机器学习中常见优化算法之一，梯度下降法有以下几个作用：</p><p>（1）梯度下降是迭代法的一种，可以用于求解最小二乘问题。</p><p>（2）在求解机器学习算法的模型参数，即无约束优化问题时，主要有梯度下降法（Gradient Descent）和最小二乘法。</p><p>（3）在求解损失函数的最小值时，可以通过梯度下降法来一步步的迭代求解，得到最小化的损失函数和模型参数值。</p><p>（4）如果我们需要求解损失函数的最大值，可通过梯度上升法来迭代。梯度下降法和梯度上升法可相互转换。</p><p>（5）在机器学习中，梯度下降法主要有随机梯度下降法和批量梯度下降法。</p><h3 id="梯度下降法缺点"><a href="#梯度下降法缺点" class="headerlink" title="梯度下降法缺点"></a>梯度下降法缺点</h3><p>梯度下降法缺点有以下几点：</p><p>（1）靠近极小值时收敛速度减慢。</p><p>（2）直线搜索时可能会产生一些问题。</p><p>（3）可能会“之字形”地下降。</p><p>梯度概念也有需注意的地方：</p><p>（1）梯度是一个向量，即有方向有大小。 </p><p>（2）梯度的方向是最大方向导数的方向。 </p><p>（3）梯度的值是最大方向导数的值。</p><h3 id="2-12-3-梯度下降法直观理解"><a href="#2-12-3-梯度下降法直观理解" class="headerlink" title="2.12.3 梯度下降法直观理解"></a>2.12.3 梯度下降法直观理解</h3><p>梯度下降法经典图示如下图2.7所示：</p><p><img src="/p/16a6/2.25/1.png" alt></p><p>图2.7 梯度下降法经典图示</p><p>形象化举例，由上图2.7所示，假如最开始，我们在一座大山上的某处位置，因为到处都是陌生的，不知道下山的路，所以只能摸索着根据直觉，走一步算一步，在此过程中，每走到一个位置的时候，都会求解当前位置的梯度，沿着梯度的负方向，也就是当前最陡峭的位置向下走一步，然后继续求解当前位置梯度，向这一步所在位置沿着最陡峭最易下山的位置走一步。不断循环求梯度，就这样一步步地走下去，一直走到我们觉得已经到了山脚。当然这样走下去，有可能我们不能走到山脚，而是到了某一个局部的山势低处。<br>由此，从上面的解释可以看出，梯度下降不一定能够找到全局的最优解，有可能是一个局部的最优解。当然，如果损失函数是凸函数，梯度下降法得到的解就一定是全局最优解。</p><p><strong>核心思想归纳</strong>：</p><p>（1）初始化参数，随机选取取值范围内的任意数；</p><p>（2）迭代操作：<br>    a）计算当前梯度；<br>    b）修改新的变量；<br>    c）计算朝最陡的下坡方向走一步；<br>    d）判断是否需要终止，如否，返回a）；</p><p>（3）得到全局最优解或者接近全局最优解。</p><h3 id="2-12-4-梯度下降法算法描述"><a href="#2-12-4-梯度下降法算法描述" class="headerlink" title="2.12.4 梯度下降法算法描述"></a>2.12.4 梯度下降法算法描述</h3><p>梯度下降法算法步骤如下：</p><p>（1）确定优化模型的假设函数及损失函数。<br>    举例，对于线性回归，假设函数为：</p><script type="math/tex; mode=display">  h_\theta(x_1,x_2,...,x_n)=\theta_0+\theta_1x_1+...+\theta_nx_n</script><p>  其中，$\theta_i,x_i(i=0,1,2,…,n)$分别为模型参数、每个样本的特征值。<br>  对于假设函数，损失函数为：</p><script type="math/tex; mode=display">  J(\theta_0,\theta_1,...,\theta_n)=\frac{1}{2m}\sum^{m}_{j=0}(h_\theta (x^{(j)}_0      ,x^{(j)}_1,...,x^{(j)}_n)-y_j)^2</script><p>（2）相关参数初始化。<br>    主要初始化${\theta}_i$、算法迭代步长${\alpha} $、终止距离${\zeta} $。初始化时可以根据经验初始化，即${\theta} $初始化为0，步长${\alpha} $初始化为1。当前步长记为${\varphi}_i $。当然，也可随机初始化。</p><p>（3）迭代计算。</p><pre><code>1）计算当前位置时损失函数的梯度，对$&#123;\theta&#125;_i $，其梯度表示为：</code></pre><script type="math/tex; mode=display">\frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)=\frac{1}{2m}\sum^{m}_{j=0}(h_\theta (x^{(j)}_0    ,x^{(j)}_1,...,x^{(j)}_n)-y_j)^2</script><pre><code>2）计算当前位置下降的距离。</code></pre><script type="math/tex; mode=display">{\varphi}_i={\alpha} \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)</script><pre><code>3）判断是否终止。确定是否所有$&#123;\theta&#125;_i$梯度下降的距离$&#123;\varphi&#125;_i$都小于终止距离$&#123;\zeta&#125;$，如果都小于$&#123;\zeta&#125;$，则算法终止，当然的值即为最终结果，否则进入下一步。4）更新所有的$&#123;\theta&#125;_i$，更新后的表达式为：</code></pre><script type="math/tex; mode=display">{\theta}_i={\theta}_i-\alpha \frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)</script><script type="math/tex; mode=display">\theta_i=\theta_i - \alpha \frac{1}{m} \sum^{m}_{j=0}(h_\theta (x^{(j)}_0    ,x^{(j)}_1,...,x^{(j)}_n)-y_j)x^{(j)}_i</script><pre><code>5）令上式$x^&#123;(j)&#125;_0=1$，更新完毕后转入1)。由此，可看出，当前位置的梯度方向由所有样本决定，上式中 $\frac&#123;1&#125;&#123;m&#125;$、$\alpha \frac&#123;1&#125;&#123;m&#125;$ 的目的是为了便于理解。</code></pre><h3 id="2-12-5-如何对梯度下降法进行调优"><a href="#2-12-5-如何对梯度下降法进行调优" class="headerlink" title="2.12.5 如何对梯度下降法进行调优"></a>2.12.5 如何对梯度下降法进行调优</h3><p>实际使用梯度下降法时，各项参数指标不能一步就达到理想状态，对梯度下降法调优主要体现在以下几个方面：</p><p>（1）<strong>算法迭代步长$\alpha$选择。</strong><br>    在算法参数初始化时，有时根据经验将步长初始化为1。实际取值取决于数据样本。可以从大到小，多取一些值，分别运行算法看迭代效果，如果损失函数在变小，则取值有效。如果取值无效，说明要增大步长。但步长太大，有时会导致迭代速度过快，错过最优解。步长太小，迭代速度慢，算法运行时间长。</p><p>（2）<strong>参数的初始值选择。</strong><br>    初始值不同，获得的最小值也有可能不同，梯度下降有可能得到的是局部最小值。如果损失函数是凸函数，则一定是最优解。由于有局部最优解的风险，需要多次用不同初始值运行算法，关键损失函数的最小值，选择损失函数最小化的初值。</p><p>（3）<strong>标准化处理。</strong><br>    由于样本不同，特征取值范围也不同，导致迭代速度慢。为了减少特征取值的影响，可对特征数据标准化，使新期望为0，新方差为1，可节省算法运行时间。</p><h3 id="2-12-6-随机梯度和批量梯度区别"><a href="#2-12-6-随机梯度和批量梯度区别" class="headerlink" title="2.12.6 随机梯度和批量梯度区别"></a>2.12.6 随机梯度和批量梯度区别</h3><pre><code>随机梯度下降（SGD）和批量梯度下降（BGD）是两种主要梯度下降法，其目的是增加某些限制来加速运算求解。</code></pre><p>下面通过介绍两种梯度下降法的求解思路，对其进行比较。<br>假设函数为：</p><script type="math/tex; mode=display">h_\theta (x_0,x_1,...,x_3) = \theta_0 x_0 + \theta_1 x_1 + ... + \theta_n x_n</script><p>损失函数为：</p><script type="math/tex; mode=display">J(\theta_0, \theta_1, ... , \theta_n) =             \frac{1}{2m} \sum^{m}_{j=0}(h_\theta (x^{j}_0    ,x^{j}_1,...,x^{j}_n)-y^j)^2</script><p>其中，$m$为样本个数，$j$为参数个数。</p><p>1、 <strong>批量梯度下降的求解思路如下：</strong><br>a) 得到每个$ \theta $对应的梯度：</p><script type="math/tex; mode=display">\frac{\partial}{\partial \theta_i}J({\theta}_0,{\theta}_1,...,{\theta}_n)=\frac{1}{m}\sum^{m}_{j=0}(h_\theta (x^{j}_0    ,x^{j}_1,...,x^{j}_n)-y^j)x^{j}_i</script><p>b) 由于是求最小化风险函数，所以按每个参数 $ \theta $ 的梯度负方向更新 $ \theta_i $ ：</p><script type="math/tex; mode=display">\theta_i=\theta_i - \frac{1}{m} \sum^{m}_{j=0}(h_\theta (x^{j}_0    ,x^{j}_1,...,x^{j}_n)-y^j)x^{j}_i</script><p>c) 从上式可以注意到，它得到的虽然是一个全局最优解，但每迭代一步，都要用到训练集所有的数据，如果样本数据很大，这种方法迭代速度就很慢。<br>相比而言，随机梯度下降可避免这种问题。</p><p>2、<strong>随机梯度下降的求解思路如下：</strong><br>a) 相比批量梯度下降对应所有的训练样本，随机梯度下降法中损失函数对应的是训练集中每个样本的粒度。<br>损失函数可以写成如下这种形式，</p><script type="math/tex; mode=display">J(\theta_0, \theta_1, ... , \theta_n) =             \frac{1}{m} \sum^{m}_{j=0}(y^j - h_\theta (x^{j}_0            ,x^{j}_1,...,x^{j}_n))^2 =             \frac{1}{m} \sum^{m}_{j=0} cost(\theta,(x^j,y^j))</script><p>b）对每个参数 $ \theta$ 按梯度方向更新 $ \theta$：</p><script type="math/tex; mode=display">\theta_i = \theta_i + (y^j - h_\theta (x^{j}_0, x^{j}_1, ... ,x^{j}_n))</script><p>c) 随机梯度下降是通过每个样本来迭代更新一次。<br>随机梯度下降伴随的一个问题是噪音较批量梯度下降要多，使得随机梯度下降并不是每次迭代都向着整体最优化方向。</p><p><strong>小结：</strong><br>随机梯度下降法、批量梯度下降法相对来说都比较极端，简单对比如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:center">批量梯度下降</td><td style="text-align:left">a）采用所有数据来梯度下降。<br>b）批量梯度下降法在样本量很大的时候，训练速度慢。</td></tr><tr><td style="text-align:center">随机梯度下降</td><td style="text-align:left">a）随机梯度下降用一个样本来梯度下降。<br>b）训练速度很快。<br>c）随机梯度下降法仅仅用一个样本决定梯度方向，导致解有可能不是全局最优。<br>d）收敛速度来说，随机梯度下降法一次迭代一个样本，导致迭代方向变化很大，不能很快的收敛到局部最优解。</td></tr></tbody></table></div><p>下面介绍能结合两种方法优点的小批量梯度下降法。</p><p>3、 <strong>小批量（Mini-Batch）梯度下降的求解思路如下</strong><br>对于总数为$m$个样本的数据，根据样本的数据，选取其中的$n(1&lt; n&lt; m)$个子样本来迭代。其参数$\theta$按梯度方向更新$\theta_i$公式如下：</p><script type="math/tex; mode=display">\theta_i = \theta_i - \alpha \sum^{t+n-1}_{j=t}        ( h_\theta (x^{j}_{0}, x^{j}_{1}, ... , x^{j}_{n} ) - y^j ) x^{j}_{i}</script><h3 id="2-12-7-各种梯度下降法性能比较"><a href="#2-12-7-各种梯度下降法性能比较" class="headerlink" title="2.12.7 各种梯度下降法性能比较"></a>2.12.7 各种梯度下降法性能比较</h3><pre><code>下表简单对比随机梯度下降（SGD）、批量梯度下降（BGD）、小批量梯度下降（Mini-batch GD）、和Online GD的区别：</code></pre><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">BGD</th><th style="text-align:center">SGD</th><th style="text-align:center">Mini-batch GD</th><th style="text-align:center">Online GD</th></tr></thead><tbody><tr><td style="text-align:center">训练集</td><td style="text-align:center">固定</td><td style="text-align:center">固定</td><td style="text-align:center">固定</td><td style="text-align:center">实时更新</td></tr><tr><td style="text-align:center">单次迭代样本数</td><td style="text-align:center">整个训练集</td><td style="text-align:center">单个样本</td><td style="text-align:center">训练集的子集</td><td style="text-align:center">根据具体算法定</td></tr><tr><td style="text-align:center">算法复杂度</td><td style="text-align:center">高</td><td style="text-align:center">低</td><td style="text-align:center">一般</td><td style="text-align:center">低</td></tr><tr><td style="text-align:center">时效性</td><td style="text-align:center">低</td><td style="text-align:center">一般</td><td style="text-align:center">一般</td><td style="text-align:center">高</td></tr><tr><td style="text-align:center">收敛性</td><td style="text-align:center">稳定</td><td style="text-align:center">不稳定</td><td style="text-align:center">较稳定</td><td style="text-align:center">不稳定</td></tr></tbody></table></div><p>BGD、SGD、Mini-batch GD，前面均已讨论过，这里介绍一下Online GD。</p><pre><code>Online GD于Mini-batch GD/SGD的区别在于，所有训练数据只用一次，然后丢弃。这样做的优点在于可预测最终模型的变化趋势。Online GD在互联网领域用的较多，比如搜索广告的点击率（CTR）预估模型，网民的点击行为会随着时间改变。用普通的BGD算法（每天更新一次）一方面耗时较长（需要对所有历史数据重新训练）；另一方面，无法及时反馈用户的点击行为迁移。而Online GD算法可以实时的依据网民的点击行为进行迁移。</code></pre><h2 id="2-13-自然梯度法"><a href="#2-13-自然梯度法" class="headerlink" title="2.13 自然梯度法"></a>2.13 自然梯度法</h2><p><strong>（贡献者：郜泉凯－华南理工大学）</strong></p><h3 id="2-13-1-为什么我们需要自然梯度"><a href="#2-13-1-为什么我们需要自然梯度" class="headerlink" title="2.13.1 为什么我们需要自然梯度"></a>2.13.1 为什么我们需要自然梯度</h3><p>传统的梯度下降方法是在欧氏空间进行、并与时序过程结合的优化方法，但这样的更新过程无法度量由于参数变化引起的概率属性的变化（这一点也可以认为是传统梯度下降方法的缺点）。在如强化学习等很多应用领域关注模型输出的概率分布，优化过程常常需要在一定概率属性的约束下完成，这就需要自然梯度。</p><h3 id="2-12-2-如何定义自然梯度"><a href="#2-12-2-如何定义自然梯度" class="headerlink" title="2.12.2 如何定义自然梯度"></a>2.12.2 如何定义自然梯度</h3><p>若度量模型参数变化引起的概率分布变化，常用的“距离”度量是KL散度（Kullback-Leibler divergence）。设模型概率分布为$p(x;\theta)$，其与参数变动后的概率分布间的KL散度为：</p><script type="math/tex; mode=display">D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))=\int p(x;\theta)log\frac {p(x;\theta)}{p(x;\theta+\delta\theta)}dx</script><p>我们令$f(\theta+\delta\theta)=log p(x;\theta+\delta\theta)$，做泰勒展开取二阶近似（忽略高阶余项）得到：</p><script type="math/tex; mode=display">f(\theta+\delta\theta)\approx f(\theta)+\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}+\frac{1}{2}\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}\delta\theta</script><p>带入到$D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))$中可得到：</p><script type="math/tex; mode=display">\begin{eqnarray}D_{KL}(p(x;\theta)||p(x;\theta+\delta\theta))&=&\int p(x;\theta)(f(\theta)-f(\theta+\delta\theta))dx\\&=&-\int p(x;\theta)(\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}+\frac{1}{2}\delta\theta^T\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}\delta\theta)dx\\&=&-\delta\theta^T\int p(x;\theta)\frac{\partial logp(x;\theta)}{\partial\theta}dx\\&-&\frac{1}{2}\delta\theta^T\int p(x;\theta)\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}dx\delta\theta\\&=&-\delta\theta^T\int p(x;\theta)\frac{\frac{\partial p(x;\theta)}{\partial\theta}}{p(x;\theta)}dx-\frac{1}{2}\delta\theta^TG\delta\theta\\&=&-\frac{1}{2}\delta\theta^TG\delta\theta\end{eqnarray}</script><p>我们记在KL散度意义下的参数增量为$\delta\theta_G$，接下来我们寻求在$||\delta\theta_G||^2=\epsilon$约束下$\delta\theta_G$的方向，使得目标函数$J(\theta)$下降最快,即$J(\theta+\delta\theta)-J(\theta)$最大。应用拉格朗日乘子法：</p><script type="math/tex; mode=display">\max_{\delta\theta}J(\theta+\delta\theta)-J(\theta)-\lambda(||\delta\theta_G||^2-\epsilon)</script><p>应用一阶泰勒展开等价于:</p><script type="math/tex; mode=display">\max_{\delta\theta}\nabla \delta\theta^T J(\theta)-\frac{1}{2}\lambda\delta\theta^TG\delta\theta</script><p>对$\delta\theta$求导得$\nabla J(\theta)-\lambda G\delta\theta=0$，即$\delta\theta=\frac{1}{\lambda}G^{-1}\nabla J(\theta)$，其中$G^{-1}\nabla J(\theta)$称为自然梯度，相应的自然梯度下降公式为$\theta_{k+1}=\theta_k-\alpha_kG^{-1}(\theta_k)\nabla J(\theta_K)$。</p><h3 id="2-12-3-Fisher信息矩阵的意义"><a href="#2-12-3-Fisher信息矩阵的意义" class="headerlink" title="2.12.3 Fisher信息矩阵的意义"></a>2.12.3 Fisher信息矩阵的意义</h3><p>首先我们对一个模型进行建模，成为以$\theta$为参数的概率分布$p(x;\theta)$。为求出一个合理的$\theta$我们需要一个评分函数（score function）：$s(\theta)=\nabla_{\theta}logp(x;\theta)$，意为对数似然的梯度，当分数为0时（对数似然梯度为0），对数似然达到极值。对评分函数求关于$p(x;\theta)$数学期望$p_E$不难发现期望为0。接下来求估计误差的界，我们用评分函数的方差来确定，即$E_{p(x;\theta)}[(s(\theta)-p_E)(s(\theta-p_E)^T)]$。带入评分函数的数学表达形式则等价于Fisher信息矩阵$G(\theta)=\int p(x;\theta)\frac{\partial f(\theta)}{\partial\theta}\frac{\partial f(\theta)^T}{\partial\theta}dx$。特别地，Fisher信息矩阵与评分函数$\nabla_{\theta}logp(x;\theta)$的Hessian似然的负数等价。</p><p>证明：首先求出评分函数的Hessian矩阵，由梯度的Jacobian决定</p><script type="math/tex; mode=display">\begin{eqnarray}H_{logp(x;\theta)}&=&J(\frac{\nabla p(x;\theta)}{p(x;\theta)})\\&=&\frac{\frac{\partial\nabla p(x;\theta)}{\partial\theta}p(x;\theta)-\nabla p(x;\theta)\nabla p(x;\theta)^T}{p(x;\theta)p(x;\theta)}\\&=&\frac{H_{p(x;\theta)}p(x;\theta)}{p(x;\theta)p(x;\theta)}-\frac{\nabla p(x;\theta)\nabla p(x;\theta)^T}{p(x;\theta)p(x;\theta)}\\\end{eqnarray}</script><p>等式两边同时求关于$p(x;\theta)$的数学期望：</p><script type="math/tex; mode=display">\begin{eqnarray}E_{p(x;\theta)}[H_{logp(x;\theta)}] &=& E_{p(x;\theta)}(\frac{H_{p(x;\theta)}p(x;\theta)}{p(x;\theta)p(x;\theta)})-G\\&=&\int\frac{H_{p(x;\theta)}}{p(x;\theta)}p(x;\theta)dx-G\\&=&\nabla^2\int p(x;\theta)dx-G\\&=&-G\end{eqnarray}</script><p>而Hessian矩阵刻画着对数似然函数的曲率，所以本质上自然梯度下降法是在一个消除了不同概率分布的曲率后，在同一个“平坦”曲面上进行迭代更新，步长等于原概率分布空间的步长按照曲率折合到新的“平坦曲面”的大小。</p><p> 值得注意的一点是，一般来说似然函数获取很难，在实际问题中，我们可以用采样的方法从数据集中采样数据，将Fisher信息矩阵原始表达式的积分变为求和来近似估计，这样的方式得到的Fisher信息矩阵称为经验Fisher。</p><h2 id="2-14-线性判别分析（LDA）"><a href="#2-14-线性判别分析（LDA）" class="headerlink" title="2.14 线性判别分析（LDA）"></a>2.14 线性判别分析（LDA）</h2><h3 id="2-14-1-LDA思想总结"><a href="#2-14-1-LDA思想总结" class="headerlink" title="2.14.1 LDA思想总结"></a>2.14.1 LDA思想总结</h3><pre><code>线性判别分析（Linear Discriminant Analysis，LDA）是一种经典的降维方法。和主成分分析PCA不考虑样本类别输出的无监督降维技术不同，LDA是一种监督学习的降维技术，数据集的每个样本有类别输出。  </code></pre><p>LDA分类思想简单总结如下：  </p><ol><li>多维空间中，数据处理分类问题较为复杂，LDA算法将多维空间中的数据投影到一条直线上，将d维数据转化成1维数据进行处理。  </li><li>对于训练数据，设法将多维数据投影到一条直线上，同类数据的投影点尽可能接近，异类数据点尽可能远离。  </li><li>对数据进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。  </li></ol><p>如果用一句话概括LDA思想，即“投影后类内方差最小，类间方差最大”。</p><h3 id="2-14-2-图解LDA核心思想"><a href="#2-14-2-图解LDA核心思想" class="headerlink" title="2.14.2 图解LDA核心思想"></a>2.14.2 图解LDA核心思想</h3><pre><code>假设有红、蓝两类数据，这些数据特征均为二维，如下图所示。我们的目标是将这些数据投影到一维，让每一类相近的数据的投影点尽可能接近，不同类别数据尽可能远，即图中红色和蓝色数据中心之间的距离尽可能大。</code></pre><p><img src="/p/16a6/ch2/2.29/1.png" alt></p><p>左图和右图是两种不同的投影方式。</p><pre><code>左图思路：让不同类别的平均点距离最远的投影方式。右图思路：让同类别的数据挨得最近的投影方式。从上图直观看出，右图红色数据和蓝色数据在各自的区域来说相对集中，根据数据分布直方图也可看出，所以右图的投影效果好于左图，左图中间直方图部分有明显交集。以上例子是基于数据是二维的，分类后的投影是一条直线。如果原始数据是多维的，则投影后的分类面是一低维的超平面。</code></pre><h3 id="2-14-3-二类LDA算法原理"><a href="#2-14-3-二类LDA算法原理" class="headerlink" title="2.14.3 二类LDA算法原理"></a>2.14.3 二类LDA算法原理</h3><pre><code>输入：数据集 $D=\&#123;(\boldsymbol x_1,\boldsymbol y_1),(\boldsymbol x_2,\boldsymbol y_2),...,(\boldsymbol x_m,\boldsymbol y_m)\&#125;$，其中样本 $\boldsymbol x_i $ 是n维向量，$\boldsymbol y_i  \epsilon \&#123;0, 1\&#125;$，降维后的目标维度 $d$。定义$N_j(j=0,1)$ 为第 $j$ 类样本个数；$X_j(j=0,1)$ 为第 $j$ 类样本的集合；$u_j(j=0,1)$ 为第 $j$ 类样本的均值向量；$\sum_j(j=0,1)$ 为第 $j$ 类样本的协方差矩阵。其中</code></pre><script type="math/tex; mode=display">u_j = \frac{1}{N_j} \sum_{\boldsymbol x\epsilon X_j}\boldsymbol x(j=0,1)， \sum_j = \sum_{\boldsymbol x\epsilon X_j}(\boldsymbol x-u_j)(\boldsymbol x-u_j)^T(j=0,1)</script><pre><code>假设投影直线是向量 $\boldsymbol w$，对任意样本 $\boldsymbol x_i$，它在直线 $w$上的投影为 $\boldsymbol w^Tx_i$，两个类别的中心点 $u_0$, $u_1 $在直线 $w$ 的投影分别为 $\boldsymbol w^Tu_0$ 、$\boldsymbol w^Tu_1$。LDA的目标是让两类别的数据中心间的距离 $\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2$ 尽量大，与此同时，希望同类样本投影点的协方差$\boldsymbol w^T \sum_0 \boldsymbol w$、$\boldsymbol w^T \sum_1 \boldsymbol w$ 尽量小，最小化 $\boldsymbol w^T \sum_0 \boldsymbol w + \boldsymbol w^T \sum_1 \boldsymbol w$ 。定义类内散度矩阵</code></pre><script type="math/tex; mode=display">S_w = \sum_0 + \sum_1 =     \sum_{\boldsymbol x\epsilon X_0}(\boldsymbol x-u_0)(\boldsymbol x-u_0)^T +     \sum_{\boldsymbol x\epsilon X_1}(\boldsymbol x-u_1)(\boldsymbol x-u_1)^T</script><pre><code>类间散度矩阵 $S_b = (u_0 - u_1)(u_0 - u_1)^T$据上分析，优化目标为</code></pre><script type="math/tex; mode=display">\mathop{\arg\max}_\boldsymbol w J(\boldsymbol w) = \frac{\| \boldsymbol w^Tu_0 - \boldsymbol w^Tu_1 \|^2_2}{\boldsymbol w^T \sum_0\boldsymbol w + \boldsymbol w^T \sum_1\boldsymbol w} = \frac{\boldsymbol w^T(u_0-u_1)(u_0-u_1)^T\boldsymbol w}{\boldsymbol w^T(\sum_0 + \sum_1)\boldsymbol w} =\frac{\boldsymbol w^TS_b\boldsymbol w}{\boldsymbol w^TS_w\boldsymbol w}</script><pre><code>根据广义瑞利商的性质，矩阵 $S^&#123;-1&#125;_&#123;w&#125; S_b$ 的最大特征值为 $J(\boldsymbol w)$ 的最大值，矩阵 $S^&#123;-1&#125;_&#123;w&#125; S_b$ 的最大特征值对应的特征向量即为 $\boldsymbol w$。</code></pre><h3 id="2-14-4-LDA算法流程总结"><a href="#2-14-4-LDA算法流程总结" class="headerlink" title="2.14.4 LDA算法流程总结"></a>2.14.4 LDA算法流程总结</h3><p>LDA算法降维流程如下：</p><pre><code>输入：数据集 $D = \&#123; (x_1,y_1),(x_2,y_2), ... ,(x_m,y_m) \&#125;$，其中样本 $x_i $ 是n维向量，$y_i  \epsilon \&#123;C_1, C_2, ..., C_k\&#125;$，降维后的目标维度 $d$ 。输出：降维后的数据集 $\overline&#123;D&#125; $ 。</code></pre><p>步骤：</p><ol><li>计算类内散度矩阵 $S_w$。</li><li>计算类间散度矩阵 $S_b$ 。</li><li>计算矩阵 $S^{-1}_wS_b$ 。</li><li>计算矩阵 $S^{-1}_wS_b$ 的最大的 d 个特征值。</li><li>计算 d 个特征值对应的 d 个特征向量，记投影矩阵为 W 。</li><li>转化样本集的每个样本，得到新样本 $P_i = W^Tx_i$ 。</li><li>输出新样本集 $\overline{D} = \{ (p_1,y_1),(p_2,y_2),…,(p_m,y_m) \}$</li></ol><h3 id="2-14-5-LDA和PCA区别"><a href="#2-14-5-LDA和PCA区别" class="headerlink" title="2.14.5 LDA和PCA区别"></a>2.14.5 LDA和PCA区别</h3><div class="table-container"><table><thead><tr><th style="text-align:center">异同点</th><th style="text-align:left">LDA</th><th style="text-align:left">PCA</th></tr></thead><tbody><tr><td style="text-align:center">相同点</td><td style="text-align:left">1. 两者均可以对数据进行降维；<br>2. 两者在降维时均使用了矩阵特征分解的思想；<br>3. 两者都假设数据符合高斯分布；</td><td style="text-align:left"></td></tr><tr><td style="text-align:center">不同点</td><td style="text-align:left">有监督的降维方法；</td><td style="text-align:left">无监督的降维方法；</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">降维最多降到k-1维；</td><td style="text-align:left">降维多少没有限制；</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">可以用于降维，还可以用于分类；</td><td style="text-align:left">只用于降维；</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">选择分类性能最好的投影方向；</td><td style="text-align:left">选择样本点投影具有最大方差的方向；</td></tr><tr><td style="text-align:center"></td><td style="text-align:left">更明确，更能反映样本间差异；</td><td style="text-align:left">目的较为模糊；</td></tr></tbody></table></div><h3 id="2-14-6-LDA优缺点"><a href="#2-14-6-LDA优缺点" class="headerlink" title="2.14.6 LDA优缺点"></a>2.14.6 LDA优缺点</h3><div class="table-container"><table><thead><tr><th style="text-align:center">优缺点</th><th style="text-align:left">简要说明</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:left">1. 可以使用类别的先验知识；<br>2. 以标签、类别衡量差异性的有监督降维方式，相对于PCA的模糊性，其目的更明确，更能反映样本间的差异；</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:left">1. LDA不适合对非高斯分布样本进行降维；<br>2. LDA降维最多降到分类数k-1维；<br>3. LDA在样本分类信息依赖方差而不是均值时，降维效果不好；<br>4. LDA可能过度拟合数据。</td></tr></tbody></table></div><h2 id="2-15-主成分分析（PCA）"><a href="#2-15-主成分分析（PCA）" class="headerlink" title="2.15  主成分分析（PCA）"></a>2.15  主成分分析（PCA）</h2><h3 id="2-15-1-主成分分析（PCA）思想总结"><a href="#2-15-1-主成分分析（PCA）思想总结" class="headerlink" title="2.15.1 主成分分析（PCA）思想总结"></a>2.15.1 主成分分析（PCA）思想总结</h3><ol><li>PCA就是将高维的数据通过线性变换投影到低维空间上去。</li><li>投影思想：找出最能够代表原始数据的投影方法。被PCA降掉的那些维度只能是那些噪声或是冗余的数据。</li><li>去冗余：去除可以被其他向量代表的线性相关向量，这部分信息量是多余的。</li><li>去噪声，去除较小特征值对应的特征向量，特征值的大小反映了变换后在特征向量方向上变换的幅度，幅度越大，说明这个方向上的元素差异也越大，要保留。</li><li>对角化矩阵，寻找极大线性无关组，保留较大的特征值，去除较小特征值，组成一个投影矩阵，对原始样本矩阵进行投影，得到降维后的新样本矩阵。</li><li>完成PCA的关键是——协方差矩阵。协方差矩阵，能同时表现不同维度间的相关性以及各个维度上的方差。协方差矩阵度量的是维度与维度之间的关系，而非样本与样本之间。</li><li>之所以对角化，因为对角化之后非对角上的元素都是0，达到去噪声的目的。对角化后的协方差矩阵，对角线上较小的新方差对应的就是那些该去掉的维度。所以我们只取那些含有较大能量(特征值)的维度，其余的就舍掉，即去冗余。</li></ol><h3 id="2-15-2-图解PCA核心思想"><a href="#2-15-2-图解PCA核心思想" class="headerlink" title="2.15.2 图解PCA核心思想"></a>2.15.2 图解PCA核心思想</h3><pre><code>PCA可解决训练数据中存在数据特征过多或特征累赘的问题。核心思想是将m维特征映射到n维（n &lt; m），这n维形成主元，是重构出来最能代表原始数据的正交特征。假设数据集是m个n维，$(\boldsymbol x^&#123;(1)&#125;, \boldsymbol x^&#123;(2)&#125;, \cdots, \boldsymbol x^&#123;(m)&#125;)$。如果$n=2$，需要降维到$n&#39;=1$，现在想找到某一维度方向代表这两个维度的数据。下图有$u_1, u_2$两个向量方向，但是哪个向量才是我们所想要的，可以更好代表原始数据集的呢？</code></pre><p><img src="/p/16a6/ch2/2.34/1.png" alt></p><p>从图可看出，$u_1$比$u_2$好，为什么呢？有以下两个主要评价指标：</p><ol><li>样本点到这个直线的距离足够近。</li><li>样本点在这个直线上的投影能尽可能的分开。</li></ol><p>如果我们需要降维的目标维数是其他任意维，则：</p><ol><li>样本点到这个超平面的距离足够近。</li><li>样本点在这个超平面上的投影能尽可能的分开。</li></ol><h3 id="2-15-3-PCA算法推理"><a href="#2-15-3-PCA算法推理" class="headerlink" title="2.15.3 PCA算法推理"></a>2.15.3 PCA算法推理</h3><p>下面以基于最小投影距离为评价指标推理：</p><pre><code>假设数据集是m个n维，$(x^&#123;(1)&#125;, x^&#123;(2)&#125;,...,x^&#123;(m)&#125;)$，且数据进行了中心化。经过投影变换得到新坐标为 $&#123;w_1,w_2,...,w_n&#125;$，其中 $w$ 是标准正交基，即 $\| w \|_2 = 1$，$w^T_iw_j = 0$。经过降维后，新坐标为 $\&#123; w_1,w_2,...,w_n \&#125;$，其中 $n&#39;$ 是降维后的目标维数。样本点 $x^&#123;(i)&#125;$ 在新坐标系下的投影为 $z^&#123;(i)&#125; = \left(z^&#123;(i)&#125;_1, z^&#123;(i)&#125;_2, ..., z^&#123;(i)&#125;_&#123;n&#39;&#125;   \right)$，其中 $z^&#123;(i)&#125;_j = w^T_j x^&#123;(i)&#125;$ 是 $x^&#123;(i)&#125; $ 在低维坐标系里第 j 维的坐标。如果用 $z^&#123;(i)&#125; $ 去恢复 $x^&#123;(i)&#125; $ ，则得到的恢复数据为 $\widehat&#123;x&#125;^&#123;(i)&#125; = \sum^&#123;n&#39;&#125;_&#123;j=1&#125; x^&#123;(i)&#125;_j w_j = Wz^&#123;(i)&#125;$，其中 $W$为标准正交基组成的矩阵。考虑到整个样本集，样本点到这个超平面的距离足够近，目标变为最小化 $\sum^m_&#123;i=1&#125; \| \hat&#123;x&#125;^&#123;(i)&#125; - x^&#123;(i)&#125; \|^2_2$ 。对此式进行推理，可得：</code></pre><script type="math/tex; mode=display">\sum^m_{i=1} \| \hat{x}^{(i)} - x^{(i)} \|^2_2 =     \sum^m_{i=1} \| Wz^{(i)} - x^{(i)} \|^2_2 \\    = \sum^m_{i=1} \left( Wz^{(i)} \right)^T \left( Wz^{(i)} \right)    - 2\sum^m_{i=1} \left( Wz^{(i)} \right)^T x^{(i)}    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\    = \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)    - 2\sum^m_{i=1} \left( z^{(i)} \right)^T x^{(i)}    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\    = - \sum^m_{i=1} \left( z^{(i)} \right)^T \left( z^{(i)} \right)    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\    = -tr \left( W^T \left( \sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T \right)W \right)    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)} \\    = -tr \left( W^TXX^TW \right)    + \sum^m_{i=1} \left( x^{(i)} \right)^T x^{(i)}</script><pre><code>在推导过程中，分别用到了 $\overline&#123;x&#125;^&#123;(i)&#125; = Wz^&#123;(i)&#125;$ ，矩阵转置公式 $(AB)^T = B^TA^T$，$W^TW = I$，$z^&#123;(i)&#125; = W^Tx^&#123;(i)&#125;$ 以及矩阵的迹，最后两步是将代数和转为矩阵形式。由于 $W$ 的每一个向量 $w_j$ 是标准正交基，$\sum^m_&#123;i=1&#125; x^&#123;(i)&#125; \left(  x^&#123;(i)&#125; \right)^T$ 是数据集的协方差矩阵，$\sum^m_&#123;i=1&#125; \left(  x^&#123;(i)&#125; \right)^T x^&#123;(i)&#125; $ 是一个常量。最小化 $\sum^m_&#123;i=1&#125; \| \hat&#123;x&#125;^&#123;(i)&#125; - x^&#123;(i)&#125; \|^2_2$ 又可等价于</code></pre><script type="math/tex; mode=display">\underbrace{\arg \min}_W - tr \left( W^TXX^TW \right) s.t.W^TW = I</script><p>利用拉格朗日函数可得到</p><script type="math/tex; mode=display">J(W) = -tr(W^TXX^TW) + \lambda(W^TW - I)</script><pre><code>对 $W$ 求导，可得 $-XX^TW + \lambda W = 0 $ ，也即 $ XX^TW = \lambda W $ 。 $ XX^T $ 是 $ n&#39; $ 个特征向量组成的矩阵，$\lambda$ 为$ XX^T $ 的特征值。$W$ 即为我们想要的矩阵。对于原始数据，只需要 $z^&#123;(i)&#125; = W^TX^&#123;(i)&#125;$ ，就可把原始数据集降维到最小投影距离的 $n&#39;$ 维数据集。基于最大投影方差的推导，这里就不再赘述，有兴趣的同仁可自行查阅资料。</code></pre><h3 id="2-15-4-PCA算法流程总结"><a href="#2-15-4-PCA算法流程总结" class="headerlink" title="2.15.4 PCA算法流程总结"></a>2.15.4 PCA算法流程总结</h3><p>输入：$n$ 维样本集 $D = \left( x^{(1)},x^{(2)},…,x^{(m)} \right)$ ，目标降维的维数 $n’$ 。</p><p>输出：降维后的新样本集 $D’  = \left( z^{(1)},z^{(2)},…,z^{(m)} \right)$ 。</p><p>主要步骤如下：</p><ol><li>对所有的样本进行中心化，$ x^{(i)} = x^{(i)} - \frac{1}{m} \sum^m_{j=1} x^{(j)} $ 。</li><li>计算样本的协方差矩阵 $XX^T$ 。</li><li>对协方差矩阵 $XX^T$ 进行特征值分解。</li><li>取出最大的 $n’ $ 个特征值对应的特征向量 $\{ w_1,w_2,…,w_{n’} \}$ 。</li><li>标准化特征向量，得到特征向量矩阵 $W$ 。</li><li>转化样本集中的每个样本 $z^{(i)} = W^T x^{(i)}$ 。</li><li>得到输出矩阵 $D’ = \left( z^{(1)},z^{(2)},…,z^{(n)} \right)$ 。<br><em>注</em>：在降维时，有时不明确目标维数，而是指定降维到的主成分比重阈值 $k(k \epsilon(0,1])$ 。假设 $n$ 个特征值为 $\lambda_1 \geqslant \lambda_2 \geqslant … \geqslant \lambda_n$ ，则 $n’$ 可从 $\sum^{n’}_{i=1} \lambda_i \geqslant k \times \sum^n_{i=1} \lambda_i $ 得到。</li></ol><h3 id="2-15-5-PCA算法主要优缺点"><a href="#2-15-5-PCA算法主要优缺点" class="headerlink" title="2.15.5 PCA算法主要优缺点"></a>2.15.5 PCA算法主要优缺点</h3><div class="table-container"><table><thead><tr><th style="text-align:center">优缺点</th><th style="text-align:left">简要说明</th></tr></thead><tbody><tr><td style="text-align:center">优点</td><td style="text-align:left">1. 仅仅需要以方差衡量信息量，不受数据集以外的因素影响。　2.各主成分之间正交，可消除原始数据成分间的相互影响的因素。3. 计算方法简单，主要运算是特征值分解，易于实现。</td></tr><tr><td style="text-align:center">缺点</td><td style="text-align:left">1.主成分各个特征维度的含义具有一定的模糊性，不如原始样本特征的解释性强。2. 方差小的非主成分也可能含有对样本差异的重要信息，因降维丢弃可能对后续数据处理有影响。</td></tr></tbody></table></div><h3 id="2-15-6-降维的必要性及目的"><a href="#2-15-6-降维的必要性及目的" class="headerlink" title="2.15.6 降维的必要性及目的"></a>2.15.6 降维的必要性及目的</h3><p><strong>降维的必要性</strong>：</p><ol><li>多重共线性和预测变量之间相互关联。多重共线性会导致解空间的不稳定，从而可能导致结果的不连贯。</li><li>高维空间本身具有稀疏性。一维正态分布有68%的值落于正负标准差之间，而在十维空间上只有2%。</li><li>过多的变量，对查找规律造成冗余麻烦。</li><li>仅在变量层面上分析可能会忽略变量之间的潜在联系。例如几个预测变量可能落入仅反映数据某一方面特征的一个组内。</li></ol><p><strong>降维的目的</strong>：</p><ol><li>减少预测变量的个数。</li><li>确保这些变量是相互独立的。</li><li>提供一个框架来解释结果。相关特征，特别是重要特征更能在数据中明确的显示出来；如果只有两维或者三维的话，更便于可视化展示。</li><li>数据在低维下更容易处理、更容易使用。</li><li>去除数据噪声。</li><li>降低算法运算开销。</li></ol><h3 id="2-15-7-KPCA与PCA的区别"><a href="#2-15-7-KPCA与PCA的区别" class="headerlink" title="2.15.7 KPCA与PCA的区别"></a>2.15.7 KPCA与PCA的区别</h3><pre><code>应用PCA算法前提是假设存在一个线性超平面，进而投影。那如果数据不是线性的呢？该怎么办？这时候就需要KPCA，数据集从 $n$ 维映射到线性可分的高维 $N &gt;n$，然后再从 $N$ 维降维到一个低维度 $n&#39;(n&#39;&lt;n&lt;N)$ 。KPCA用到了核函数思想，使用了核函数的主成分分析一般称为核主成分分析(Kernelized PCA, 简称KPCA）。</code></pre><p>假设高维空间数据由 $n$ 维空间的数据通过映射 $\phi$ 产生。</p><pre><code>$n$ 维空间的特征分解为：</code></pre><script type="math/tex; mode=display">\sum^m_{i=1} x^{(i)} \left( x^{(i)} \right)^T W = \lambda W</script><pre><code>其映射为</code></pre><script type="math/tex; mode=display">\sum^m_{i=1} \phi \left( x^{(i)} \right) \phi \left( x^{(i)} \right)^T W = \lambda W</script><pre><code>通过在高维空间进行协方差矩阵的特征值分解，然后用和PCA一样的方法进行降维。由于KPCA需要核函数的运算，因此它的计算量要比PCA大很多。</code></pre><h2 id="2-16-模型评估"><a href="#2-16-模型评估" class="headerlink" title="2.16 模型评估"></a>2.16 模型评估</h2><h3 id="2-16-1-模型评估常用方法？"><a href="#2-16-1-模型评估常用方法？" class="headerlink" title="2.16.1 模型评估常用方法？"></a>2.16.1 模型评估常用方法？</h3><pre><code>一般情况来说，单一评分标准无法完全评估一个机器学习模型。只用good和bad偏离真实场景去评估某个模型，都是一种欠妥的评估方式。下面介绍常用的分类模型和回归模型评估方法。</code></pre><p><strong>分类模型常用评估方法：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">指标</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Accuracy</td><td style="text-align:center">准确率</td></tr><tr><td style="text-align:center">Precision</td><td style="text-align:center">精准度/查准率</td></tr><tr><td style="text-align:center">Recall</td><td style="text-align:center">召回率/查全率</td></tr><tr><td style="text-align:center">P-R曲线</td><td style="text-align:center">查准率为纵轴，查全率为横轴，作图</td></tr><tr><td style="text-align:center">F1</td><td style="text-align:center">F1值</td></tr><tr><td style="text-align:center">Confusion Matrix</td><td style="text-align:center">混淆矩阵</td></tr><tr><td style="text-align:center">ROC</td><td style="text-align:center">ROC曲线</td></tr><tr><td style="text-align:center">AUC</td><td style="text-align:center">ROC曲线下的面积</td></tr></tbody></table></div><p><strong>回归模型常用评估方法：</strong></p><div class="table-container"><table><thead><tr><th style="text-align:center">指标</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">Mean Square Error (MSE, RMSE)</td><td style="text-align:center">平均方差</td></tr><tr><td style="text-align:center">Absolute Error (MAE, RAE)</td><td style="text-align:center">绝对误差</td></tr><tr><td style="text-align:center">R-Squared</td><td style="text-align:center">R平方值</td></tr></tbody></table></div><h3 id="2-16-2-误差、偏差和方差有什么区别和联系"><a href="#2-16-2-误差、偏差和方差有什么区别和联系" class="headerlink" title="2.16.2 误差、偏差和方差有什么区别和联系"></a>2.16.2 误差、偏差和方差有什么区别和联系</h3><p>在机器学习中，Bias(偏差)，Error(误差)，和Variance(方差)存在以下区别和联系：</p><p><strong>对于Error </strong>：</p><ul><li><p>误差（error）：一般地，我们把学习器的实际预测输出与样本的真是输出之间的差异称为“误差”。</p></li><li><p>Error = Bias + Variance + Noise，Error反映的是整个模型的准确度。</p></li></ul><p><strong>对于Noise:</strong></p><p>噪声：描述了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p><p><strong>对于Bias：</strong></p><ul><li>Bias衡量模型拟合训练数据的能力（训练数据不一定是整个 training dataset，而是只用于训练它的那一部分数据，例如：mini-batch），Bias反映的是模型在样本上的输出与真实值之间的误差，即模型本身的精准度。</li><li>Bias 越小，拟合能力越高（可能产生overfitting）；反之，拟合能力越低（可能产生underfitting）。</li><li>偏差越大，越偏离真实数据，如下图第二行所示。</li></ul><p><strong>对于Variance：</strong></p><ul><li><p>方差公式：$S_{N}^{2}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}$</p></li><li><p>Variance描述的是预测值的变化范围，离散程度，也就是离其期望值的距离。方差越大，数据的分布越分散，模型的稳定程度越差。</p></li><li>Variance反映的是模型每一次输出结果与模型输出期望之间的误差，即模型的稳定性。</li><li>Variance越小，模型的泛化的能力越高；反之，模型的泛化的能力越低。</li><li>如果模型在训练集上拟合效果比较优秀，但是在测试集上拟合效果比较差劣，则方差较大，说明模型的稳定程度较差，出现这种现象可能是由于模型对训练集过拟合造成的。 如下图右列所示。</li></ul><blockquote><p><img src="/p/16a6/ch2/2.16.20.1.png" alt></p></blockquote><h3 id="2-16-3-经验误差与泛化误差"><a href="#2-16-3-经验误差与泛化误差" class="headerlink" title="2.16.3 经验误差与泛化误差"></a>2.16.3 经验误差与泛化误差</h3><p>经验误差（empirical error）：也叫训练误差（training error），模型在训练集上的误差。 </p><p>泛化误差（generalization error）：模型在新样本集（测试集）上的误差称为“泛化误差”。</p><h3 id="2-16-4-图解欠拟合、过拟合"><a href="#2-16-4-图解欠拟合、过拟合" class="headerlink" title="2.16.4 图解欠拟合、过拟合"></a>2.16.4 图解欠拟合、过拟合</h3><p>根据不同的坐标方式，欠拟合与过拟合图解不同。</p><ol><li><strong>横轴为训练样本数量，纵轴为误差</strong></li></ol><p><img src="/p/16a6/ch2/2.16.4.1.jpg" alt></p><p>如上图所示，我们可以直观看出欠拟合和过拟合的区别：</p><pre><code>模型欠拟合：在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大；模型过拟合：在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。模型正常：在训练集以及测试集上，同时具有相对较低的偏差以及方差。</code></pre><ol><li><strong>横轴为模型复杂程度，纵轴为误差</strong></li></ol><p><img src="/p/16a6/ch2/2.16.4.2.png" alt></p><pre><code>                红线为测试集上的Error,蓝线为训练集上的Error模型欠拟合：模型在点A处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。模型过拟合：模型在点C处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。 模型正常：模型复杂程度控制在点B处为最优。</code></pre><ol><li><strong>横轴为正则项系数，纵轴为误差</strong></li></ol><p><img src="/p/16a6/ch2/2.16.4.3.png" alt></p><pre><code>                                         红线为测试集上的Error,蓝线为训练集上的Error模型欠拟合：模型在点C处，在训练集以及测试集上同时具有较高的误差，此时模型的偏差较大。模型过拟合：模型在点A处，在训练集上具有较低的误差，在测试集上具有较高的误差，此时模型的方差较大。 它通常发生在模型过于复杂的情况下，如参数过多等，会使得模型的预测性能变弱，并且增加数据的波动性。虽然模型在训练时的效果可以表现的很完美，基本上记住了数据的全部特点，但这种模型在未知数据的表现能力会大减折扣，因为简单的模型泛化能力通常都是很弱的。模型正常：模型复杂程度控制在点B处为最优。</code></pre><h3 id="2-16-5-如何解决过拟合与欠拟合"><a href="#2-16-5-如何解决过拟合与欠拟合" class="headerlink" title="2.16.5 如何解决过拟合与欠拟合"></a>2.16.5 如何解决过拟合与欠拟合</h3><p><strong>如何解决欠拟合：</strong></p><ol><li>添加其他特征项。组合、泛化、相关性、上下文特征、平台特征等特征是特征添加的重要手段，有时候特征项不够会导致模型欠拟合。</li><li>添加多项式特征。例如将线性模型添加二次项或三次项使模型泛化能力更强。例如，FM（Factorization Machine）模型、FFM（Field-aware Factorization Machine）模型，其实就是线性模型，增加了二阶多项式，保证了模型一定的拟合程度。</li><li>可以增加模型的复杂程度。</li><li>减小正则化系数。正则化的目的是用来防止过拟合的，但是现在模型出现了欠拟合，则需要减少正则化参数。</li></ol><p><strong>如何解决过拟合：</strong></p><ol><li>重新清洗数据，数据不纯会导致过拟合，此类情况需要重新清洗数据。 </li><li>增加训练样本数量。 </li><li>降低模型复杂程度。 </li><li>增大正则项系数。 </li><li>采用dropout方法，dropout方法，通俗的讲就是在训练的时候让神经元以一定的概率不工作。 </li><li>early stopping。 </li><li>减少迭代次数。 </li><li>增大学习率。 </li><li>添加噪声数据。 </li><li>树结构中，可以对树进行剪枝。 </li><li>减少特征项。</li></ol><p>欠拟合和过拟合这些方法，需要根据实际问题，实际模型，进行选择。</p><h3 id="2-16-6-交叉验证的主要作用"><a href="#2-16-6-交叉验证的主要作用" class="headerlink" title="2.16.6 交叉验证的主要作用"></a>2.16.6 交叉验证的主要作用</h3><pre><code>为了得到更为稳健可靠的模型，对模型的泛化误差进行评估，得到模型泛化误差的近似值。当有多个模型可以选择时，我们通常选择“泛化误差”最小的模型。 交叉验证的方法有许多种，但是最常用的是：留一交叉验证、k折交叉验证。</code></pre><h3 id="2-16-7-理解k折交叉验证"><a href="#2-16-7-理解k折交叉验证" class="headerlink" title="2.16.7 理解k折交叉验证"></a>2.16.7 理解k折交叉验证</h3><ol><li>将含有N个样本的数据集，分成K份，每份含有N/K个样本。选择其中1份作为测试集，另外K-1份作为训练集，测试集就有K种情况。 </li><li>在每种情况中，用训练集训练模型，用测试集测试模型，计算模型的泛化误差。 </li><li>交叉验证重复K次，每份验证一次，平均K次的结果或者使用其它结合方式，最终得到一个单一估测，得到模型最终的泛化误差。 </li><li>将K种情况下，模型的泛化误差取均值，得到模型最终的泛化误差。  </li><li>一般$2\leqslant K \leqslant10$。 k折交叉验证的优势在于，同时重复运用随机产生的子样本进行训练和验证，每次的结果验证一次，10折交叉验证是最常用的。 </li><li>训练集中样本数量要足够多，一般至少大于总样本数的50%。 </li><li>训练集和测试集必须从完整的数据集中均匀取样。均匀取样的目的是希望减少训练集、测试集与原数据集之间的偏差。当样本数量足够多时，通过随机取样，便可以实现均匀取样的效果。 </li></ol><h3 id="2-16-8-混淆矩阵"><a href="#2-16-8-混淆矩阵" class="headerlink" title="2.16.8 混淆矩阵"></a>2.16.8 混淆矩阵</h3><p>第一种混淆矩阵:</p><div class="table-container"><table><thead><tr><th style="text-align:center">真实情况T or F</th><th style="text-align:left">预测为正例1，P</th><th style="text-align:left">预测为负例0，N</th></tr></thead><tbody><tr><td style="text-align:center">本来label标记为1，预测结果真为T、假为F</td><td style="text-align:left">TP(预测为1，实际为1)</td><td style="text-align:left">FN(预测为0，实际为1)</td></tr><tr><td style="text-align:center">本来label标记为0，预测结果真为T、假为F</td><td style="text-align:left">FP(预测为1，实际为0)</td><td style="text-align:left">TN(预测为0，实际也为0)</td></tr></tbody></table></div><p>第二种混淆矩阵:</p><div class="table-container"><table><thead><tr><th style="text-align:center">预测情况P or N</th><th style="text-align:left">实际label为1,预测对了为T</th><th style="text-align:left">实际label为0,预测对了为T</th></tr></thead><tbody><tr><td style="text-align:center">预测为正例1，P</td><td style="text-align:left">TP(预测为1，实际为1)</td><td style="text-align:left">FP(预测为1，实际为0)</td></tr><tr><td style="text-align:center">预测为负例0，N</td><td style="text-align:left">FN(预测为0，实际为1)</td><td style="text-align:left">TN(预测为0，实际也为0)</td></tr></tbody></table></div><h3 id="2-16-9-错误率及精度"><a href="#2-16-9-错误率及精度" class="headerlink" title="2.16.9 错误率及精度"></a>2.16.9 错误率及精度</h3><ol><li>错误率（Error Rate）：分类错误的样本数占样本总数的比例。</li><li>精度（accuracy）：分类正确的样本数占样本总数的比例。</li></ol><h3 id="2-16-10-查准率与查全率"><a href="#2-16-10-查准率与查全率" class="headerlink" title="2.16.10 查准率与查全率"></a>2.16.10 查准率与查全率</h3><p>将算法预测的结果分成四种情况： </p><ol><li>正确肯定（True Positive,TP）：预测为真，实际为真 </li><li>正确否定（True Negative,TN）：预测为假，实际为假 </li><li>错误肯定（False Positive,FP）：预测为真，实际为假 </li><li>错误否定（False Negative,FN）：预测为假，实际为真</li></ol><p>则： </p><p>查准率（Precision）=TP/（TP+FP）</p><p><strong>理解</strong>：预测出为阳性的样本中，正确的有多少。区别准确率（正确预测出的样本，包括正确预测为阳性、阴性，占总样本比例）。<br>例，在所有我们预测有恶性肿瘤的病人中，实际上有恶性肿瘤的病人的百分比，越高越好。 </p><p>查全率（Recall）=TP/（TP+FN）</p><p><strong>理解</strong>：正确预测为阳性的数量占总样本中阳性数量的比例。<br>例，在所有实际上有恶性肿瘤的病人中，成功预测有恶性肿瘤的病人的百分比，越高越好。 </p><h3 id="2-16-11-ROC与AUC"><a href="#2-16-11-ROC与AUC" class="headerlink" title="2.16.11 ROC与AUC"></a>2.16.11 ROC与AUC</h3><pre><code>ROC全称是“受试者工作特征”（Receiver Operating Characteristic）。ROC曲线的面积就是AUC（Area Under Curve）。AUC用于衡量“二分类问题”机器学习算法性能（泛化能力）。ROC曲线，通过将连续变量设定出多个不同的临界值，从而计算出一系列真正率和假正率，再以假正率为横坐标、真正率为纵坐标绘制成曲线，曲线下面积越大，推断准确性越高。在ROC曲线上，最靠近坐标图左上方的点为假正率和真正率均较高的临界值。 对于分类器，或者说分类算法，评价指标主要有Precision，Recall，F-score。下图是一个ROC曲线的示例。</code></pre><p><img src="/p/16a6/ch2/2.40.10/1.png" alt></p><p>ROC曲线的横坐标为False Positive Rate（FPR），纵坐标为True Positive Rate（TPR）。其中</p><script type="math/tex; mode=display">TPR = \frac{TP}{TP+FN} ,FPR = \frac{FP}{FP+TN}</script><pre><code>下面着重介绍ROC曲线图中的四个点和一条线。第一个点(0,1)，即FPR=0, TPR=1，这意味着FN（False Negative）=0，并且FP（False Positive）=0。意味着这是一个完美的分类器，它将所有的样本都正确分类。第二个点(1,0)，即FPR=1，TPR=0，意味着这是一个最糟糕的分类器，因为它成功避开了所有的正确答案。第三个点(0,0)，即FPR=TPR=0，即FP（False Positive）=TP（True Positive）=0，可以发现该分类器预测所有的样本都为负样本（Negative）。第四个点(1,1)，即FPR=TPR=1，分类器实际上预测所有的样本都为正样本。经过以上分析，ROC曲线越接近左上角，该分类器的性能越好。ROC曲线所覆盖的面积称为AUC（Area Under Curve），可以更直观的判断学习器的性能，AUC越大则性能越好。  </code></pre><h3 id="2-16-12-如何画ROC曲线"><a href="#2-16-12-如何画ROC曲线" class="headerlink" title="2.16.12 如何画ROC曲线"></a>2.16.12 如何画ROC曲线</h3><pre><code>下图是一个示例，图中共有20个测试样本，“Class”一栏表示每个测试样本真正的标签（p表示正样本，n表示负样本），“Score”表示每个测试样本属于正样本的概率。</code></pre><p>步骤：<br>    1、假设已经得出一系列样本被划分为正类的概率，按照大小排序。<br>    2、从高到低，依次将“Score”值作为阈值threshold，当测试样本属于正样本的概率大于或等于这个threshold时，我们认为它为正样本，否则为负样本。举例来说，对于图中的第4个样本，其“Score”值为0.6，那么样本1，2，3，4都被认为是正样本，因为它们的“Score”值都大于等于0.6，而其他样本则都认为是负样本。<br>    3、每次选取一个不同的threshold，得到一组FPR和TPR，即ROC曲线上的一点。以此共得到20组FPR和TPR的值。<br>    4、根据3、中的每个坐标点，画图。</p><p><img src="/p/16a6/ch2/2.40.11/1.jpg" alt></p><h3 id="2-16-13-如何计算TPR，FPR"><a href="#2-16-13-如何计算TPR，FPR" class="headerlink" title="2.16.13 如何计算TPR，FPR"></a>2.16.13 如何计算TPR，FPR</h3><p>1、分析数据<br>y_true = [0, 0, 1, 1]；scores = [0.1, 0.4, 0.35, 0.8]；<br>2、列表</p><div class="table-container"><table><thead><tr><th>样本</th><th>预测属于P的概率(score)</th><th>真实类别</th></tr></thead><tbody><tr><td>y[0]</td><td>0.1</td><td>N</td></tr><tr><td>y[1]</td><td>0.4</td><td>N</td></tr><tr><td>y[2]</td><td>0.35</td><td>P</td></tr><tr><td>y[3]</td><td>0.8</td><td>P</td></tr></tbody></table></div><p>3、将截断点依次取为score值，计算TPR和FPR。<br>当截断点为0.1时：<br>说明只要score&gt;=0.1，它的预测类别就是正例。 因为4个样本的score都大于等于0.1，所以，所有样本的预测类别都为P。<br>scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [1, 1, 1, 1]；<br>正例与反例信息如下：</p><div class="table-container"><table><thead><tr><th></th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td><strong>正例</strong></td><td>TP=2</td><td>FN=0</td></tr><tr><td><strong>反例</strong></td><td>FP=2</td><td>TN=0</td></tr></tbody></table></div><p>由此可得：<br>TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 1；</p><p>当截断点为0.35时：<br>scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 1, 1];<br>正例与反例信息如下：</p><div class="table-container"><table><thead><tr><th></th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td><strong>正例</strong></td><td>TP=2</td><td>FN=0</td></tr><tr><td><strong>反例</strong></td><td>FP=1</td><td>TN=1</td></tr></tbody></table></div><p>由此可得：<br>TPR = TP/(TP+FN) = 1； FPR = FP/(TN+FP) = 0.5；</p><p>当截断点为0.4时：<br>scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 1, 0, 1]；<br>正例与反例信息如下：</p><div class="table-container"><table><thead><tr><th></th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td><strong>正例</strong></td><td>TP=1</td><td>FN=1</td></tr><tr><td><strong>反例</strong></td><td>FP=1</td><td>TN=1</td></tr></tbody></table></div><p>由此可得：<br>TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0.5；</p><p>当截断点为0.8时：<br>scores = [0.1, 0.4, 0.35, 0.8]；y_true = [0, 0, 1, 1]；y_pred = [0, 0, 0, 1]；</p><p>正例与反例信息如下：</p><div class="table-container"><table><thead><tr><th></th><th>正例</th><th>反例</th></tr></thead><tbody><tr><td><strong>正例</strong></td><td>TP=1</td><td>FN=1</td></tr><tr><td><strong>反例</strong></td><td>FP=0</td><td>TN=2</td></tr></tbody></table></div><p>由此可得：<br>TPR = TP/(TP+FN) = 0.5； FPR = FP/(TN+FP) = 0；</p><p>4、根据TPR、FPR值，以FPR为横轴，TPR为纵轴画图。</p><h3 id="2-16-14-如何计算AUC"><a href="#2-16-14-如何计算AUC" class="headerlink" title="2.16.14 如何计算AUC"></a>2.16.14 如何计算AUC</h3><ul><li>将坐标点按照横坐标FPR排序 。</li><li>计算第$i$个坐标点和第$i+1$个坐标点的间距$dx$ 。 </li><li>获取第$i$或者$i+1$个坐标点的纵坐标y。</li><li>计算面积微元$ds=ydx$。</li><li>对面积微元进行累加，得到AUC。</li></ul><h3 id="2-16-15-为什么使用Roc和Auc评价分类器"><a href="#2-16-15-为什么使用Roc和Auc评价分类器" class="headerlink" title="2.16.15 为什么使用Roc和Auc评价分类器"></a>2.16.15 为什么使用Roc和Auc评价分类器</h3><pre><code>模型有很多评估方法，为什么还要使用ROC和AUC呢？因为ROC曲线有个很好的特性：当测试集中的正负样本的分布变换的时候，ROC曲线能够保持不变。在实际的数据集中经常会出现样本类不平衡，即正负样本比例差距较大，而且测试数据中的正负样本也可能随着时间变化。</code></pre><h3 id="2-16-16-直观理解AUC"><a href="#2-16-16-直观理解AUC" class="headerlink" title="2.16.16 直观理解AUC"></a>2.16.16 直观理解AUC</h3><pre><code>下图展现了三种AUC的值： </code></pre><p><img src="/p/16a6/ch2/2.40.15/1.png" alt></p><pre><code>AUC是衡量二分类模型优劣的一种评价指标，表示正例排在负例前面的概率。其他评价指标有精确度、准确率、召回率，而AUC比这三者更为常用。一般在分类模型中，预测结果都是以概率的形式表现，如果要计算准确率，通常都会手动设置一个阈值来将对应的概率转化成类别，这个阈值也就很大程度上影响了模型准确率的计算。举例：现在假设有一个训练好的二分类器对10个正负样本（正例5个，负例5个）预测，得分按高到低排序得到的最好预测结果为[1, 1, 1, 1, 1, 0, 0, 0, 0, 0]，即5个正例均排在5个负例前面，正例排在负例前面的概率为100%。然后绘制其ROC曲线，由于是10个样本，除去原点我们需要描10个点，如下：</code></pre><p><img src="/p/16a6/ch2/2.16.17-1.png" alt></p><pre><code>描点方式按照样本预测结果的得分高低从左至右开始遍历。从原点开始，每遇到1便向y轴正方向移动y轴最小步长1个单位，这里是1/5=0.2；每遇到0则向x轴正方向移动x轴最小步长1个单位，这里也是0.2。不难看出，上图的AUC等于1，印证了正例排在负例前面的概率的确为100%。假设预测结果序列为[1, 1, 1, 1, 0, 1, 0, 0, 0, 0]。</code></pre><p><img src="/p/16a6/ch2/2.16.17-2.png" alt></p><pre><code>计算上图的AUC为0.96与计算正例与排在负例前面的概率0.8 × 1 + 0.2 × 0.8 = 0.96相等，而左上角阴影部分的面积则是负例排在正例前面的概率0.2 × 0.2 = 0.04。假设预测结果序列为[1, 1, 1, 0, 1, 0, 1, 0, 0, 0]。</code></pre><p><img src="/p/16a6/ch2/2.16.17-3.png" alt></p><pre><code>计算上图的AUC为0.88与计算正例与排在负例前面的概率0.6 × 1 + 0.2 × 0.8 + 0.2 × 0.6 = 0.88相等，左上角阴影部分的面积是负例排在正例前面的概率0.2 × 0.2 × 3 = 0.12。</code></pre><h3 id="2-16-17-代价敏感错误率与代价曲线"><a href="#2-16-17-代价敏感错误率与代价曲线" class="headerlink" title="2.16.17 代价敏感错误率与代价曲线"></a>2.16.17 代价敏感错误率与代价曲线</h3><p>不同的错误会产生不同代价。以二分法为例，设置代价矩阵如下：</p><p><img src="/p/16a6/ch2/2-1.png" alt></p><p>当判断正确的时候，值为0，不正确的时候，分别为$Cost_{01}$和$Cost_{10}$ 。</p><p>$Cost_{10}$:表示实际为反例但预测成正例的代价。</p><p>$Cost_{01}$:表示实际为正例但是预测为反例的代价。</p><p><strong>代价敏感错误率</strong>=样本中由模型得到的错误值与代价乘积之和 / 总样本。<br>其数学表达式为：</p><script type="math/tex; mode=display">E(f;D;cost)=\frac{1}{m}\left( \sum_{x_{i} \in D^{+}}({f(x_i)\neq y_i})\times Cost_{01}+ \sum_{x_{i} \in D^{-}}({f(x_i)\neq y_i})\times Cost_{10}\right)</script><p>$D^{+}、D^{-}$分别代表样例集的正例子集和反例子集，x是预测值，y是真实值。</p><p><strong>代价曲线</strong>：<br>    在均等代价时，ROC曲线不能直接反应出模型的期望总体代价，而代价曲线可以。<br>代价曲线横轴为[0,1]的正例函数代价：</p><script type="math/tex; mode=display">P(+)Cost=\frac{p*Cost_{01}}{p*Cost_{01}+(1-p)*Cost_{10}}</script><p>其中p是样本为正例的概率。</p><p>代价曲线纵轴维[0,1]的归一化代价：</p><script type="math/tex; mode=display">Cost_{norm}=\frac{FNR*p*Cost_{01}+FNR*(1-p)*Cost_{10}}{p*Cost_{01}+(1-p)*Cost_{10}}</script><p>其中FPR为假阳率，FNR=1-TPR为假阴率。</p><p>注：ROC每个点，对应代价平面上一条线。</p><p>例如，ROC上(TPR,FPR),计算出FNR=1-TPR，在代价平面上绘制一条从(0,FPR)到(1,FNR)的线段，面积则为该条件下期望的总体代价。所有线段下界面积，所有条件下学习器的期望总体代价。</p><p><img src="/p/16a6/ch2/2.16.18.1.png" alt></p><h3 id="2-16-18-模型有哪些比较检验方法"><a href="#2-16-18-模型有哪些比较检验方法" class="headerlink" title="2.16.18 模型有哪些比较检验方法"></a>2.16.18 模型有哪些比较检验方法</h3><p>正确性分析：模型稳定性分析，稳健性分析，收敛性分析，变化趋势分析，极值分析等。<br>有效性分析：误差分析，参数敏感性分析，模型对比检验等。<br>有用性分析：关键数据求解，极值点，拐点，变化趋势分析，用数据验证动态模拟等。<br>高效性分析：时空复杂度分析与现有进行比较等。</p><h3 id="2-16-19-为什么使用标准差"><a href="#2-16-19-为什么使用标准差" class="headerlink" title="2.16.19 为什么使用标准差"></a>2.16.19 为什么使用标准差</h3><p>方差公式为：$S^2_{N}=\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}$</p><p>标准差公式为：$S_{N}=\sqrt{\frac{1}{N}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}$</p><p>样本标准差公式为：$S_{N}=\sqrt{\frac{1}{N-1}\sum_{i=1}^{N}(x_{i}-\bar{x})^{2}}$</p><p>与方差相比，使用标准差来表示数据点的离散程度有3个好处：<br>1、表示离散程度的数字与样本数据点的数量级一致，更适合对数据样本形成感性认知。</p><p>2、表示离散程度的数字单位与样本数据的单位一致，更方便做后续的分析运算。</p><p>3、在样本数据大致符合正态分布的情况下，标准差具有方便估算的特性：68%的数据点落在平均值前后1个标准差的范围内、95%的数据点落在平均值前后2个标准差的范围内，而99%的数据点将会落在平均值前后3个标准差的范围内。</p><h3 id="2-16-20-类别不平衡产生原因"><a href="#2-16-20-类别不平衡产生原因" class="headerlink" title="2.16.20 类别不平衡产生原因"></a>2.16.20 类别不平衡产生原因</h3><pre><code>类别不平衡（class-imbalance）是指分类任务中不同类别的训练样例数目差别很大的情况。 </code></pre><p>产生原因：</p><pre><code>分类学习算法通常都会假设不同类别的训练样例数目基本相同。如果不同类别的训练样例数目差别很大，则会影响学习结果，测试结果变差。例如二分类问题中有998个反例，正例有2个，那学习方法只需返回一个永远将新样本预测为反例的分类器，就能达到99.8%的精度；然而这样的分类器没有价值。</code></pre><h3 id="2-16-21-常见的类别不平衡问题解决方法"><a href="#2-16-21-常见的类别不平衡问题解决方法" class="headerlink" title="2.16.21 常见的类别不平衡问题解决方法"></a>2.16.21 常见的类别不平衡问题解决方法</h3><p>  防止类别不平衡对学习造成的影响，在构建分类模型之前，需要对分类不平衡性问题进行处理。主要解决方法有：</p><p>1、扩大数据集</p><pre><code>增加包含小类样本数据的数据，更多的数据能得到更多的分布信息。</code></pre><p>2、对大类数据欠采样</p><pre><code>减少大类数据样本个数，使与小样本个数接近。缺点：欠采样操作时若随机丢弃大类样本，可能会丢失重要信息。 代表算法：EasyEnsemble。其思想是利用集成学习机制，将大类划分为若干个集合供不同的学习器使用。相当于对每个学习器都进行欠采样，但对于全局则不会丢失重要信息。</code></pre><p>3、对小类数据过采样</p><pre><code>过采样：对小类的数据样本进行采样来增加小类的数据样本个数。 代表算法：SMOTE和ADASYN。 SMOTE：通过对训练集中的小类数据进行插值来产生额外的小类样本数据。新的少数类样本产生的策略：对每个少数类样本a，在a的最近邻中随机选一个样本b，然后在a、b之间的连线上随机选一点作为新合成的少数类样本。     ADASYN：根据学习难度的不同，对不同的少数类别的样本使用加权分布，对于难以学习的少数类的样本，产生更多的综合数据。 通过减少类不平衡引入的偏差和将分类决策边界自适应地转移到困难的样本两种手段，改善了数据分布。</code></pre><p>4、使用新评价指标</p><pre><code>如果当前评价指标不适用，则应寻找其他具有说服力的评价指标。比如准确度这个评价指标在类别不均衡的分类任务中并不适用，甚至进行误导。因此在类别不均衡分类任务中，需要使用更有说服力的评价指标来对分类器进行评价。</code></pre><p>5、选择新算法</p><pre><code>不同的算法适用于不同的任务与数据，应该使用不同的算法进行比较。</code></pre><p>6、数据代价加权</p><pre><code>例如当分类任务是识别小类，那么可以对分类器的小类样本数据增加权值，降低大类样本的权值，从而使得分类器将重点集中在小类样本身上。</code></pre><p>7、转化问题思考角度</p><pre><code>例如在分类问题时，把小类的样本作为异常点，将问题转化为异常点检测或变化趋势检测问题。 异常点检测即是对那些罕见事件进行识别。变化趋势检测区别于异常点检测在于其通过检测不寻常的变化趋势来识别。    </code></pre><p>8、将问题细化分析</p><pre><code>对问题进行分析与挖掘，将问题划分成多个更小的问题，看这些小问题是否更容易解决。 </code></pre><h2 id="2-17-决策树"><a href="#2-17-决策树" class="headerlink" title="2.17 决策树"></a>2.17 决策树</h2><h3 id="2-17-1-决策树的基本原理"><a href="#2-17-1-决策树的基本原理" class="headerlink" title="2.17.1 决策树的基本原理"></a>2.17.1 决策树的基本原理</h3><pre><code>决策树（Decision Tree）是一种分而治之的决策过程。一个困难的预测问题，通过树的分支节点，被划分成两个或多个较为简单的子集，从结构上划分为不同的子问题。将依规则分割数据集的过程不断递归下去（Recursive Partitioning）。随着树的深度不断增加，分支节点的子集越来越小，所需要提的问题数也逐渐简化。当分支节点的深度或者问题的简单程度满足一定的停止规则（Stopping Rule）时, 该分支节点会停止分裂，此为自上而下的停止阈值（Cutoff Threshold）法；有些决策树也使用自下而上的剪枝（Pruning）法。</code></pre><h3 id="2-17-2-决策树的三要素？"><a href="#2-17-2-决策树的三要素？" class="headerlink" title="2.17.2 决策树的三要素？"></a>2.17.2 决策树的三要素？</h3><pre><code>一棵决策树的生成过程主要分为下3个部分：  1、特征选择：从训练数据中众多的特征中选择一个特征作为当前节点的分裂标准，如何选择特征有着很多不同量化评估标准，从而衍生出不同的决策树算法。 2、决策树生成：根据选择的特征评估标准，从上至下递归地生成子节点，直到数据集不可分则决策树停止生长。树结构来说，递归结构是最容易理解的方式。 3、剪枝：决策树容易过拟合，一般来需要剪枝，缩小树结构规模、缓解过拟合。剪枝技术有预剪枝和后剪枝两种。</code></pre><h3 id="2-17-3-决策树学习基本算法"><a href="#2-17-3-决策树学习基本算法" class="headerlink" title="2.17.3 决策树学习基本算法"></a>2.17.3 决策树学习基本算法</h3><p><img src="/p/16a6/ch2/2-5.png" alt></p><h3 id="2-17-4-决策树算法优缺点"><a href="#2-17-4-决策树算法优缺点" class="headerlink" title="2.17.4 决策树算法优缺点"></a>2.17.4 决策树算法优缺点</h3><p><strong>决策树算法的优点</strong>：  </p><p>1、决策树算法易理解，机理解释起来简单。 </p><p>2、决策树算法可以用于小数据集。</p><p>3、决策树算法的时间复杂度较小，为用于训练决策树的数据点的对数。</p><p>4、相比于其他算法智能分析一种类型变量，决策树算法可处理数字和数据的类别。</p><p>5、能够处理多输出的问题。 </p><p>6、对缺失值不敏感。</p><p>7、可以处理不相关特征数据。</p><p>8、效率高，决策树只需要一次构建，反复使用，每一次预测的最大计算次数不超过决策树的深度。</p><p><strong>决策树算法的缺点</strong>： </p><p>1、对连续性的字段比较难预测。</p><p>2、容易出现过拟合。</p><p>3、当类别太多时，错误可能就会增加的比较快。</p><p>4、在处理特征关联性比较强的数据时表现得不是太好。</p><p>5、对于各类别样本数量不一致的数据，在决策树当中，信息增益的结果偏向于那些具有更多数值的特征。</p><h3 id="2-17-5-熵的概念以及理解"><a href="#2-17-5-熵的概念以及理解" class="headerlink" title="2.17.5 熵的概念以及理解"></a>2.17.5 熵的概念以及理解</h3><pre><code>熵：度量随机变量的不确定性。  定义：假设随机变量X的可能取值有$x_&#123;1&#125;,x_&#123;2&#125;,...,x_&#123;n&#125;$，对于每一个可能的取值$x_&#123;i&#125;$，其概率为$P(X=x_&#123;i&#125;)=p_&#123;i&#125;,i=1,2...,n$。随机变量的熵为：</code></pre><script type="math/tex; mode=display">H(X)=-\sum_{i=1}^{n}p_{i}log_{2}p_{i}</script><pre><code>   对于样本集合，假设样本有k个类别，每个类别的概率为$\frac&#123;|C_&#123;k&#125;|&#125;&#123;|D|&#125;$，其中 $&#123;|C_&#123;k&#125;|&#125;&#123;|D|&#125;$为类别为k的样本个数，$|D|$为样本总数。样本集合D的熵为：</code></pre><script type="math/tex; mode=display">H(D)=-\sum_{k=1}^{k}\frac{|C_{k}|}{|D|}log_{2}\frac{|C_{k}|}{|D|}</script><h3 id="2-17-6-信息增益的理解"><a href="#2-17-6-信息增益的理解" class="headerlink" title="2.17.6 信息增益的理解"></a>2.17.6 信息增益的理解</h3><pre><code>定义：以某特征划分数据集前后的熵的差值。 熵可以表示样本集合的不确定性，熵越大，样本的不确定性就越大。因此可以使用划分前后集合熵的差值来衡量使用当前特征对于样本集合D划分效果的好坏。      假设划分前样本集合D的熵为H(D)。使用某个特征A划分数据集D，计算划分后的数据子集的熵为H(D|A)。  则信息增益为：</code></pre><script type="math/tex; mode=display">g(D,A)=H(D)-H(D|A)</script><pre><code>*注：*在决策树构建的过程中我们总是希望集合往最快到达纯度更高的子集合方向发展，因此我们总是选择使得信息增益最大的特征来划分当前数据集D。  思想：计算所有特征划分数据集D，得到多个特征划分数据集D的信息增益，从这些信息增益中选择最大的，因而当前结点的划分特征便是使信息增益最大的划分所使用的特征。  另外这里提一下信息增益比相关知识：$信息增益比=惩罚参数\times信息增益$  信息增益比本质：在信息增益的基础之上乘上一个惩罚参数。特征个数较多时，惩罚参数较小；特征个数较少时，惩罚参数较大。  惩罚参数：数据集D以特征A作为随机变量的熵的倒数。</code></pre><h3 id="2-17-7-剪枝处理的作用及策略"><a href="#2-17-7-剪枝处理的作用及策略" class="headerlink" title="2.17.7 剪枝处理的作用及策略"></a>2.17.7 剪枝处理的作用及策略</h3><pre><code>剪枝处理是决策树学习算法用来解决过拟合问题的一种办法。在决策树算法中，为了尽可能正确分类训练样本， 节点划分过程不断重复， 有时候会造成决策树分支过多，以至于将训练样本集自身特点当作泛化特点， 而导致过拟合。 因此可以采用剪枝处理来去掉一些分支来降低过拟合的风险。 剪枝的基本策略有预剪枝（pre-pruning）和后剪枝（post-pruning）。预剪枝：在决策树生成过程中，在每个节点划分前先估计其划分后的泛化性能， 如果不能提升，则停止划分，将当前节点标记为叶结点。 后剪枝：生成决策树以后，再自下而上对非叶结点进行考察， 若将此节点标记为叶结点可以带来泛化性能提升，则修改之。</code></pre><h2 id="2-18-支持向量机"><a href="#2-18-支持向量机" class="headerlink" title="2.18 支持向量机"></a>2.18 支持向量机</h2><h3 id="2-18-1-什么是支持向量机"><a href="#2-18-1-什么是支持向量机" class="headerlink" title="2.18.1 什么是支持向量机"></a>2.18.1 什么是支持向量机</h3><pre><code>支持向量：在求解的过程中，会发现只根据部分数据就可以确定分类器，这些数据称为支持向量。支持向量机（Support Vector Machine，SVM）：其含义是通过支持向量运算的分类器。在一个二维环境中，其中点R，S，G点和其它靠近中间黑线的点可以看作为支持向量，它们可以决定分类器，即黑线的具体参数。</code></pre><p><img src="/p/16a6/ch2/2-6.png" alt></p><pre><code>支持向量机是一种二分类模型，它的目的是寻找一个超平面来对样本进行分割，分割的原则是边界最大化，最终转化为一个凸二次规划问题来求解。由简至繁的模型包括：当训练样本线性可分时，通过硬边界（hard margin）最大化，学习一个线性可分支持向量机；当训练样本近似线性可分时，通过软边界（soft margin）最大化，学习一个线性支持向量机；当训练样本线性不可分时，通过核技巧和软边界最大化，学习一个非线性支持向量机；</code></pre><h3 id="2-18-2-支持向量机能解决哪些问题"><a href="#2-18-2-支持向量机能解决哪些问题" class="headerlink" title="2.18.2 支持向量机能解决哪些问题"></a>2.18.2 支持向量机能解决哪些问题</h3><p><strong>线性分类</strong></p><pre><code>在训练数据中，每个数据都有n个的属性和一个二分类类别标志，我们可以认为这些数据在一个n维空间里。我们的目标是找到一个n-1维的超平面，这个超平面可以将数据分成两部分，每部分数据都属于同一个类别。这样的超平面有很多，假如我们要找到一个最佳的超平面。此时，增加一个约束条件：要求这个超平面到每边最近数据点的距离是最大的，成为最大边距超平面。这个分类器即为最大边距分类器。</code></pre><p><strong>非线性分类</strong></p><pre><code>SVM的一个优势是支持非线性分类。它结合使用拉格朗日乘子法（Lagrange Multiplier）和KKT（Karush Kuhn Tucker）条件，以及核函数可以生成非线性分类器。</code></pre><h3 id="2-18-3-核函数特点及其作用"><a href="#2-18-3-核函数特点及其作用" class="headerlink" title="2.18.3 核函数特点及其作用"></a>2.18.3 核函数特点及其作用</h3><pre><code>引入核函数目的：把原坐标系里线性不可分的数据用核函数Kernel投影到另一个空间，尽量使得数据在新的空间里线性可分。  核函数方法的广泛应用，与其特点是分不开的：  </code></pre><p>1）核函数的引入避免了“维数灾难”，大大减小了计算量。而输入空间的维数n对核函数矩阵无影响。因此，核函数方法可以有效处理高维输入。</p><p>2）无需知道非线性变换函数Φ的形式和参数。</p><p>3）核函数的形式和参数的变化会隐式地改变从输入空间到特征空间的映射，进而对特征空间的性质产生影响，最终改变各种核函数方法的性能。</p><p>4）核函数方法可以和不同的算法相结合，形成多种不同的基于核函数技术的方法，且这两部分的设计可以单独进行，并可以为不同的应用选择不同的核函数和算法。</p><h3 id="2-18-4-SVM为什么引入对偶问题"><a href="#2-18-4-SVM为什么引入对偶问题" class="headerlink" title="2.18.4 SVM为什么引入对偶问题"></a>2.18.4 SVM为什么引入对偶问题</h3><p>1，对偶问题将原始问题中的约束转为了对偶问题中的等式约束，对偶问题往往更加容易求解。</p><p>2，可以很自然的引用核函数（拉格朗日表达式里面有内积，而核函数也是通过内积进行映射的）。</p><p>3，在优化理论中，目标函数 f(x) 会有多种形式：如果目标函数和约束条件都为变量 x 的线性函数，称该问题为线性规划；如果目标函数为二次函数，约束条件为线性函数，称该最优化问题为二次规划；如果目标函数或者约束条件均为非线性函数，称该最优化问题为非线性规划。每个线性规划问题都有一个与之对应的对偶问题，对偶问题有非常良好的性质，以下列举几个：</p><pre><code>a, 对偶问题的对偶是原问题；b, 无论原始问题是否是凸的，对偶问题都是凸优化问题；c, 对偶问题可以给出原始问题一个下界；d, 当满足一定条件时，原始问题与对偶问题的解是完全等价的。</code></pre><h3 id="2-18-5-如何理解SVM中的对偶问题"><a href="#2-18-5-如何理解SVM中的对偶问题" class="headerlink" title="2.18.5 如何理解SVM中的对偶问题"></a>2.18.5 如何理解SVM中的对偶问题</h3><p>在硬边界支持向量机中，问题的求解可以转化为凸二次规划问题。</p><pre><code>假设优化目标为</code></pre><script type="math/tex; mode=display">\begin{align}&\min_{\boldsymbol w, b}\frac{1}{2}||\boldsymbol w||^2\\&s.t. y_i(\boldsymbol w^T\boldsymbol x_i+b)\geqslant 1, i=1,2,\cdots,m.\\\end{align}  \tag{1}</script><p><strong>step 1</strong>. 转化问题：</p><script type="math/tex; mode=display">\min_{\boldsymbol w, b} \max_{\alpha_i \geqslant 0}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}  \tag{2}</script><p>上式等价于原问题，因为若满足(1)中不等式约束，则(2)式求max时,$\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))$必须取0，与(1)等价；若不满足(1)中不等式约束，(2)中求max会得到无穷大。 交换min和max获得其对偶问题:</p><script type="math/tex; mode=display">\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}</script><p>交换之后的对偶问题和原问题并不相等，上式的解小于等于原问题的解。</p><p><strong>step 2</strong>.现在的问题是如何找到问题(1) 的最优值的一个最好的下界? </p><script type="math/tex; mode=display">\frac{1}{2}||\boldsymbol w||^2 < v\\1 - y_i(\boldsymbol w^T\boldsymbol x_i+b) \leqslant 0\tag{3}</script><p>若方程组(3)无解， 则v是问题(1)的一个下界。若(3)有解， 则 </p><script type="math/tex; mode=display">\forall \boldsymbol \alpha >  0 , \ \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\} < v</script><p>由逆否命题得：若 </p><script type="math/tex; mode=display">\exists \boldsymbol \alpha >  0 , \ \min_{\boldsymbol w, b}  \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\} \geqslant v</script><p>则(3)无解。</p><p>那么v是问题</p><p>(1)的一个下界。<br> 要求得一个好的下界，取最大值即可 </p><script type="math/tex; mode=display">\max_{\alpha_i \geqslant 0}  \min_{\boldsymbol w, b} \left\{\frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))\right\}</script><p><strong>step 3</strong>. 令</p><script type="math/tex; mode=display">L(\boldsymbol w, b,\boldsymbol a) =   \frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1 - y_i(\boldsymbol w^T\boldsymbol x_i+b))</script><p>$p^<em>$为原问题的最小值，对应的$w,b$分别为$w^</em>,b^*$,则对于任意的$a&gt;0$:</p><script type="math/tex; mode=display">p^* = \frac{1}{2}||\boldsymbol w^*||^2 \geqslant  L(\boldsymbol w^*, b,\boldsymbol a) \geqslant \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)</script><p>则 $\min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)$是问题（1）的一个下界。</p><p>此时，取最大值即可求得好的下界，即</p><script type="math/tex; mode=display">\max_{\alpha_i \geqslant 0} \min_{\boldsymbol w, b} L(\boldsymbol w, b,\boldsymbol a)</script><h3 id="2-18-7-常见的核函数有哪些"><a href="#2-18-7-常见的核函数有哪些" class="headerlink" title="2.18.7 常见的核函数有哪些"></a>2.18.7 常见的核函数有哪些</h3><div class="table-container"><table><thead><tr><th>核函数</th><th>表达式</th><th>备注</th></tr></thead><tbody><tr><td>Linear Kernel线性核</td><td>$k(x,y)=x^{t}y+c$</td><td></td></tr><tr><td>Polynomial Kernel多项式核</td><td>$k(x,y)=(ax^{t}y+c)^{d}$</td><td>$d\geqslant1$为多项式的次数</td></tr><tr><td>Exponential Kernel指数核</td><td>$k(x,y)=exp(-\frac{\left \</td><td>x-y \right \</td><td>}{2\sigma ^{2}})$</td><td>$\sigma&gt;0$</td></tr><tr><td>Gaussian Kernel高斯核</td><td>$k(x,y)=exp(-\frac{\left \</td><td>x-y \right \</td><td>^{2}}{2\sigma ^{2}})$</td><td>$\sigma$为高斯核的带宽，$\sigma&gt;0$,</td></tr><tr><td>Laplacian Kernel拉普拉斯核</td><td>$k(x,y)=exp(-\frac{\left \</td><td>x-y \right \</td><td>}{\sigma})$</td><td>$\sigma&gt;0$</td></tr><tr><td>ANOVA Kernel</td><td>$k(x,y)=exp(-\sigma(x^{k}-y^{k})^{2})^{d}$</td><td></td></tr><tr><td>Sigmoid Kernel</td><td>$k(x,y)=tanh(ax^{t}y+c)$</td><td>$tanh$为双曲正切函数，$a&gt;0,c&lt;0$</td></tr></tbody></table></div><h3 id="2-18-9-SVM主要特点"><a href="#2-18-9-SVM主要特点" class="headerlink" title="2.18.9 SVM主要特点"></a>2.18.9 SVM主要特点</h3><p>特点：</p><p>(1)  SVM方法的理论基础是非线性映射，SVM利用内积核函数代替向高维空间的非线性映射。<br>(2)  SVM的目标是对特征空间划分得到最优超平面，SVM方法核心是最大化分类边界。<br>(3)  支持向量是SVM的训练结果，在SVM分类决策中起决定作用的是支持向量。<br>(4)  SVM是一种有坚实理论基础的新颖的适用小样本学习方法。它基本上不涉及概率测度及大数定律等，也简化了通常的分类和回归等问题。<br>(5)  SVM的最终决策函数只由少数的支持向量所确定，计算的复杂性取决于支持向量的数目，而不是样本空间的维数，这在某种意义上避免了“维数灾难”。<br>(6)  少数支持向量决定了最终结果，这不但可以帮助我们抓住关键样本、“剔除”大量冗余样本,而且注定了该方法不但算法简单，而且具有较好的“鲁棒性”。这种鲁棒性主要体现在：<br>        ①增、删非支持向量样本对模型没有影响;<br>        ②支持向量样本集具有一定的鲁棒性;<br>        ③有些成功的应用中，SVM方法对核的选取不敏感<br>(7)  SVM学习问题可以表示为凸优化问题，因此可以利用已知的有效算法发现目标函数的全局最小值。而其他分类方法（如基于规则的分类器和人工神经网络）都采用一种基于贪心学习的策略来搜索假设空间，这种方法一般只能获得局部最优解。<br>(8)  SVM通过最大化决策边界的边缘来控制模型的能力。尽管如此，用户必须提供其他参数，如使用核函数类型和引入松弛变量等。<br>(9)  SVM在小样本训练集上能够得到比其它算法好很多的结果。SVM优化目标是结构化风险最小，而不是经验风险最小，避免了过拟合问题，通过margin的概念，得到对数据分布的结构化描述，减低了对数据规模和数据分布的要求，有优秀的泛化能力。<br>(10)  它是一个凸优化问题，因此局部最优解一定是全局最优解的优点。  </p><h3 id="2-18-10-SVM主要缺点"><a href="#2-18-10-SVM主要缺点" class="headerlink" title="2.18.10 SVM主要缺点"></a>2.18.10 SVM主要缺点</h3><p>(1) SVM算法对大规模训练样本难以实施<br>        SVM的空间消耗主要是存储训练样本和核矩阵，由于SVM是借助二次规划来求解支持向量，而求解二次规划将涉及m阶矩阵的计算（m为样本的个数），当m数目很大时该矩阵的存储和计算将耗费大量的机器内存和运算时间。<br>        如果数据量很大，SVM的训练时间就会比较长，如垃圾邮件的分类检测，没有使用SVM分类器，而是使用简单的朴素贝叶斯分类器，或者是使用逻辑回归模型分类。</p><p>(2) 用SVM解决多分类问题存在困难</p><pre><code>    经典的支持向量机算法只给出了二类分类的算法，而在实际应用中，一般要解决多类的分类问题。可以通过多个二类支持向量机的组合来解决。主要有一对多组合模式、一对一组合模式和SVM决策树；再就是通过构造多个分类器的组合来解决。主要原理是克服SVM固有的缺点，结合其他算法的优势，解决多类问题的分类精度。如：与粗糙集理论结合，形成一种优势互补的多类问题的组合分类器。</code></pre><p>(3) 对缺失数据敏感，对参数和核函数的选择敏感</p><pre><code>    支持向量机性能的优劣主要取决于核函数的选取，所以对于一个实际问题而言，如何根据实际的数据模型选择合适的核函数从而构造SVM算法。目前比较成熟的核函数及其参数的选择都是人为的，根据经验来选取的，带有一定的随意性。在不同的问题领域，核函数应当具有不同的形式和参数，所以在选取时候应该将领域知识引入进来，但是目前还没有好的方法来解决核函数的选取问题。</code></pre><h3 id="2-18-11-逻辑回归与SVM的异同"><a href="#2-18-11-逻辑回归与SVM的异同" class="headerlink" title="2.18.11 逻辑回归与SVM的异同"></a>2.18.11 逻辑回归与SVM的异同</h3><p>相同点：</p><ul><li>LR和SVM都是<strong>分类</strong>算法。</li><li>LR和SVM都是<strong>监督学习</strong>算法。</li><li>LR和SVM都是<strong>判别模型</strong>。</li><li>如果不考虑核函数，LR和SVM都是<strong>线性分类</strong>算法，也就是说他们的分类决策面都是线性的。<br> 说明：LR也是可以用核函数的.但LR通常不采用核函数的方法。（<strong>计算量太大</strong>）</li></ul><p>不同点：</p><p><strong>1、LR采用log损失，SVM采用合页(hinge)损失。</strong><br>逻辑回归的损失函数：</p><script type="math/tex; mode=display">J(\theta)=-\frac{1}{m}\sum^m_{i=1}\left[y^{i}logh_{\theta}(x^{i})+ (1-y^{i})log(1-h_{\theta}(x^{i}))\right]</script><p>支持向量机的目标函数:</p><script type="math/tex; mode=display">L(w,n,a)=\frac{1}{2}||w||^2-\sum^n_{i=1}\alpha_i \left( y_i(w^Tx_i+b)-1\right)</script><pre><code>逻辑回归方法基于概率理论，假设样本为1的概率可以用sigmoid函数来表示，然后通过**极大似然估计**的方法估计出参数的值。  支持向量机基于几何**边界最大化**原理，认为存在最大几何边界的分类面为最优分类面。</code></pre><p>2、<strong>LR对异常值敏感，SVM对异常值不敏感</strong>。</p><pre><code>支持向量机只考虑局部的边界线附近的点，而逻辑回归考虑全局。LR模型找到的那个超平面，是尽量让所有点都远离他，而SVM寻找的那个超平面，是只让最靠近中间分割线的那些点尽量远离，即只用到那些支持向量的样本。  支持向量机改变非支持向量样本并不会引起决策面的变化。  逻辑回归中改变任何样本都会引起决策面的变化。  </code></pre><p>3、<strong>计算复杂度不同。对于海量数据，SVM的效率较低，LR效率比较高</strong></p><pre><code>当样本较少，特征维数较低时，SVM和LR的运行时间均比较短，SVM较短一些。准确率的话，LR明显比SVM要高。当样本稍微增加些时，SVM运行时间开始增长，但是准确率赶超了LR。SVM时间虽长，但在可接受范围内。当数据量增长到20000时，特征维数增长到200时，SVM的运行时间剧烈增加，远远超过了LR的运行时间。但是准确率却和LR相差无几。(这其中主要原因是大量非支持向量参与计算，造成SVM的二次规划问题)</code></pre><p>4、<strong>对非线性问题的处理方式不同</strong></p><pre><code>LR主要靠特征构造，必须组合交叉特征，特征离散化。SVM也可以这样，还可以通过核函数kernel（因为只有支持向量参与核计算，计算复杂度不高）。由于可以利用核函数，SVM则可以通过对偶求解高效处理。LR则在特征空间维度很高时，表现较差。</code></pre><p>5、<strong>SVM的损失函数就自带正则</strong>。<br>    损失函数中的1/2||w||^2项，这就是为什么SVM是结构风险最小化算法的原因！！！而LR必须另外在损失函数上添加正则项！！！**</p><p>6、SVM自带<strong>结构风险最小化</strong>，LR则是<strong>经验风险最小化</strong>。</p><p>7、SVM会用核函数而LR一般不用核函数。</p><h2 id="2-19-贝叶斯分类器"><a href="#2-19-贝叶斯分类器" class="headerlink" title="2.19 贝叶斯分类器"></a>2.19 贝叶斯分类器</h2><h3 id="2-19-1-图解极大似然估计"><a href="#2-19-1-图解极大似然估计" class="headerlink" title="2.19.1 图解极大似然估计"></a>2.19.1 图解极大似然估计</h3><p>极大似然估计的原理，用一张图片来说明，如下图所示：</p><p><img src="/p/16a6/ch2/2.19.1.1.png" alt></p><pre><code>例：有两个外形完全相同的箱子，1号箱有99只白球，1只黑球；2号箱有1只白球，99只黑球。在一次实验中，取出的是黑球，请问是从哪个箱子中取出的？一般的根据经验想法，会猜测这只黑球最像是从2号箱取出，此时描述的“最像”就有“最大似然”的意思，这种想法常称为“最大似然原理”。</code></pre><h3 id="2-19-2-极大似然估计原理"><a href="#2-19-2-极大似然估计原理" class="headerlink" title="2.19.2 极大似然估计原理"></a>2.19.2 极大似然估计原理</h3><pre><code>总结起来，最大似然估计的目的就是：利用已知的样本结果，反推最有可能（最大概率）导致这样结果的参数值。极大似然估计是建立在极大似然原理的基础上的一个统计方法。极大似然估计提供了一种给定观察数据来评估模型参数的方法，即：“模型已定，参数未知”。通过若干次试验，观察其结果，利用试验结果得到某个参数值能够使样本出现的概率为最大，则称为极大似然估计。由于样本集中的样本都是独立同分布，可以只考虑一类样本集$D$，来估计参数向量$\vec\theta$。记已知的样本集为：</code></pre><script type="math/tex; mode=display">D=\vec x_{1},\vec x_{2},...,\vec x_{n}</script><p>似然函数（likelihood function）：联合概率密度函数$p(D|\vec\theta )$称为相对于$\vec x_{1},\vec x_{2},…,\vec x_{n}$的$\vec\theta$的似然函数。</p><script type="math/tex; mode=display">l(\vec\theta )=p(D|\vec\theta ) =p(\vec x_{1},\vec x_{2},...,\vec x_{n}|\vec\theta )=\prod_{i=1}^{n}p(\vec x_{i}|\vec \theta )</script><p>如果$\hat{\vec\theta}$是参数空间中能使似然函数$l(\vec\theta)$最大的$\vec\theta$值，则$\hat{\vec\theta}$应该是“最可能”的参数值，那么$\hat{\vec\theta}$就是$\theta$的极大似然估计量。它是样本集的函数，记作：</p><script type="math/tex; mode=display">\hat{\vec\theta}=d(D)= \mathop {\arg \max}_{\vec\theta} l(\vec\theta )</script><p>$\hat{\vec\theta}(\vec x_{1},\vec x_{2},…,\vec x_{n})$称为极大似然函数估计值。</p><h3 id="2-19-3-贝叶斯分类器基本原理"><a href="#2-19-3-贝叶斯分类器基本原理" class="headerlink" title="2.19.3 贝叶斯分类器基本原理"></a>2.19.3 贝叶斯分类器基本原理</h3><pre><code>贝叶斯决策论通过**相关概率已知**的情况下利用**误判损失**来选择最优的类别分类。  </code></pre><p>假设有$N$种可能的分类标记，记为$Y=\{c_1,c_2,…,c_N\}$，那对于样本$\boldsymbol{x}$，它属于哪一类呢？</p><p>计算步骤如下：</p><p>step 1. 算出样本$\boldsymbol{x}$属于第i个类的概率，即$P(c_i|x)$；</p><p>step 2. 通过比较所有的$P(c_i|\boldsymbol{x})$，得到样本$\boldsymbol{x}$所属的最佳类别。</p><p>step 3. 将类别$c_i$和样本$\boldsymbol{x}$代入到贝叶斯公式中，得到：</p><script type="math/tex; mode=display">P(c_i|\boldsymbol{x})=\frac{P(\boldsymbol{x}|c_i)P(c_i)}{P(\boldsymbol{x})}.</script><pre><code>一般来说，$P(c_i)$为先验概率，$P(\boldsymbol&#123;x&#125;|c_i)$为条件概率，$P(\boldsymbol&#123;x&#125;)$是用于归一化的证据因子。对于$P(c_i)$可以通过训练样本中类别为$c_i$的样本所占的比例进行估计；此外，由于只需要找出最大的$P(\boldsymbol&#123;x&#125;|c_i)$，因此我们并不需要计算$P(\boldsymbol&#123;x&#125;)$。  为了求解条件概率，基于不同假设提出了不同的方法，以下将介绍朴素贝叶斯分类器和半朴素贝叶斯分类器。</code></pre><h3 id="2-19-4-朴素贝叶斯分类器"><a href="#2-19-4-朴素贝叶斯分类器" class="headerlink" title="2.19.4 朴素贝叶斯分类器"></a>2.19.4 朴素贝叶斯分类器</h3><pre><code>假设样本$\boldsymbol&#123;x&#125;$包含$d$个属性，即$\boldsymbol&#123;x&#125;=\&#123; x_1,x_2,...,x_d\&#125;$。于是有：</code></pre><script type="math/tex; mode=display">P(\boldsymbol{x}|c_i)=P(x_1,x_2,\cdots,x_d|c_i)</script><p>这个联合概率难以从有限的训练样本中直接估计得到。于是，朴素贝叶斯（Naive Bayesian，简称NB）采用了“属性条件独立性假设”：对已知类别，假设所有属性相互独立。于是有：</p><script type="math/tex; mode=display">P(x_1,x_2,\cdots,x_d|c_i)=\prod_{j=1}^d P(x_j|c_i)</script><p>这样的话，我们就可以很容易地推出相应的判定准则了：</p><script type="math/tex; mode=display">h_{nb}(\boldsymbol{x})=\mathop{\arg \max}_{c_i\in Y} P(c_i)\prod_{j=1}^dP(x_j|c_i)</script><p><strong>条件概率$P(x_j|c_i)$的求解</strong></p><p>如果$x_j$是标签属性，那么我们可以通过计数的方法估计$P(x_j|c_i)$</p><script type="math/tex; mode=display">P(x_j|c_i)=\frac{P(x_j,c_i)}{P(c_i)}\approx\frac{\#(x_j,c_i)}{\#(c_i)}</script><p>其中，$#(x_j,c_i)$表示在训练样本中$x_j$与$c_{i}$共同出现的次数。</p><p>如果$x_j$是数值属性，通常我们假设类别中$c_{i}$的所有样本第$j$个属性的值服从正态分布。我们首先估计这个分布的均值$μ$和方差$σ$，然后计算$x_j$在这个分布中的概率密度$P(x_j|c_i)$。</p><h3 id="2-19-5-举例理解朴素贝叶斯分类器"><a href="#2-19-5-举例理解朴素贝叶斯分类器" class="headerlink" title="2.19.5 举例理解朴素贝叶斯分类器"></a>2.19.5 举例理解朴素贝叶斯分类器</h3><p>使用经典的西瓜训练集如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">纹理</th><th style="text-align:center">脐部</th><th style="text-align:center">触感</th><th style="text-align:center">密度</th><th style="text-align:center">含糖率</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.697</td><td style="text-align:center">0.460</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.774</td><td style="text-align:center">0.376</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">乌黑</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.634</td><td style="text-align:center">0.264</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.608</td><td style="text-align:center">0.318</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">浅白</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.556</td><td style="text-align:center">0.215</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">青绿</td><td style="text-align:center">稍蜷</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">稍凹</td><td style="text-align:center">软粘</td><td style="text-align:center">0.403</td><td style="text-align:center">0.237</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">7</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍蜷</td><td style="text-align:center">浊响</td><td style="text-align:center">稍糊</td><td style="text-align:center">稍凹</td><td style="text-align:center">软粘</td><td style="text-align:center">0.481</td><td style="text-align:center">0.149</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">8</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍蜷</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">稍凹</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.437</td><td style="text-align:center">0.211</td><td style="text-align:center">是</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍蜷</td><td style="text-align:center">沉闷</td><td style="text-align:center">稍糊</td><td style="text-align:center">稍凹</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.666</td><td style="text-align:center">0.091</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">青绿</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">清晰</td><td style="text-align:center">平坦</td><td style="text-align:center">软粘</td><td style="text-align:center">0.243</td><td style="text-align:center">0.267</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">浅白</td><td style="text-align:center">硬挺</td><td style="text-align:center">清脆</td><td style="text-align:center">模糊</td><td style="text-align:center">平坦</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.245</td><td style="text-align:center">0.057</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">浅白</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">模糊</td><td style="text-align:center">平坦</td><td style="text-align:center">软粘</td><td style="text-align:center">0.343</td><td style="text-align:center">0.099</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">青绿</td><td style="text-align:center">稍蜷</td><td style="text-align:center">浊响</td><td style="text-align:center">稍糊</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.639</td><td style="text-align:center">0.161</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">浅白</td><td style="text-align:center">稍蜷</td><td style="text-align:center">沉闷</td><td style="text-align:center">稍糊</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.657</td><td style="text-align:center">0.198</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">15</td><td style="text-align:center">乌黑</td><td style="text-align:center">稍蜷</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">稍凹</td><td style="text-align:center">软粘</td><td style="text-align:center">0.360</td><td style="text-align:center">0.370</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">16</td><td style="text-align:center">浅白</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">模糊</td><td style="text-align:center">平坦</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.593</td><td style="text-align:center">0.042</td><td style="text-align:center">否</td></tr><tr><td style="text-align:center">17</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">沉闷</td><td style="text-align:center">稍糊</td><td style="text-align:center">稍凹</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.719</td><td style="text-align:center">0.103</td><td style="text-align:center">否</td></tr></tbody></table></div><p>对下面的测试例“测1”进行 分类：</p><div class="table-container"><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">色泽</th><th style="text-align:center">根蒂</th><th style="text-align:center">敲声</th><th style="text-align:center">纹理</th><th style="text-align:center">脐部</th><th style="text-align:center">触感</th><th style="text-align:center">密度</th><th style="text-align:center">含糖率</th><th style="text-align:center">好瓜</th></tr></thead><tbody><tr><td style="text-align:center">测1</td><td style="text-align:center">青绿</td><td style="text-align:center">蜷缩</td><td style="text-align:center">浊响</td><td style="text-align:center">清晰</td><td style="text-align:center">凹陷</td><td style="text-align:center">硬滑</td><td style="text-align:center">0.697</td><td style="text-align:center">0.460</td><td style="text-align:center">？</td></tr></tbody></table></div><p>首先，估计类先验概率$P(c_j)$，有</p><script type="math/tex; mode=display">\begin{align} &P(好瓜=是)=\frac{8}{17}=0.471 \newline &P(好瓜=否)=\frac{9}{17}=0.529 \end{align}</script><p>然后，为每个属性估计条件概率（这里，对于连续属性，假定它们服从正态分布）</p><script type="math/tex; mode=display">P_{青绿|是}=P（色泽=青绿|好瓜=是）=\frac{3}{8}=0.375</script><script type="math/tex; mode=display">P_{青绿|否}=P（色泽=青绿|好瓜=否）=\frac{3}{9}\approx0.333</script><script type="math/tex; mode=display">P_{蜷缩|是}=P（根蒂=蜷缩|好瓜=是）=\frac{5}{8}=0.625</script><script type="math/tex; mode=display">P_{蜷缩|否}=P（根蒂=蜷缩|好瓜=否）=\frac{3}{9}=0.333</script><script type="math/tex; mode=display">P_{浊响|是}=P（敲声=浊响|好瓜=是）=\frac{6}{8}=0.750</script><script type="math/tex; mode=display">P_{浊响|否}=P（敲声=浊响|好瓜=否）=\frac{4}{9}\approx 0.444</script><script type="math/tex; mode=display">P_{清晰|是}=P（纹理=清晰|好瓜=是）=\frac{7}{8}= 0.875</script><script type="math/tex; mode=display">P_{清晰|否}=P（纹理=清晰|好瓜=否）=\frac{2}{9}\approx 0.222</script><script type="math/tex; mode=display">P_{凹陷|是}=P（脐部=凹陷|好瓜=是）=\frac{6}{8}= 0.750</script><script type="math/tex; mode=display">P_{凹陷|否}=P（脐部=凹陷|好瓜=否）=\frac{2}{9} \approx 0.222</script><script type="math/tex; mode=display">P_{硬滑|是}=P（触感=硬滑|好瓜=是）=\frac{6}{8}= 0.750</script><script type="math/tex; mode=display">P_{硬滑|否}=P（触感=硬滑|好瓜=否）=\frac{6}{9} \approx 0.667</script><script type="math/tex; mode=display">\begin{aligned}\rho_{密度：0.697|是}&=\rho（密度=0.697|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.129}exp\left( -\frac{(0.697-0.574)^2}{2\times0.129^2}\right) \approx 1.959\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\rho_{密度：0.697|否}&=\rho（密度=0.697|好瓜=否）\\&=\frac{1}{\sqrt{2 \pi}\times0.195}exp\left( -\frac{(0.697-0.496)^2}{2\times0.195^2}\right) \approx 1.203\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\rho_{含糖：0.460|是}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.101}exp\left( -\frac{(0.460-0.279)^2}{2\times0.101^2}\right) \approx 0.788\end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}\rho_{含糖：0.460|否}&=\rho（密度=0.460|好瓜=是）\\&=\frac{1}{\sqrt{2 \pi}\times0.108}exp\left( -\frac{(0.460-0.154)^2}{2\times0.108^2}\right) \approx 0.066\end{aligned}</script><p>于是有</p><script type="math/tex; mode=display">\begin{align} P(&好瓜=是)\times P_{青绿|是} \times P_{蜷缩|是} \times P_{浊响|是} \times P_{清晰|是} \times P_{凹陷|是}\newline &\times P_{硬滑|是} \times p_{密度：0.697|是} \times p_{含糖：0.460|是} \approx 0.063 \newline\newline P(&好瓜=否)\times P_{青绿|否} \times P_{蜷缩|否} \times P_{浊响|否} \times P_{清晰|否} \times P_{凹陷|否}\newline &\times P_{硬滑|否} \times p_{密度：0.697|否} \times p_{含糖：0.460|否} \approx 6.80\times 10^{-5} \end{align}</script><p>由于$0.063&gt;6.80\times 10^{-5}$，因此，朴素贝叶斯分类器将测试样本“测1”判别为“好瓜”。</p><h3 id="2-19-6-半朴素贝叶斯分类器"><a href="#2-19-6-半朴素贝叶斯分类器" class="headerlink" title="2.19.6 半朴素贝叶斯分类器"></a>2.19.6 半朴素贝叶斯分类器</h3><pre><code>朴素贝叶斯采用了“属性条件独立性假设”，半朴素贝叶斯分类器的基本想法是适当考虑一部分属性间的相互依赖信息。**独依赖估计**（One-Dependence Estimator，简称ODE）是半朴素贝叶斯分类器最常用的一种策略。顾名思义，独依赖是假设每个属性在类别之外最多依赖一个其他属性，即：</code></pre><script type="math/tex; mode=display">P(\boldsymbol{x}|c_i)=\prod_{j=1}^d P(x_j|c_i,{\rm pa}_j)</script><p>其中$pa_j$为属性$x_i$所依赖的属性，成为$x_i$的父属性。假设父属性$pa_j$已知，那么可以使用下面的公式估计$P(x_j|c_i,{\rm pa}_j)$</p><script type="math/tex; mode=display">P(x_j|c_i,{\rm pa}_j)=\frac{P(x_j,c_i,{\rm pa}_j)}{P(c_i,{\rm pa}_j)}</script><h2 id="2-20-EM算法"><a href="#2-20-EM算法" class="headerlink" title="2.20 EM算法"></a>2.20 EM算法</h2><h3 id="2-20-1-EM算法基本思想"><a href="#2-20-1-EM算法基本思想" class="headerlink" title="2.20.1 EM算法基本思想"></a>2.20.1 EM算法基本思想</h3><pre><code>最大期望算法（Expectation-Maximization algorithm, EM），是一类通过迭代进行极大似然估计的优化算法，通常作为牛顿迭代法的替代，用于对包含隐变量或缺失数据的概率模型进行参数估计。最大期望算法基本思想是经过两个步骤交替进行计算：第一步是计算期望（E），利用对隐藏变量的现有估计值，计算其最大似然估计值**；**第二步是最大化（M），最大化在E步上求得的最大似然值来计算参数的值。M步上找到的参数估计值被用于下一个E步计算中，这个过程不断交替进行。</code></pre><h3 id="2-20-2-EM算法推导"><a href="#2-20-2-EM算法推导" class="headerlink" title="2.20.2 EM算法推导"></a>2.20.2 EM算法推导</h3><pre><code>对于$m$个样本观察数据$x=(x^&#123;1&#125;,x^&#123;2&#125;,...,x^&#123;m&#125;)$，现在想找出样本的模型参数$\theta$，其极大化模型分布的对数似然函数为：</code></pre><script type="math/tex; mode=display">\theta = \mathop{\arg\max}_\theta\sum\limits_{i=1}^m logP(x^{(i)};\theta)</script><p>如果得到的观察数据有未观察到的隐含数据$z=(z^{(1)},z^{(2)},…z^{(m)})$，极大化模型分布的对数似然函数则为：</p><script type="math/tex; mode=display">\theta =\mathop{\arg\max}_\theta\sum\limits_{i=1}^m logP(x^{(i)};\theta) = \mathop{\arg\max}_\theta\sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}P(x^{(i)}, z^{(i)};\theta)  \tag{a}</script><p>由于上式不能直接求出$\theta$，采用缩放技巧：</p><script type="math/tex; mode=display">\begin{align} \sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}P(x^{(i)}, z^{(i)};\theta)   & = \sum\limits_{i=1}^m log\sum\limits_{z^{(i)}}Q_i(z^{(i)})\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} \\ & \geqslant  \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} \end{align}   \tag{1}</script><p>上式用到了Jensen不等式：</p><script type="math/tex; mode=display">log\sum\limits_j\lambda_jy_j \geqslant \sum\limits_j\lambda_jlogy_j\;\;,  \lambda_j \geqslant 0, \sum\limits_j\lambda_j =1</script><p>并且引入了一个未知的新分布$Q_i(z^{(i)})$。</p><p>此时，如果需要满足Jensen不等式中的等号，所以有：</p><script type="math/tex; mode=display">\frac{P(x^{(i)}, z^{(i)};\theta)}{Q_i(z^{(i)})} =c, c为常数</script><p>由于$Q_i(z^{(i)})$是一个分布，所以满足</p><script type="math/tex; mode=display">\sum\limits_{z}Q_i(z^{(i)}) =1</script><p>综上，可得：</p><script type="math/tex; mode=display">Q_i(z^{(i)})  = \frac{P(x^{(i)}， z^{(i)};\theta)}{\sum\limits_{z}P(x^{(i)}, z^{(i)};\theta)} =  \frac{P(x^{(i)}, z^{(i)};\theta)}{P(x^{(i)};\theta)} = P( z^{(i)}|x^{(i)};\theta)</script><p>如果$Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)};\theta)$ ，则第(1)式是我们的包含隐藏数据的对数似然的一个下界。如果我们能极大化这个下界，则也在尝试极大化我们的对数似然。即我们需要最大化下式：</p><script type="math/tex; mode=display">\mathop{\arg\max}_\theta \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log\frac{P(x^{(i)}， z^{(i)};\theta)}{Q_i(z^{(i)})}</script><p>简化得：</p><script type="math/tex; mode=display">\mathop{\arg\max}_\theta \sum\limits_{i=1}^m \sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}</script><p>以上即为EM算法的M步，$\sum\limits_{z^{(i)}}Q_i(z^{(i)})log{P(x^{(i)}, z^{(i)};\theta)}$可理解为$logP(x^{(i)}, z^{(i)};\theta) $基于条件概率分布$Q_i(z^{(i)}) $的期望。以上即为EM算法中E步和M步的具体数学含义。</p><h3 id="2-20-3-图解EM算法"><a href="#2-20-3-图解EM算法" class="headerlink" title="2.20.3 图解EM算法"></a>2.20.3 图解EM算法</h3><pre><code>考虑上一节中的（a）式，表达式中存在隐变量，直接找到参数估计比较困难，通过EM算法迭代求解下界的最大值到收敛为止。</code></pre><p><img src="/p/16a6/ch2/2.20.1.jpg" alt></p><pre><code>图片中的紫色部分是我们的目标模型$p(x|\theta)$，该模型复杂，难以求解析解，为了消除隐变量$z^&#123;(i)&#125;$的影响，我们可以选择一个不包含$z^&#123;(i)&#125;$的模型$r(x|\theta)$，使其满足条件$r(x|\theta) \leqslant p(x|\theta) $。</code></pre><p>求解步骤如下：</p><p>（1）选取$\theta_1$，使得$r(x|\theta_1) = p(x|\theta_1)$，然后对此时的$r$求取最大值，得到极值点$\theta_2$，实现参数的更新。</p><p>（2）重复以上过程到收敛为止，在更新过程中始终满足$r \leqslant p $.</p><h3 id="2-20-4-EM算法流程"><a href="#2-20-4-EM算法流程" class="headerlink" title="2.20.4 EM算法流程"></a>2.20.4 EM算法流程</h3><p>输入：观察数据$x=(x^{(1)},x^{(2)},…x^{(m)})$，联合分布$p(x,z ;\theta)$，条件分布$p(z|x; \theta)$，最大迭代次数$J$</p><p>1）随机初始化模型参数$\theta$的初值$\theta^0$。</p><p>2）$for \ j  \ from \ 1  \ to  \ j$：</p><pre><code>a） E步。计算联合分布的条件概率期望：</code></pre><script type="math/tex; mode=display">Q_i(z^{(i)}) = P( z^{(i)}|x^{(i)}, \theta^{j})</script><script type="math/tex; mode=display">L(\theta, \theta^{j}) = \sum\limits_{i=1}^m\sum\limits_{z^{(i)}}P( z^{(i)}|x^{(i)}, \theta^{j})log{P(x^{(i)}, z^{(i)};\theta)}</script><pre><code>b） M步。极大化$L(\theta, \theta^&#123;j&#125;)$，得到$\theta^&#123;j+1&#125;$:</code></pre><script type="math/tex; mode=display">\theta^{j+1} = \mathop{\arg\max}_\theta L(\theta, \theta^{j})</script><pre><code>c） 如果$\theta^&#123;j+1&#125;$收敛，则算法结束。否则继续回到步骤a）进行E步迭代。</code></pre><p>输出：模型参数$\theta$。</p><h2 id="2-21-降维和聚类"><a href="#2-21-降维和聚类" class="headerlink" title="2.21 降维和聚类"></a>2.21 降维和聚类</h2><h3 id="2-21-1-图解为什么会产生维数灾难"><a href="#2-21-1-图解为什么会产生维数灾难" class="headerlink" title="2.21.1 图解为什么会产生维数灾难"></a>2.21.1 图解为什么会产生维数灾难</h3><pre><code>假如数据集包含10张照片，照片中包含三角形和圆两种形状。现在来设计一个分类器进行训练，让这个分类器对其他的照片进行正确分类（假设三角形和圆的总数是无限大），简单的，我们用一个特征进行分类：</code></pre><p><img src="/p/16a6/ch2/2.21.1.1.png" alt></p><pre><code>                                        图2.21.1.a从上图可看到，如果仅仅只有一个特征进行分类，三角形和圆几乎是均匀分布在这条线段上，很难将10张照片线性分类。那么，增加一个特征后的情况会怎么样：</code></pre><p><img src="/p/16a6/ch2/2.21.1.2.png" alt></p><pre><code>                                        图2.21.1.b</code></pre><p>增加一个特征后，我们发现仍然无法找到一条直线将猫和狗分开。所以，考虑需要再增加一个特征：</p><p><img src="/p/16a6/ch2/2.21.1.3.png" alt></p><pre><code>                                        图2.21.1.c</code></pre><p><img src="/p/16a6/ch2/2.21.1.4.png" alt></p><pre><code>                                        图2.21.1.d此时，可以找到一个平面将三角形和圆分开。现在计算一下不同特征数是样本的密度：（1）一个特征时，假设特征空间时长度为5的线段，则样本密度为$10 \div 5 = 2$。（2）两个特征时，特征空间大小为$ 5\times5 = 25$，样本密度为$10 \div 25 = 0.4$。（3）三个特征时，特征空间大小是$ 5\times5\times5 = 125$，样本密度为$10 \div 125 = 0.08$。以此类推，如果继续增加特征数量，样本密度会越来越稀疏，此时，更容易找到一个超平面将训练样本分开。当特征数量增长至无限大时，样本密度就变得非常稀疏。下面看一下将高维空间的分类结果映射到低维空间时，会出现什么情况？</code></pre><p><img src="/p/16a6/ch2/2.21.1.5.png" alt></p><pre><code>                                    图2.21.1.e上图是将三维特征空间映射到二维特征空间后的结果。尽管在高维特征空间时训练样本线性可分，但是映射到低维空间后，结果正好相反。事实上，增加特征数量使得高维空间线性可分，相当于在低维空间内训练一个复杂的非线性分类器。不过，这个非线性分类器太过“聪明”，仅仅学到了一些特例。如果将其用来辨别那些未曾出现在训练样本中的测试样本时，通常结果不太理想，会造成过拟合问题。</code></pre><p><img src="/p/16a6/ch2/2.21.1.6a.png" alt></p><pre><code>                                    图2.21.1.f上图所示的只采用2个特征的线性分类器分错了一些训练样本，准确率似乎没有图2.21.1.e的高，但是，采用2个特征的线性分类器的泛化能力比采用3个特征的线性分类器要强。因为，采用2个特征的线性分类器学习到的不只是特例，而是一个整体趋势，对于那些未曾出现过的样本也可以比较好地辨别开来。换句话说，通过减少特征数量，可以避免出现过拟合问题，从而避免“维数灾难”。</code></pre><p><img src="/p/16a6/ch2/2.21.1.6.png" alt></p><pre><code>上图从另一个角度诠释了“维数灾难”。假设只有一个特征时，特征的值域是0到1，每一个三角形和圆的特征值都是唯一的。如果我们希望训练样本覆盖特征值值域的20%，那么就需要三角形和圆总数的20%。我们增加一个特征后，为了继续覆盖特征值值域的20%就需要三角形和圆总数的45%($0.452^2\approx0.2$)。继续增加一个特征后，需要三角形和圆总数的58%($0.583^3\approx0.2$)。随着特征数量的增加，为了覆盖特征值值域的20%，就需要更多的训练样本。如果没有足够的训练样本，就可能会出现过拟合问题。通过上述例子，我们可以看到特征数量越多，训练样本就会越稀疏，分类器的参数估计就会越不准确，更加容易出现过拟合问题。“维数灾难”的另一个影响是训练样本的稀疏性并不是均匀分布的。处于中心位置的训练样本比四周的训练样本更加稀疏。</code></pre><p><img src="/p/16a6/ch2/2.21.1.7.png" alt></p><pre><code>假设有一个二维特征空间，如上图所示的矩形，在矩形内部有一个内切的圆形。由于越接近圆心的样本越稀疏，因此，相比于圆形内的样本，那些位于矩形四角的样本更加难以分类。当维数变大时，特征超空间的容量不变，但单位圆的容量会趋于0，在高维空间中，大多数训练数据驻留在特征超空间的角落。散落在角落的数据要比处于中心的数据难于分类。</code></pre><h3 id="2-21-2-怎样避免维数灾难"><a href="#2-21-2-怎样避免维数灾难" class="headerlink" title="2.21.2 怎样避免维数灾难"></a>2.21.2 怎样避免维数灾难</h3><p><strong>有待完善！！！</strong></p><p>解决维度灾难问题：</p><p>主成分分析法PCA，线性判别法LDA</p><p>奇异值分解简化数据、拉普拉斯特征映射</p><p>Lassio缩减系数法、小波分析法、</p><h3 id="2-21-3-聚类和降维有什么区别与联系"><a href="#2-21-3-聚类和降维有什么区别与联系" class="headerlink" title="2.21.3 聚类和降维有什么区别与联系"></a>2.21.3 聚类和降维有什么区别与联系</h3><pre><code>聚类用于找寻数据内在的分布结构，既可以作为一个单独的过程，比如异常检测等等。也可作为分类等其他学习任务的前驱过程。聚类是标准的无监督学习。1）在一些推荐系统中需确定新用户的类型，但定义“用户类型”却可能不太容易，此时往往可先对原有的用户数据进行聚类，根据聚类结果将每个簇定义为一个类,然后再基于这些类训练分类模型,用于判别新用户的类型。</code></pre><p><img src="/p/16a6/ch2/2.21.3.1.png" alt></p><pre><code>2）而降维则是为了缓解维数灾难的一个重要方法，就是通过某种数学变换将原始高维属性空间转变为一个低维“子空间”。其基于的假设就是，虽然人们平时观测到的数据样本虽然是高维的，但是实际上真正与学习任务相关的是个低维度的分布。从而通过最主要的几个特征维度就可以实现对数据的描述，对于后续的分类很有帮助。比如对于Kaggle（数据分析竞赛平台之一）上的泰坦尼克号生还问题。通过给定一个乘客的许多特征如年龄、姓名、性别、票价等，来判断其是否能在海难中生还。这就需要首先进行特征筛选，从而能够找出主要的特征，让学习到的模型有更好的泛化性。聚类和降维都可以作为分类等问题的预处理步骤。</code></pre><p><img src="/p/16a6/ch2/2-19.jpg" alt></p><pre><code>但是他们虽然都能实现对数据的约减。但是二者适用的对象不同，聚类针对的是数据点，而降维则是对于数据的特征。另外它们有着很多种实现方法。聚类中常用的有K-means、层次聚类、基于密度的聚类等；降维中常用的则PCA、Isomap、LLE等。</code></pre><h3 id="2-21-4-有哪些聚类算法优劣衡量标准"><a href="#2-21-4-有哪些聚类算法优劣衡量标准" class="headerlink" title="2.21.4 有哪些聚类算法优劣衡量标准"></a>2.21.4 有哪些聚类算法优劣衡量标准</h3><p>不同聚类算法有不同的优劣和不同的适用条件。可从以下方面进行衡量判断：<br>    1、算法的处理能力：处理大的数据集的能力，即算法复杂度；处理数据噪声的能力；处理任意形状，包括有间隙的嵌套的数据的能力；<br>    2、算法是否需要预设条件：是否需要预先知道聚类个数，是否需要用户给出领域知识； </p><pre><code>3、算法的数据输入属性：算法处理的结果与数据输入的顺序是否相关，也就是说算法是否独立于数据输入顺序；算法处理有很多属性数据的能力，也就是对数据维数是否敏感，对数据的类型有无要求。</code></pre><h3 id="2-21-5-聚类和分类有什么区别"><a href="#2-21-5-聚类和分类有什么区别" class="headerlink" title="2.21.5 聚类和分类有什么区别"></a>2.21.5 聚类和分类有什么区别</h3><p><strong>聚类（Clustering） </strong><br>    聚类，简单地说就是把相似的东西分到一组，聚类的时候，我们并不关心某一类是什么，我们需要实现的目标只是把相似的东西聚到一起。一个聚类算法通常只需要知道如何计算相似度就可以开始工作了，因此聚类通常并不需要使用训练数据进行学习，在机器学习中属于无监督学习。 </p><p><strong>分类（Classification） </strong></p><pre><code> 分类，对于一个分类器，通常需要你告诉它“这个东西被分为某某类”。一般情况下，一个分类器会从它得到的训练集中进行学习，从而具备对未知数据进行分类的能力，在机器学习中属于监督学习。</code></pre><h3 id="2-21-6-不同聚类算法特点性能比较"><a href="#2-21-6-不同聚类算法特点性能比较" class="headerlink" title="2.21.6 不同聚类算法特点性能比较"></a>2.21.6 不同聚类算法特点性能比较</h3><div class="table-container"><table><thead><tr><th style="text-align:center">算法名称</th><th style="text-align:center">可伸缩性</th><th style="text-align:center">适合的数据类型</th><th style="text-align:center">高维性</th><th style="text-align:center">异常数据抗干扰性</th><th style="text-align:center">聚类形状</th><th style="text-align:center">算法效率</th></tr></thead><tbody><tr><td style="text-align:center">WAVECLUSTER</td><td style="text-align:center">很高</td><td style="text-align:center">数值型</td><td style="text-align:center">很高</td><td style="text-align:center">较高</td><td style="text-align:center">任意形状</td><td style="text-align:center">很高</td></tr><tr><td style="text-align:center">ROCK</td><td style="text-align:center">很高</td><td style="text-align:center">混合型</td><td style="text-align:center">很高</td><td style="text-align:center">很高</td><td style="text-align:center">任意形状</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">BIRCH</td><td style="text-align:center">较高</td><td style="text-align:center">数值型</td><td style="text-align:center">较低</td><td style="text-align:center">较低</td><td style="text-align:center">球形</td><td style="text-align:center">很高</td></tr><tr><td style="text-align:center">CURE</td><td style="text-align:center">较高</td><td style="text-align:center">数值型</td><td style="text-align:center">一般</td><td style="text-align:center">很高</td><td style="text-align:center">任意形状</td><td style="text-align:center">较高</td></tr><tr><td style="text-align:center">K-PROTOTYPES</td><td style="text-align:center">一般</td><td style="text-align:center">混合型</td><td style="text-align:center">较低</td><td style="text-align:center">较低</td><td style="text-align:center">任意形状</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">DENCLUE</td><td style="text-align:center">较低</td><td style="text-align:center">数值型</td><td style="text-align:center">较高</td><td style="text-align:center">一般</td><td style="text-align:center">任意形状</td><td style="text-align:center">较高</td></tr><tr><td style="text-align:center">OPTIGRID</td><td style="text-align:center">一般</td><td style="text-align:center">数值型</td><td style="text-align:center">较高</td><td style="text-align:center">一般</td><td style="text-align:center">任意形状</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">CLIQUE</td><td style="text-align:center">较高</td><td style="text-align:center">数值型</td><td style="text-align:center">较高</td><td style="text-align:center">较高</td><td style="text-align:center">任意形状</td><td style="text-align:center">较低</td></tr><tr><td style="text-align:center">DBSCAN</td><td style="text-align:center">一般</td><td style="text-align:center">数值型</td><td style="text-align:center">较低</td><td style="text-align:center">较高</td><td style="text-align:center">任意形状</td><td style="text-align:center">一般</td></tr><tr><td style="text-align:center">CLARANS</td><td style="text-align:center">较低</td><td style="text-align:center">数值型</td><td style="text-align:center">较低</td><td style="text-align:center">较高</td><td style="text-align:center">球形</td><td style="text-align:center">较低</td></tr></tbody></table></div><h3 id="2-21-7-四种常用聚类方法之比较"><a href="#2-21-7-四种常用聚类方法之比较" class="headerlink" title="2.21.7 四种常用聚类方法之比较"></a>2.21.7 四种常用聚类方法之比较</h3><pre><code>聚类就是按照某个特定标准把一个数据集分割成不同的类或簇，使得同一个簇内的数据对象的相似性尽可能大，同时不在同一个簇中的数据对象的差异性也尽可能地大。即聚类后同一类的数据尽可能聚集到一起，不同类数据尽量分离。主要的聚类算法可以划分为如下几类：划分方法、层次方法、基于密度的方法、基于网格的方法以及基于模型的方法。下面主要对k-means聚类算法、凝聚型层次聚类算法、神经网络聚类算法之SOM,以及模糊聚类的FCM算法通过通用测试数据集进行聚类效果的比较和分析。</code></pre><h3 id="2-21-8-k-means聚类算法"><a href="#2-21-8-k-means聚类算法" class="headerlink" title="2.21.8 k-means聚类算法"></a>2.21.8 k-means聚类算法</h3><p>k-means是划分方法中较经典的聚类算法之一。由于该算法的效率高，所以在对大规模数据进行聚类时被广泛应用。目前，许多算法均围绕着该算法进行扩展和改进。<br>k-means算法以k为参数，把n个对象分成k个簇，使簇内具有较高的相似度，而簇间的相似度较低。k-means算法的处理过程如下：首先，随机地 选择k个对象，每个对象初始地代表了一个簇的平均值或中心;对剩余的每个对象，根据其与各簇中心的距离，将它赋给最近的簇;然后重新计算每个簇的平均值。 这个过程不断重复，直到准则函数收敛。通常，采用平方误差准则，其定义如下：</p><script type="math/tex; mode=display">E=\sum_{i=1}^{k}\sum_{p\in C_i}\left\|p-m_i\right\|^2</script><p>　这里E是数据中所有对象的平方误差的总和，p是空间中的点，$m_i$是簇$C_i$的平均值[9]。该目标函数使生成的簇尽可能紧凑独立，使用的距离度量是欧几里得距离，当然也可以用其他距离度量。</p><p><strong>算法流程</strong>：<br>    输入：包含n个对象的数据和簇的数目k；<br>    输出：n个对象到k个簇，使平方误差准则最小。<br>    步骤：<br>　　(1) 任意选择k个对象作为初始的簇中心；<br>　　(2) 根据簇中对象的平均值，将每个对象(重新)赋予最类似的簇；<br>　　(3) 更新簇的平均值，即计算每个簇中对象的平均值；<br>　　(4) 重复步骤(2)、(3)直到簇中心不再变化；</p><h3 id="2-21-9-层次聚类算法"><a href="#2-21-9-层次聚类算法" class="headerlink" title="2.21.9 层次聚类算法"></a>2.21.9 层次聚类算法</h3><pre><code>根据层次分解的顺序是自底向上的还是自上向下的，层次聚类算法分为凝聚的层次聚类算法和分裂的层次聚类算法。</code></pre><p>　凝聚型层次聚类的策略是先将每个对象作为一个簇，然后合并这些原子簇为越来越大的簇，直到所有对象都在一个簇中，或者某个终结条件被满足。绝大多数层次聚类属于凝聚型层次聚类，它们只是在簇间相似度的定义上有所不同。</p><p><strong>算法流程</strong>：</p><p>注：以采用最小距离的凝聚层次聚类算法为例：</p><p>　(1) 将每个对象看作一类，计算两两之间的最小距离；<br>　(2) 将距离最小的两个类合并成一个新类；<br>　(3) 重新计算新类与所有类之间的距离；<br>　(4) 重复(2)、(3)，直到所有类最后合并成一类。</p><h3 id="2-21-10-SOM聚类算法"><a href="#2-21-10-SOM聚类算法" class="headerlink" title="2.21.10 SOM聚类算法"></a>2.21.10 SOM聚类算法</h3><pre><code>SOM神经网络[11]是由芬兰神经网络专家Kohonen教授提出的，该算法假设在输入对象中存在一些拓扑结构或顺序，可以实现从输入空间(n维)到输出平面(2维)的降维映射，其映射具有拓扑特征保持性质,与实际的大脑处理有很强的理论联系。SOM网络包含输入层和输出层。输入层对应一个高维的输入向量，输出层由一系列组织在2维网格上的有序节点构成，输入节点与输出节点通过权重向量连接。 学习过程中，找到与之距离最短的输出层单元，即获胜单元，对其更新。同时，将邻近区域的权值更新，使输出节点保持输入向量的拓扑特征。</code></pre><p><strong>算法流程</strong>：</p><pre><code>(1) 网络初始化，对输出层每个节点权重赋初值；(2) 从输入样本中随机选取输入向量并且归一化，找到与输入向量距离最小的权重向量；(3) 定义获胜单元，在获胜单元的邻近区域调整权重使其向输入向量靠拢；(4) 提供新样本、进行训练；(5) 收缩邻域半径、减小学习率、重复，直到小于允许值，输出聚类结果。</code></pre><h3 id="2-21-11-FCM聚类算法"><a href="#2-21-11-FCM聚类算法" class="headerlink" title="2.21.11 FCM聚类算法"></a>2.21.11 FCM聚类算法</h3><pre><code>1965年美国加州大学柏克莱分校的扎德教授第一次提出了‘集合’的概念。经过十多年的发展，模糊集合理论渐渐被应用到各个实际应用方面。为克服非此即彼的分类缺点，出现了以模糊集合论为数学基础的聚类分析。用模糊数学的方法进行聚类分析，就是模糊聚类分析[12]。  FCM算法是一种以隶属度来确定每个数据点属于某个聚类程度的算法。该聚类算法是传统硬聚类算法的一种改进。  设数据集$X=&#123;x_1,x_2,...,x_n&#125;$,它的模糊$c$划分可用模糊矩阵$U=[u_&#123;ij&#125;]$表示，矩阵$U$的元素$u_&#123;ij&#125;$表示第$j(j=1,2,...,n)$个数据点属于第$i(i=1,2,...,c)$类的隶属度，$u_&#123;ij&#125;$满足如下条件：  </code></pre><script type="math/tex; mode=display">\begin{equation}\left\{\begin{array}{lr}\sum_{i=1}^c u_{ij}=1 \quad\forall~j\\u_{ij}\in[0,1] \quad\forall ~i,j\\\sum_{j=1}^c u_{ij}>0 \quad\forall ~i\end{array}\right.\end{equation}</script><p>目前被广泛使用的聚类准则是取类内加权误差平方和的极小值。即：</p><script type="math/tex; mode=display">(min)J_m(U,V)=\sum^n_{j=1}\sum^c_{i=1}u^m_{ij}d^2_{ij}(x_j,v_i)</script><p>其中$V$为聚类中心，$m$为加权指数，$d_{ij}(x_j,v_i)=||v_i-x_j||$。</p><p><strong>算法流程</strong>：</p><p>　(1) 标准化数据矩阵；<br>　(2) 建立模糊相似矩阵，初始化隶属矩阵；<br>　(3) 算法开始迭代，直到目标函数收敛到极小值；<br>　(4) 根据迭代结果，由最后的隶属矩阵确定数据所属的类，显示最后的聚类结果。</p><h3 id="2-21-12-四种聚类算法试验"><a href="#2-21-12-四种聚类算法试验" class="headerlink" title="2.21.12 四种聚类算法试验"></a>2.21.12 四种聚类算法试验</h3><pre><code>选取专门用于测试分类、聚类算法的国际通用的UCI数据库中的IRIS数据集，IRIS数据集包含150个样本数据，分别取自三种不同 的莺尾属植物setosa、versicolor和virginica的花朵样本,每个数据含有4个属性，即萼片长度、萼片宽度、花瓣长度、花瓣宽度，单位为cm。 在数据集上执行不同的聚类算法，可以得到不同精度的聚类结果。基于前面描述的各算法原理及流程，可初步得如下聚类结果。</code></pre><div class="table-container"><table><thead><tr><th>聚类方法</th><th>聚错样本数</th><th>运行时间/s</th><th>平均准确率/（%）</th></tr></thead><tbody><tr><td>K-means</td><td>17</td><td>0.146001</td><td>89</td></tr><tr><td>层次聚类</td><td>51</td><td>0.128744</td><td>66</td></tr><tr><td>SOM</td><td>22</td><td>5.267283</td><td>86</td></tr><tr><td>FCM</td><td>12</td><td>0.470417</td><td>92</td></tr></tbody></table></div><p><strong>注</strong>：</p><p>(1) 聚错样本数：总的聚错的样本数，即各类中聚错的样本数的和；<br>(2) 运行时间：即聚类整个过程所耗费的时间，单位为s；<br>(3) 平均准确度：设原数据集有k个类,用$c_i$表示第i类，$n_i$为$c_i$中样本的个数，$m_i$为聚类正确的个数,则$m_i/n_i$为 第i类中的精度，则平均精度为：$avg=\frac{1}{k}\sum_{i=1}^{k}\frac{m_{i}}{n_{i}}$。  </p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深度学习500问-ch1</title>
      <link href="/p/d306.html"/>
      <url>/p/d306.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="向量和矩阵"><a href="#向量和矩阵" class="headerlink" title="向量和矩阵"></a>向量和矩阵</h2><h3 id="标量、向量、矩阵、张量之间的联系"><a href="#标量、向量、矩阵、张量之间的联系" class="headerlink" title="标量、向量、矩阵、张量之间的联系"></a>标量、向量、矩阵、张量之间的联系</h3><p>标量：一个单独的数。</p><p>向量：一组有序排列的数，通过次序中的索引，可以确定每个单独的数。</p><p>矩阵：具有相同特征和维度的对象的集合，一个对象为一行，一个特征为一列，特征都有数值型的取值。</p><p>张量：超过二维。</p><p>关系：</p><blockquote><p>标量 = 0阶张量</p><p>向量 = 1阶张量</p></blockquote><h3 id="张量与矩阵的区别"><a href="#张量与矩阵的区别" class="headerlink" title="张量与矩阵的区别"></a>张量与矩阵的区别</h3><ul><li>代数的角度，矩阵是向量的推广。</li><li>几何的角度，矩阵是一个几何量，不随参照系坐标变换而变化，向量也具有。</li><li>张量可以用$3\times3$矩阵的形式来表达。</li><li>标量和向量的三维数组可以看成$1\times1$，$3\times3$的矩阵。</li></ul><h3 id="矩阵和向量相乘结果"><a href="#矩阵和向量相乘结果" class="headerlink" title="矩阵和向量相乘结果"></a>矩阵和向量相乘结果</h3><p>矩阵和向量相乘可以看成是矩阵相乘的一个特殊情况</p><h3 id="向量和矩阵的范数归纳"><a href="#向量和矩阵的范数归纳" class="headerlink" title="向量和矩阵的范数归纳"></a>向量和矩阵的范数归纳</h3><p><strong>向量的范数(norm)</strong>  </p><ul><li>向量的1范数：向量的各个元素的绝对值之和</li></ul><script type="math/tex; mode=display">\Vert\vec{x}\Vert_1=\sum_{i=1}^N\vert{x_i}\vert</script><ul><li>向量的2范数：向量的每个元素的平方和再开平方根</li></ul><script type="math/tex; mode=display">\Vert\vec{x}\Vert_2=\sqrt{\sum_{i=1}^N{\vert{x_i}\vert}^2}</script><ul><li>向量的负无穷范数：向量的所有元素的绝对值中最小的</li></ul><script type="math/tex; mode=display">\Vert\vec{x}\Vert_{-\infty}=\min{|{x_i}|}</script><ul><li>向量的正无穷范数：向量的所有元素的绝对值中最大的</li></ul><script type="math/tex; mode=display">\Vert\vec{x}\Vert_{+\infty}=\max{|{x_i}|}</script><ul><li>向量的p范数：</li></ul><script type="math/tex; mode=display">L_p=\Vert\vec{x}\Vert_p=\sqrt[p]{\sum_{i=1}^{N}|{x_i}|^p}</script><p><strong>矩阵的范数</strong>  </p><p>矩阵定义为：$A_{m\times n}$，其元素为 $a_{ij}$。</p><p>矩阵的范数定义为</p><script type="math/tex; mode=display">\Vert{A}\Vert_p :=\sup_{x\neq 0}\frac{\Vert{Ax}\Vert_p}{\Vert{x}\Vert_p}</script><p>当向量取不同范数时, 相应得到了不同的矩阵范数。</p><ul><li><p><strong>矩阵的1范数（列范数）</strong>：矩阵的每一列上的元素绝对值先求和，再从中取个最大的,（列和最大）</p><script type="math/tex; mode=display">\Vert A\Vert_1=\max_{1\le j\le n}\sum_{i=1}^m|{a_{ij}}|</script></li><li><p><strong>矩阵的2范数</strong>：矩阵$A^TA$的最大特征值开平方根</p><script type="math/tex; mode=display">\Vert A\Vert_2=\sqrt{\lambda_{max}(A^T A)}</script></li></ul><p>其中， $\lambda_{max}(A^T A)$ 为 $A^T A$ 的特征值绝对值的最大值。</p><ul><li><p><strong>矩阵的无穷范数（行范数）</strong>：矩阵的每一行上的元素绝对值先求和，再从中取个最大的，（行和最大）</p><script type="math/tex; mode=display">\Vert A\Vert_{\infty}=\max_{1\le i \le m}\sum_{j=1}^n |{a_{ij}}|</script></li><li><p><strong>矩阵的核范数</strong>：矩阵的奇异值（将矩阵svd分解）之和，这个范数可以用来低秩表示（因为最小化核范数，相当于最小化矩阵的秩——低秩）</p></li><li><p><strong>矩阵的L0范数</strong>：矩阵的非0元素的个数，通常用它来表示稀疏，L0范数越小0元素越多，也就越稀疏</p></li><li><strong>矩阵的L1范数</strong>：矩阵中的每个元素绝对值之和，它是L0范数的最优凸近似，因此它也可以表示稀疏</li><li><strong>矩阵的F范数</strong>：矩阵的各个元素平方之和再开平方根，它通常也叫做矩阵的L2范数，它的优点在于它是一个凸函数，可以求导求解，易于计算</li></ul><script type="math/tex; mode=display">\Vert A\Vert_F=\sqrt{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^2)}</script><ul><li><strong>矩阵的L21范数</strong>：矩阵先以每一列为单位，求每一列的F范数（也可认为是向量的2范数），然后再将得到的结果求L1范数（也可认为是向量的1范数），很容易看出它是介于L1和L2之间的一种范数</li><li><strong>矩阵的 p范数</strong> </li></ul><script type="math/tex; mode=display">\Vert A\Vert_p=\sqrt[p]{(\sum_{i=1}^m\sum_{j=1}^n{| a_{ij}|}^p)}</script><h3 id="如何判断一个矩阵为正定"><a href="#如何判断一个矩阵为正定" class="headerlink" title="如何判断一个矩阵为正定"></a>如何判断一个矩阵为正定</h3><p>判定一个矩阵是否为正定，通常有以下几个方面：  </p><ul><li>顺序主子式全大于0；  </li><li>存在可逆矩阵$C$使$C^TC$等于该矩阵；</li><li>正惯性指数等于$n$；</li><li>合同于单位矩阵$E$（即：规范形为$E$）</li><li>标准形中主对角元素全为正；</li><li>特征值全为正；</li><li>是某基的度量矩阵。</li></ul><h2 id="导数和偏导数"><a href="#导数和偏导数" class="headerlink" title="导数和偏导数"></a>导数和偏导数</h2><h3 id="导数偏导计算"><a href="#导数偏导计算" class="headerlink" title="导数偏导计算"></a>导数偏导计算</h3><h3 id="导数和偏导数有什么区别？"><a href="#导数和偏导数有什么区别？" class="headerlink" title="导数和偏导数有什么区别？"></a>导数和偏导数有什么区别？</h3><h2 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h2><h3 id="特征值分解与特征向量"><a href="#特征值分解与特征向量" class="headerlink" title="特征值分解与特征向量"></a>特征值分解与特征向量</h3><p>特征值分解是将一个矩阵分解为如下形式： </p><script type="math/tex; mode=display">A=Q\sum Q^{-1}</script><p>其中，$Q$是这个矩阵$A$的特征向量组成的矩阵，$\sum$是一个对角矩阵，每一个对角线元素就是一个特征值，里面的特征值是由大到小排列的。</p><h3 id="奇异值与特征值有什么关系"><a href="#奇异值与特征值有什么关系" class="headerlink" title="奇异值与特征值有什么关系"></a>奇异值与特征值有什么关系</h3><p>那么奇异值和特征值是怎么对应起来的呢？我们将一个矩阵$A$的转置乘以$A$，并对$A^TA$求特征值，则有下面的形式：</p><script type="math/tex; mode=display">(A^TA)V = \lambda V</script><p>这里$V$就是上面的右奇异向量，另外还有：</p><script type="math/tex; mode=display">\sigma_i = \sqrt{\lambda_i}, u_i=\frac{1}{\sigma_i}AV</script><p>这里的$\sigma$就是奇异值，$u$就是上面说的左奇异向量。<br>奇异值$\sigma$跟特征值类似，在矩阵$\sum$中也是从大到小排列，而且$\sigma$的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前$r$（$r$远小于$m、n$）个的奇异值来近似描述矩阵，即部分奇异值分解：</p><script type="math/tex; mode=display">A_{m\times n}\approx U_{m \times r}\sum_{r\times r}V_{r \times n}^T</script><p>右边的三个矩阵相乘的结果将会是一个接近于$A$的矩阵，在这儿，$r$越接近于$n$，则相乘的结果越接近于$A$。</p><h2 id="概率分布与随机变量"><a href="#概率分布与随机变量" class="headerlink" title="概率分布与随机变量"></a>概率分布与随机变量</h2><h3 id="机器学习为什么要使用概率"><a href="#机器学习为什么要使用概率" class="headerlink" title="机器学习为什么要使用概率"></a>机器学习为什么要使用概率</h3><h3 id="变量与随机变量有什么区别"><a href="#变量与随机变量有什么区别" class="headerlink" title="变量与随机变量有什么区别"></a>变量与随机变量有什么区别</h3><h3 id="随机变量与概率分布的联系"><a href="#随机变量与概率分布的联系" class="headerlink" title="随机变量与概率分布的联系"></a>随机变量与概率分布的联系</h3><h3 id="离散型随机变量和概率质量函数"><a href="#离散型随机变量和概率质量函数" class="headerlink" title="离散型随机变量和概率质量函数"></a>离散型随机变量和概率质量函数</h3><h3 id="连续型随机变量和概率密度函数"><a href="#连续型随机变量和概率密度函数" class="headerlink" title="连续型随机变量和概率密度函数"></a>连续型随机变量和概率密度函数</h3><h3 id="举例理解条件概率"><a href="#举例理解条件概率" class="headerlink" title="举例理解条件概率"></a>举例理解条件概率</h3><h3 id="联合概率与边缘概率联系区别"><a href="#联合概率与边缘概率联系区别" class="headerlink" title="联合概率与边缘概率联系区别"></a>联合概率与边缘概率联系区别</h3><p><strong>区别：</strong><br>联合概率：联合概率指类似于$P(X=a,Y=b)$这样，包含多个条件，且所有条件同时成立的概率。联合概率是指在多元的概率分布中多个随机变量分别满足各自条件的概率。<br>边缘概率：边缘概率是某个事件发生的概率，而与其它事件无关。边缘概率指类似于$P(X=a)$，$P(Y=b)$这样，仅与单个随机变量有关的概率。</p><p><strong>联系：</strong><br>联合分布可求边缘分布，但若只知道边缘分布，无法求得联合分布。  </p><h3 id="1-4-8-条件概率的链式法则"><a href="#1-4-8-条件概率的链式法则" class="headerlink" title="1.4.8 条件概率的链式法则"></a>1.4.8 条件概率的链式法则</h3><h3 id="1-4-9-独立性和条件独立性"><a href="#1-4-9-独立性和条件独立性" class="headerlink" title="1.4.9 独立性和条件独立性"></a>1.4.9 独立性和条件独立性</h3><p><strong>独立性</strong><br>两个随机变量$x$和$y$，概率分布表示成两个因子乘积形式，一个因子只包含$x$，另一个因子只包含$y$，两个随机变量相互独立(independent)。<br><strong>条件有时为不独立的事件之间带来独立，有时也会把本来独立的事件，因为此条件的存在，而失去独立性。</strong><br>举例：$P(XY)=P(X)P(Y)$, 事件$X$和事件$Y$独立。此时给定$Z$，</p><script type="math/tex; mode=display">P(X,Y|Z) \not = P(X|Z)P(Y|Z)</script><p>事件独立时，联合概率等于概率的乘积。这是一个非常好的数学性质，然而不幸的是，无条件的独立是十分稀少的，因为大部分情况下，事件之间都是互相影响的。 </p><p><strong>条件独立性</strong><br>给定$Z$的情况下,$X$和$Y$条件独立，当且仅当</p><script type="math/tex; mode=display">X\bot Y|Z \iff P(X,Y|Z) = P(X|Z)P(Y|Z)</script><p>$X$和$Y$的关系依赖于$Z$，而不是直接产生。  </p><blockquote><p><strong>举例</strong>定义如下事件：<br>$X$：明天下雨；<br>$Y$：今天的地面是湿的；<br>$Z$：今天是否下雨；<br>$Z$事件的成立，对$X$和$Y$均有影响，然而，在$Z$事件成立的前提下，今天的地面情况对明天是否下雨没有影响。 </p></blockquote><h2 id="常见概率分布"><a href="#常见概率分布" class="headerlink" title="常见概率分布"></a>常见概率分布</h2><h3 id="Bernoulli分布"><a href="#Bernoulli分布" class="headerlink" title="Bernoulli分布"></a>Bernoulli分布</h3><h3 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h3><p>高斯也叫正态分布(Normal Distribution), 概率度函数如下:  </p><script type="math/tex; mode=display">N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi\sigma^2}}exp\left ( -\frac{1}{2\sigma^2}(x-\mu)^2 \right )</script><p>其中, $\mu$和$\sigma$分别是均值和标准差, 中心峰值x坐标由$\mu$给出, 峰的宽度受$\sigma$控制, 最大点在$x=\mu$处取得, 拐点为$x=\mu\pm\sigma$</p><p><strong>正态分布中，±1$\sigma$、±2$\sigma$、±3$\sigma$下的概率分别是68.3%、95.5%、99.73%，这3个数最好记住。</strong> </p><p>此外, 令$\mu=0,\sigma=1$高斯分布即简化为标准正态分布: </p><script type="math/tex; mode=display">N(x;\mu,\sigma^2) = \sqrt{\frac{1}{2\pi}}exp\left ( -\frac{1}{2}x^2 \right )</script><p>对概率密度函数高效求值: </p><script type="math/tex; mode=display">N(x;\mu,\beta^{-1})=\sqrt{\frac{\beta}{2\pi}}exp\left(-\frac{1}{2}\beta(x-\mu)^2\right)</script><p>其中，$\beta=\frac{1}{\sigma^2}$通过参数$\beta∈（0，\infty）$来控制分布精度。</p><h3 id="何时采用正态分布"><a href="#何时采用正态分布" class="headerlink" title="何时采用正态分布"></a>何时采用正态分布</h3><p>问: 何时采用正态分布?<br>答: 缺乏实数上分布的先验知识, 不知选择何种形式时, 默认选择正态分布总是不会错的, 理由如下: </p><ol><li>中心极限定理告诉我们, 很多独立随机变量均近似服从正态分布, 现实中很多复杂系统都可以被建模成正态分布的噪声, 即使该系统可以被结构化分解. </li><li>正态分布是具有相同方差的所有概率分布中, 不确定性最大的分布, 换句话说, 正态分布是对模型加入先验知识最少的分布.</li></ol><p>正态分布的推广:<br>正态分布可以推广到$R^n$空间, 此时称为<strong>多位正态分布</strong>, 其参数是一个正定对称矩阵$\Sigma$: </p><script type="math/tex; mode=display">N(x;\vec\mu,\Sigma)=\sqrt{\frac{1}{(2\pi)^ndet(\Sigma)}}exp\left(-\frac{1}{2}(\vec{x}-\vec{\mu})^T\Sigma^{-1}(\vec{x}-\vec{\mu})\right)</script><p>对多为正态分布概率密度高效求值: </p><script type="math/tex; mode=display">N(x;\vec{\mu},\vec\beta^{-1}) = \sqrt{det(\vec\beta)}{(2\pi)^n}exp\left(-\frac{1}{2}(\vec{x}-\vec\mu)^T\beta(\vec{x}-\vec\mu)\right)</script><p>此处，$\vec\beta$是一个精度矩阵。</p><h3 id="指数分布"><a href="#指数分布" class="headerlink" title="指数分布"></a>指数分布</h3><h3 id="Laplace-分布（拉普拉斯分布）"><a href="#Laplace-分布（拉普拉斯分布）" class="headerlink" title="Laplace 分布（拉普拉斯分布）"></a>Laplace 分布（拉普拉斯分布）</h3><p>一个联系紧密的概率分布是 Laplace 分布（Laplace distribution），它允许我们在任意一点 $\mu$处设置概率质量的峰值</p><script type="math/tex; mode=display">Laplace(x;\mu;\gamma)=\frac{1}{2\gamma}exp\left(-\frac{|x-\mu|}{\gamma}\right)</script><h3 id="Dirac分布和经验分布"><a href="#Dirac分布和经验分布" class="headerlink" title="Dirac分布和经验分布"></a>Dirac分布和经验分布</h3><h2 id="期望、方差、协方差、相关系数"><a href="#期望、方差、协方差、相关系数" class="headerlink" title="期望、方差、协方差、相关系数"></a>期望、方差、协方差、相关系数</h2><h3 id="期望"><a href="#期望" class="headerlink" title="期望"></a>期望</h3><p>函数的期望大于等于期望的函数（Jensen（詹森）不等式，即$E(f(x))\geqslant f(E(x))$  </p><h3 id="方差"><a href="#方差" class="headerlink" title="方差"></a>方差</h3><h3 id="协方差"><a href="#协方差" class="headerlink" title="协方差"></a>协方差</h3><h3 id="相关系数"><a href="#相关系数" class="headerlink" title="相关系数"></a>相关系数</h3>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 常用函数</title>
      <link href="/p/312d.html"/>
      <url>/p/312d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="PyTorch"><a href="#PyTorch" class="headerlink" title="PyTorch"></a>PyTorch</h1><h2 id="torch"><a href="#torch" class="headerlink" title="torch"></a>torch</h2><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><ul><li><p><strong>torch.numel</strong></p><p><strong>torch.numel(input)-&gt;int</strong></p><p>返回<code>input</code> 张量中的元素个数</p><blockquote><p>>>> a = torch.randn(1,2,3,4,5)</p><p>>>> torch.numel(a) </p><p>120</p><p>>>> a = torch.zeros(4,4)</p><p>>>> torch.numel(a) </p><p>16</p></blockquote></li><li></li></ul><h3 id="Creation-Ops"><a href="#Creation-Ops" class="headerlink" title="Creation Ops"></a>Creation Ops</h3><ul><li><p><strong>torch.arange</strong></p><p><strong>torch.arange(start, end, step=1, out=None) → Tensor</strong></p><p>返回一个1维张量，长度为 ( floor((end−start)/step) )。包含从 <strong>start</strong>到 <strong>end</strong>，以 <strong>step</strong> 为步长的一组序列值(默认步长为1)。</p><blockquote><p>参数:</p><ul><li>start (float) – 序列的起始点</li><li>end (float) – 序列的终止点</li><li>step (float) – 相邻点的间隔大小</li><li>out (Tensor, optional) – 结果张量</li></ul></blockquote></li></ul><hr><h3 id="Indexing-Slicing-Joining-Mutating-Ops"><a href="#Indexing-Slicing-Joining-Mutating-Ops" class="headerlink" title="Indexing, Slicing, Joining, Mutating Ops"></a>Indexing, Slicing, Joining, Mutating Ops</h3><ul><li><p><strong>torch.cat</strong></p><p>torch.cat(inputs, dimension=0)</p><p>在给定维度上对输入的张量序列<code>seq</code> 进行连接操作。</p><p><code>torch.cat()</code>可以看做 <code>torch.split()</code> 和 <code>torch.chunk()</code>的反操作。 <code>cat()</code> 函数可以通过下面例子更好的理解。</p><blockquote><p>参数:</p><ul><li>inputs (<em>sequence of Tensors</em>) – 可以是任意相同Tensor 类型的python 序列</li><li>dimension (<em>int</em>, <em>optional</em>) – 沿着此维连接张量序列。</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = torch.randn(2, 3)</span><br><span class="line">&gt;&gt;&gt; x</span><br><span class="line"> 0.5983 -0.0341  2.4918</span><br><span class="line"> 1.5981 -0.5265 -0.8735</span><br><span class="line">[torch.FloatTensor of size 2x3]</span><br><span class="line">&gt;&gt;&gt; torch.cat((x, x, x), 0)</span><br><span class="line"> 0.5983 -0.0341  2.4918</span><br><span class="line"> 1.5981 -0.5265 -0.8735</span><br><span class="line"> 0.5983 -0.0341  2.4918</span><br><span class="line"> 1.5981 -0.5265 -0.8735</span><br><span class="line"> 0.5983 -0.0341  2.4918</span><br><span class="line"> 1.5981 -0.5265 -0.8735</span><br><span class="line">[torch.FloatTensor of size 6x3]</span><br><span class="line">&gt;&gt;&gt; torch.cat((x, x, x), 1)</span><br><span class="line"> 0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918  0.5983 -0.0341  2.4918</span><br><span class="line"> 1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735  1.5981 -0.5265 -0.8735</span><br><span class="line">[torch.FloatTensor of size 2x9]</span><br></pre></td></tr></table></figure></li><li><p><strong>torch.split</strong></p><p><strong>torch.split(tensor, split_size, dim=0)</strong></p><p>将输入张量分割成相等形状的chunks（如果可分）。 如果沿指定维的张量形状大小不能被 <strong>split_size</strong> 整分， 则最后一个分块会小于其它分块。</p><blockquote><p>参数:</p><ul><li>tensor (Tensor) – 待分割张量</li><li>split_size (int) – 单个分块的形状大小</li><li>dim (int) – 沿着此维进行分割</li></ul></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = torch.zeros(2,1,2,1,2)</span><br><span class="line">&gt;&gt;&gt; x.size()</span><br><span class="line">(2L, 1L, 2L, 1L, 2L)</span><br><span class="line">&gt;&gt;&gt; y = torch.squeeze(x)</span><br><span class="line">&gt;&gt;&gt; y.size()</span><br><span class="line">(2L, 2L, 2L)</span><br><span class="line">&gt;&gt;&gt; y = torch.squeeze(x, 0)</span><br><span class="line">&gt;&gt;&gt; y.size()</span><br><span class="line">(2L, 1L, 2L, 1L, 2L)</span><br><span class="line">&gt;&gt;&gt; y = torch.squeeze(x, 1)</span><br><span class="line">&gt;&gt;&gt; y.size()</span><br><span class="line">(2L, 2L, 1L, 2L)</span><br></pre></td></tr></table></figure></li><li><p><strong>torch.stack</strong></p><p><strong>torch.stack(sequence, dim=0)</strong></p><p>沿着一个新维度对输入张量序列进行连接。 序列中所有的张量都应该为相同形状。</p><blockquote><p>  参数:</p><ul><li>sequence (Sequence) – 待连接的张量序列</li><li>dim (int) – 插入的维度。必须介于 0 与 待连接的张量序列数之间。</li></ul></blockquote></li></ul><hr><h3 id="Math-operations"><a href="#Math-operations" class="headerlink" title="Math operations"></a>Math operations</h3><h3 id="PointWise-Ops"><a href="#PointWise-Ops" class="headerlink" title="PointWise Ops"></a>PointWise Ops</h3><ul><li><p><strong>torch.tanh</strong></p><p><strong>torch.tanh(input, out=None) → Tensor</strong></p><p>返回一个新张量，包含输入 <strong>input</strong> 张量每个元素的双曲正切。</p><blockquote><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>out (Tensor, optional) – 输出张量</li></ul></blockquote></li><li></li></ul><h3 id="Reduction-Ops"><a href="#Reduction-Ops" class="headerlink" title="Reduction Ops"></a>Reduction Ops</h3><ul><li><p><strong>torch.mean</strong></p><p><strong>torch.mean(input) → float</strong></p><p>返回输入张量所有元素的均值</p><p><strong>补充一个经验教训，当input.numel = 0的时候，则返回nan</strong></p><blockquote><p>参数： input (Tensor) – 输入张量</p><p>>>>a = torch.randn(1, 3)</p><p>>>>a </p><p>-0.2946 -0.9143  2.1809 </p><p>[torch.FloatTensor of size 1x3]</p><p>>>>torch.mean(a) </p><p>0.32398951053619385</p></blockquote><p><strong>torch.mean(input, dim, out=None) → Tensor</strong></p><p>返回输入张量给定维度<code>dim</code>上每行的均值</p><p>输出形状与输入相同，除了给定维度上为1</p><blockquote><p>参数：</p><ul><li>input (Tensor) – 输入张量</li><li>dim (int) – the dimension to reduce</li><li>out (Tensor, optional) – 结果张量</li></ul><p>>>> a = torch.randn(4, 4) </p><p>>>> a</p><p>-1.2738 -0.3058  0.1230 -1.9615</p><p>0.8771 -0.5430 -0.9233  0.9879 </p><p>1.4107  0.0317 -0.6823  0.2255 </p><p>-1.3854  0.4953 -0.2160  0.2435 </p><p>[torch.FloatTensor of size 4x4] </p><p>>>> torch.mean(a, 1) </p><p>-0.8545 </p><p>0.0997 </p><p>0.2464 </p><p>-0.2157 </p><p>[torch.FloatTensor of size 4x1]</p></blockquote></li><li></li></ul><hr><h2 id="torch-Tensor"><a href="#torch-Tensor" class="headerlink" title="torch.Tensor"></a>torch.Tensor</h2><ul><li><p><strong>expand(*sizes)</strong></p><p>返回tensor的一个新视图，单个维度扩大为更大的尺寸。 tensor也可以扩大为更高维，新增加的维度将附在前面。 扩大tensor不需要分配新内存，只是仅仅新建一个tensor的视图，其中通过将<code>stride</code>设为0，一维将会扩展位更高维。任何一个一维的在不分配新内存情况下可扩展为任意的数值。</p><blockquote><p><strong>参数：</strong> </p><ul><li><strong>sizes(torch.Size or int…)</strong>-需要扩展的大小</li></ul></blockquote></li></ul><hr><h2 id="torch-nn"><a href="#torch-nn" class="headerlink" title="torch.nn"></a>torch.nn</h2><h3 id="torch-nn-Conv2d"><a href="#torch-nn-Conv2d" class="headerlink" title="torch.nn.Conv2d"></a>torch.nn.Conv2d</h3><p><strong>torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)</strong>]</p><p><strong>Parameters：</strong></p><ul><li>in_channels(<code>int</code>) – 输入信号的通道</li><li>out_channels(<code>int</code>) – 卷积产生的通道</li><li>kerner_size(<code>int</code> or <code>tuple</code>) - 卷积核的尺寸</li><li>stride(<code>int</code> or <code>tuple</code>, <code>optional</code>) - 卷积步长</li><li>padding(<code>int</code> or <code>tuple</code>, <code>optional</code>) - 输入的每一条边补充0的层数</li><li>dilation(<code>int</code> or <code>tuple</code>, <code>optional</code>) – 卷积核元素之间的间距</li><li>groups(<code>int</code>, <code>optional</code>) – 从输入通道到输出通道的阻塞连接数</li><li>bias(<code>bool</code>, <code>optional</code>) - 如果<code>bias=True</code>，添加偏置</li></ul><h3 id="torch-nn-normalization"><a href="#torch-nn-normalization" class="headerlink" title="torch.nn.normalization"></a>torch.nn.normalization</h3><p>Norm 归一化层 <a href="https://blog.csdn.net/shanglianlm/article/details/85075706">链接</a></p><blockquote><p>BN，LN，IN，GN从学术化上解释差异：<br>BatchNorm：batch方向做归一化，算NHW的均值，对小batchsize效果不好；BN主要缺点是对batchsize的大小比较敏感，由于每次计算均值和方差是在一个batch上，所以如果batchsize太小，则计算的均值、方差不足以代表整个数据分布<br>LayerNorm：channel方向做归一化，算CHW的均值，主要对RNN作用明显；<br>InstanceNorm：一个channel内做归一化，算H*W的均值，用在风格化迁移；因为在图像风格化中，生成结果主要依赖于某个图像实例，所以对整个batch归一化不适合图像风格化中，因而对HW做归一化。可以加速模型收敛，并且保持每个图像实例之间的独立。<br>GroupNorm：将channel方向分group，然后每个group内做归一化，算(C//G)HW的均值；这样与batchsize无关，不受其约束。<br>SwitchableNorm是将BN、LN、IN结合，赋予权重，让网络自己去学习归一化层应该使用什么方法。</p></blockquote><p><strong>nn.GroupNorm</strong></p><ul><li><strong>torch.nn.GroupNorm(<em>num_groups</em>, <em>num_channels</em>, <em>eps=1e-05</em>, <em>affine=True</em>, <em>device=None</em>, <em>dtype=None</em>)</strong> <a href="https://pytorch.org/docs/stable/generated/torch.nn.GroupNorm.html">链接</a></li></ul><blockquote><ul><li><strong>num_groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – number of groups to separate the channels into</li><li><strong>num_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int"><em>int</em></a>) – number of channels expected in input</li><li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li><li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable per-channel affine parameters initialized to ones (for weights) and zeros (for biases). Default: <code>True</code>.</li></ul></blockquote><p><strong>nn.BatchNorm</strong></p><ul><li><p><strong>torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</strong></p></li><li><p><strong>torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</strong></p><p>对小批量(mini-batch)3d数据组成的4d输入进行批标准化(Batch Normalization)操作</p><script type="math/tex; mode=display">y = \frac{x - mean[x]}{ \sqrt{Var[x]} + \epsilon} * gamma + beta</script><p>在每一个小批量（mini-batch）数据中，计算输入各个维度的均值和标准差。gamma与beta是可学习的大小为C的参数向量（C为输入大小）</p><p>在训练时，该层计算每次输入的均值与方差，并进行移动平均。移动平均默认的动量值为0.1。</p><p>在验证时，训练求得的均值/方差将用于标准化验证数据</p></li><li><p><strong>torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)</strong></p></li></ul><blockquote><p>num_features： 来自期望输入的特征数，该期望输入的大小为’batch_size x num_features [x width]’<br>eps： 为保证数值稳定性（分母不能趋近或取0）,给分母加上的值。默认为1e-5。<br>momentum： 动态均值和动态方差所使用的动量。默认为0.1。<br>affine： 布尔值，当设为true，给该层添加可学习的仿射变换参数。<br>track_running_stats：布尔值，当设为true，记录训练过程中的均值和方差；</p></blockquote><p><strong>nn.InstanceNorm2d</strong> <a href="https://pytorch.org/docs/stable/generated/torch.nn.InstanceNorm2d.html">链接</a></p><p><strong>torch.nn.InstanceNorm2d(<em>num_features</em>, <em>eps=1e-05</em>, <em>momentum=0.1</em>, <em>affine=False</em>, <em>track_running_stats=False</em>, <em>device=None</em>, <em>dtype=None</em>)</strong></p><blockquote><ul><li><strong>num_features</strong> – C from an expected input of size (N,C,H,W)</li><li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li><li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li><li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li><li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li></ul></blockquote><hr><h2 id="torch-cuda-amp"><a href="#torch-cuda-amp" class="headerlink" title="torch.cuda.amp"></a>torch.cuda.amp</h2><h3 id="torch-cuda-amp-autocast"><a href="#torch-cuda-amp-autocast" class="headerlink" title="torch.cuda.amp.autocast"></a>torch.cuda.amp.autocast</h3><p>开启自动混合精度，<a href="https://zhuanlan.zhihu.com/p/165152789">链接</a></p><p><strong>torch.cuda.amp.autocast(enabled=True)</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 前向过程(model + loss)开启 autocast</span></span><br><span class="line"><span class="keyword">with</span> autocast(~):</span><br><span class="line">    output = model(<span class="built_in">input</span>)</span><br><span class="line">    loss = loss_fn(output, target)</span><br></pre></td></tr></table></figure><p>​                                     </p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 基础函数</title>
      <link href="/p/50a7.html"/>
      <url>/p/50a7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>菜鸟教程上的<a href="https://www.runoob.com/python/python-tutorial.html">Python基础教程</a></p><p><a href="https://docs.python.org/3/tutorial/index.html">Python官方</a></p><p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400">廖雪峰</a></p><p>这里仅整理部分使用到的函数。</p><h1 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h1><h2 id="简单函数-内置-常用"><a href="#简单函数-内置-常用" class="headerlink" title="简单函数(内置+常用)"></a>简单函数(内置+常用)</h2><p><a href="https://www.runoob.com/python/python-built-in-functions.html">内置函数</a> + 常用的简单函数</p><h3 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h3><p><a href="https://www.runoob.com/python/python-func-bin.html">解析</a></p><p><strong>bin()</strong> 返回一个整数 int 或者长整数 long int 的二进制表示。(返回为字符串)</p><blockquote><p>>>>bin(10) </p><p>‘0b1010’ </p><p>>>> bin(20) </p><p>‘0b10100’</p></blockquote><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><blockquote><p><strong>sort 与 sorted 区别：</strong></p><p>sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。</p><p>list 的 sort 方法返回的是对已经存在的列表进行操作，无返回值，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。</p></blockquote><p><strong>sorted(iterable, cmp=None, key=None, reverse=False)</strong></p><blockquote><p>参数说明：</p><ul><li>iterable — 可迭代对象。</li><li>cmp — 比较的函数，这个具有两个参数，参数的值都是从可迭代对象中取出，此函数必须遵守的规则为，大于则返回1，小于则返回-1，等于则返回0。</li><li>key — 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。</li><li>reverse — 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。</li><li>out — 返回重新排列后的列表</li></ul></blockquote><h3 id="copy-deepcopy"><a href="#copy-deepcopy" class="headerlink" title="copy, deepcopy"></a>copy, deepcopy</h3><p><a href="https://www.runoob.com/w3cnote/python-understanding-dict-copy-shallow-or-deep.html">解析</a></p><ul><li><strong>直接赋值：</strong>其实就是对象的引用（别名）。</li><li><strong>浅拷贝(copy)：</strong>拷贝父对象，不会拷贝对象的内部的子对象。</li><li><strong>深拷贝(deepcopy)：</strong> copy 模块的 deepcopy 方法，完全拷贝了父对象及其子对象。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>: [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&#125;</span><br><span class="line">b = a.copy()</span><br><span class="line">a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]&#125;)</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">4</span>)</span><br><span class="line">a, b</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line"> ---</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">c = copy.deepcopy(a)</span><br><span class="line">a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line">a[<span class="number">1</span>].append(<span class="number">5</span>)</span><br><span class="line">a, c</span><br><span class="line">(&#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]&#125;, &#123;<span class="number">1</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;)</span><br><span class="line"> ---</span><br><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]] <span class="comment">#原始对象</span></span><br><span class="line"> </span><br><span class="line">b = a                       <span class="comment">#赋值，传对象的引用</span></span><br><span class="line">c = copy.copy(a)            <span class="comment">#对象拷贝，浅拷贝</span></span><br><span class="line">d = copy.deepcopy(a)        <span class="comment">#对象拷贝，深拷贝</span></span><br><span class="line"> </span><br><span class="line">a.append(<span class="number">5</span>)                 <span class="comment">#修改对象a</span></span><br><span class="line">a[<span class="number">4</span>].append(<span class="string">&#x27;c&#x27;</span>)            <span class="comment">#修改对象a中的[&#x27;a&#x27;, &#x27;b&#x27;]数组对象</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;a = &#x27;</span>, a )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;b = &#x27;</span>, b )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;c = &#x27;</span>, c )</span><br><span class="line"><span class="built_in">print</span>( <span class="string">&#x27;d = &#x27;</span>, d )</span><br><span class="line">(<span class="string">&#x27;a = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;b = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>], <span class="number">5</span>])</span><br><span class="line">(<span class="string">&#x27;c = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]])</span><br><span class="line">(<span class="string">&#x27;d = &#x27;</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>]])</span><br></pre></td></tr></table></figure><h3 id="yield"><a href="#yield" class="headerlink" title="yield"></a>yield</h3><p><a href="https://www.runoob.com/w3cnote/python-yield-used-analysis.html">解析</a></p><p>yield 的作用就是把一个函数变成一个 generator，带有 yield 的函数不再是一个普通函数，Python 解释器会将其视为一个 generator</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_file</span>(<span class="params">fpath</span>):</span> </span><br><span class="line">    BLOCK_SIZE = <span class="number">1024</span> </span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(fpath, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f: </span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>: </span><br><span class="line">            block = f.read(BLOCK_SIZE) </span><br><span class="line">            <span class="keyword">if</span> block: </span><br><span class="line">                <span class="keyword">yield</span> block </span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h3 id="contextlib"><a href="#contextlib" class="headerlink" title="contextlib"></a>contextlib</h3><p>任何对象，只要正确实现了上下文管理，就可以用于<code>with</code>语句。</p><p>实现上下文管理是通过<code>__enter__</code>和<code>__exit__</code>这两个方法实现的。</p><p>编写<code>__enter__</code>和<code>__exit__</code>仍然很繁琐，因此Python的标准库<code>contextlib</code>提供了更简单的写法。</p><p><code>@contextmanager</code>这个decorator接受一个generator，用<code>yield</code>语句把<code>with ... as var</code>把变量输出出去，然后，<code>with</code>语句就可以正常地工作了。</p><p>希望在某段代码执行前后自动执行特定代码，也可以用<code>@contextmanager</code>实现。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span>(<span class="params">name</span>):</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;&#125; COST: &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(name, end - start))</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> timer(<span class="string">&#x27;Timer PolicyIter&#x27;</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h2 id="Python-标准库"><a href="#Python-标准库" class="headerlink" title="Python 标准库"></a>Python 标准库</h2><h3 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h3><p>glob模块提供了一个函数用于从目录通配符搜索中生成文件列表:</p><blockquote><p>images = sorted(glob.glob(os.path.join(root, ‘image_2/*_10.png’)))</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumPy 常用函数</title>
      <link href="/p/f667.html"/>
      <url>/p/f667.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>import numpy as npy(<del>误</del>)</p><p>import numpy as np</p><p>菜鸟教程上对于NumPy的教程: <a href="https://www.runoob.com/numpy/numpy-tutorial.html">NumPy</a></p><p>官方的Reference:<a href="https://numpy.org/doc/stable/reference/index.html">NumPy Reference</a></p><p>这里仅整理部分使用到的函数。</p><h1 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h1><h2 id="NumPy-Ndarray对象"><a href="#NumPy-Ndarray对象" class="headerlink" title="NumPy Ndarray对象"></a><a href="https://www.runoob.com/numpy/numpy-ndarray-object.html">NumPy Ndarray对象</a></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.array(<span class="built_in">object</span>, dtype = <span class="literal">None</span>, copy = <span class="literal">True</span>, order = <span class="literal">None</span>, subok = <span class="literal">False</span>, ndmin = <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="NumPy-创建数组"><a href="#NumPy-创建数组" class="headerlink" title="NumPy 创建数组"></a><a href="https://www.runoob.com/numpy/numpy-array-creation.html">NumPy 创建数组</a></h2><h3 id="numpy-zeros"><a href="#numpy-zeros" class="headerlink" title="numpy.zeros"></a>numpy.zeros</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros(shape, dtype = <span class="built_in">float</span>, order = <span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">shape数组形状</span><br><span class="line">dtype数据类型，可选</span><br><span class="line">order<span class="string">&#x27;C&#x27;</span> 用于 C 的行数组，或者 <span class="string">&#x27;F&#x27;</span> 用于 FORTRAN 的列数组</span><br><span class="line">x = np.zeros(<span class="number">5</span>) </span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line">y = np.zeros((<span class="number">5</span>,), dtype = np.<span class="built_in">int</span>) </span><br><span class="line"><span class="built_in">print</span>(y)</span><br><span class="line">z = np.zeros((<span class="number">2</span>,<span class="number">2</span>), dtype = [(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])  </span><br><span class="line"><span class="built_in">print</span>(z)</span><br><span class="line">[<span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span> <span class="number">0.</span>]</span><br><span class="line">[<span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span>]</span><br><span class="line">[[(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]</span><br><span class="line"> [(<span class="number">0</span>, <span class="number">0</span>) (<span class="number">0</span>, <span class="number">0</span>)]]</span><br></pre></td></tr></table></figure><h3 id="numpy-zeros-like"><a href="#numpy-zeros-like" class="headerlink" title="numpy.zeros_like"></a>numpy.zeros_like</h3><p>Return an array of zeros with the same shape and type as a given array.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">numpy.zeros_like(a, dtype=<span class="literal">None</span>, order=<span class="string">&#x27;K&#x27;</span>, subok=<span class="literal">True</span>, shape=<span class="literal">None</span>)</span><br><span class="line">x = np.arange(<span class="number">6</span>)</span><br><span class="line">x = x.reshape((<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">np.zeros_like(x)</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]])</span><br></pre></td></tr></table></figure><h2 id="NumPy-从数据范围创建数组"><a href="#NumPy-从数据范围创建数组" class="headerlink" title="NumPy 从数据范围创建数组"></a><a href="https://www.runoob.com/numpy/numpy-array-from-numerical-ranges.html">NumPy 从数据范围创建数组</a></h2><h3 id="numpy-arange"><a href="#numpy-arange" class="headerlink" title="numpy.arange"></a>numpy.arange</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">np.arange(start, stop, step, dtype)</span><br><span class="line">start起始值，默认为<span class="number">0</span></span><br><span class="line">stop终止值（不包含）</span><br><span class="line">step步长，默认为<span class="number">1</span></span><br><span class="line">dtype返回ndarray的数据类型，如果没有提供，则会使用输入数据的类型。</span><br><span class="line">x = np.arange(<span class="number">5</span>)  </span><br><span class="line">[<span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>]</span><br><span class="line">x = np.arange(<span class="number">10</span>,<span class="number">20</span>,<span class="number">2</span>)  </span><br><span class="line">[<span class="number">10</span>  <span class="number">12</span>  <span class="number">14</span>  <span class="number">16</span>  <span class="number">18</span>]</span><br></pre></td></tr></table></figure><h2 id="NumPy-数组操作"><a href="#NumPy-数组操作" class="headerlink" title="NumPy 数组操作"></a><a href="https://www.runoob.com/numpy/numpy-array-manipulation.html">NumPy 数组操作</a></h2><h3 id="numpy-reshape"><a href="#numpy-reshape" class="headerlink" title="numpy.reshape"></a>numpy.reshape</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">numpy.reshape(arr, newshape, order=<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">arr：要修改形状的数组</span><br><span class="line">newshape：整数或者整数数组，新的形状应当兼容原有形状</span><br><span class="line">order：<span class="string">&#x27;C&#x27;</span> -- 按行，<span class="string">&#x27;F&#x27;</span> -- 按列，<span class="string">&#x27;A&#x27;</span> -- 原顺序，<span class="string">&#x27;k&#x27;</span> -- 元素在内存中的出现顺序。</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">8</span>)</span><br><span class="line">b = a.reshape(<span class="number">4</span>,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (b)</span><br><span class="line"></span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span>]</span><br><span class="line">[[<span class="number">0</span> <span class="number">1</span>]</span><br><span class="line"> [<span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">6</span> <span class="number">7</span>]]</span><br></pre></td></tr></table></figure><h3 id="numpy-append"><a href="#numpy-append" class="headerlink" title="numpy.append"></a>numpy.append</h3><p>输入数组的维度必须匹配否则将生成ValueError。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">numpy.append(arr, values, axis=<span class="literal">None</span>)</span><br><span class="line">arr：输入数组</span><br><span class="line">values：要向arr添加的值，需要和arr形状相同（除了要添加的轴）</span><br><span class="line">axis：默认为 <span class="literal">None</span>。</span><br><span class="line">当axis无定义时，是横向加成，返回总是为一维数组！当axis有定义的时候，分别为<span class="number">0</span>和<span class="number">1</span>的时候。</span><br><span class="line">当axis有定义的时候，分别为<span class="number">0</span>和<span class="number">1</span>的时候（列数要相同）。</span><br><span class="line">当axis为<span class="number">1</span>时，数组是加在右边（行数要相同）。</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="built_in">print</span> (a)</span><br><span class="line"><span class="built_in">print</span> (np.append(a, [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]))</span><br><span class="line"><span class="built_in">print</span> (np.append(a, [[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis = <span class="number">0</span>))</span><br><span class="line"><span class="built_in">print</span> (np.append(a, [[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]],axis = <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]]</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span>]</span><br><span class="line"> [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br><span class="line">[[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span>]</span><br><span class="line"> [<span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]]</span><br></pre></td></tr></table></figure><h2 id="NumPy-数学函数"><a href="#NumPy-数学函数" class="headerlink" title="NumPy 数学函数"></a><a href="https://www.runoob.com/numpy/numpy-mathematical-functions.html">NumPy 数学函数</a></h2><h3 id="numpy-power"><a href="#numpy-power" class="headerlink" title="numpy.power"></a>numpy.power</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.power(x1, x2, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">&#x27;same_kind&#x27;</span>, order=<span class="string">&#x27;K&#x27;</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj]) = &lt;ufunc <span class="string">&#x27;power&#x27;</span>&gt;¶</span><br><span class="line">x1 = np.arange(<span class="number">6</span>)</span><br><span class="line">x2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]])</span><br><span class="line">np.power(x1, x2)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">8</span>, <span class="number">27</span>, <span class="number">16</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">8</span>, <span class="number">27</span>, <span class="number">16</span>,  <span class="number">5</span>]])</span><br></pre></td></tr></table></figure><h3 id="numpy-sqrt"><a href="#numpy-sqrt" class="headerlink" title="numpy.sqrt"></a>numpy.sqrt</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">numpy.sqrt(x, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">&#x27;same_kind&#x27;</span>, order=<span class="string">&#x27;K&#x27;</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj]) = &lt;ufunc <span class="string">&#x27;sqrt&#x27;</span>&gt;</span><br><span class="line">np.sqrt([<span class="number">4</span>, -<span class="number">1</span>, np.inf])</span><br><span class="line">array([ <span class="number">2.</span>, nan, inf])</span><br></pre></td></tr></table></figure><h2 id="NumPy-线性代数"><a href="#NumPy-线性代数" class="headerlink" title="NumPy 线性代数"></a><a href="https://www.runoob.com/numpy/numpy-linear-algebra.html">NumPy 线性代数</a></h2><h3 id="numpy-dot"><a href="#numpy-dot" class="headerlink" title="numpy.dot"></a>numpy.dot</h3><p>两个数组的点积，即元素对应相乘.</p><p>对于两个一维的数组，计算的是这两个数组对应下标元素的乘积和(数学上称之为内积)；</p><p>对于二维数组，计算的是两个数组的矩阵乘积；</p><p>对于多维数组，它的通用计算公式如下，即结果数组中的每个元素都是：数组a的最后一维上的所有元素与数组b的倒数第二位上的所有元素的乘积和： <strong>dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.dot(a, b, out=<span class="literal">None</span>) </span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">b = np.array([[<span class="number">11</span>,<span class="number">12</span>],[<span class="number">13</span>,<span class="number">14</span>]])</span><br><span class="line"><span class="built_in">print</span>(np.dot(a,b))</span><br><span class="line">[[<span class="number">37</span>  <span class="number">40</span>] </span><br><span class="line"> [<span class="number">85</span>  <span class="number">92</span>]]</span><br></pre></td></tr></table></figure><h2 id="Functional-programming"><a href="#Functional-programming" class="headerlink" title="Functional programming"></a>Functional programming</h2><h3 id="numpy-piecewise"><a href="#numpy-piecewise" class="headerlink" title="numpy.piecewise"></a>numpy.piecewise</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">numpy.piecewise(x, condlist, funclist, *args, **kw)</span><br><span class="line">      |--</span><br><span class="line">      |funclist[<span class="number">0</span>](x[condlist[<span class="number">0</span>]])</span><br><span class="line">out = |funclist[<span class="number">1</span>](x[condlist[<span class="number">1</span>]])</span><br><span class="line">      |...</span><br><span class="line">      |funclist[n2](x[condlist[n2]])</span><br><span class="line">      |--</span><br><span class="line">x = np.linspace(-<span class="number">2.5</span>, <span class="number">2.5</span>, <span class="number">6</span>)</span><br><span class="line">np.piecewise(x, [x &lt; <span class="number">0</span>, x &gt;= <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">array([-<span class="number">1.</span>, -<span class="number">1.</span>, -<span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>])</span><br></pre></td></tr></table></figure><h3 id="numpy-vectorize"><a href="#numpy-vectorize" class="headerlink" title="numpy.vectorize"></a>numpy.vectorize</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">numpy.vectorize(pyfunc, otypes=<span class="literal">None</span>, doc=<span class="literal">None</span>, excluded=<span class="literal">None</span>, cache=<span class="literal">False</span>, signature=<span class="literal">None</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc</span>(<span class="params">a, b</span>):</span></span><br><span class="line">    <span class="string">&quot;Return a-b if a&gt;b, otherwise return a+b&quot;</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> a - b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> a + b</span><br><span class="line">vfunc = np.vectorize(myfunc)</span><br><span class="line">vfunc([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">2</span>)</span><br><span class="line">array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>])    </span><br><span class="line">---</span><br><span class="line">ladder_move = np.vectorize(<span class="keyword">lambda</span> x : env.ladders[x] <span class="keyword">if</span> x <span class="keyword">in</span> env.ladders <span class="keyword">else</span> x)</span><br><span class="line">step = np.piecewise(step, [step &gt; <span class="number">100</span>, step &lt;= <span class="number">100</span>], [<span class="keyword">lambda</span> x : <span class="number">200</span> - x, <span class="keyword">lambda</span> x : x])</span><br><span class="line">step = ladder_move(step)</span><br></pre></td></tr></table></figure><h2 id="Logical-functions"><a href="#Logical-functions" class="headerlink" title="Logical functions"></a>Logical functions</h2><h3 id="numpy-all"><a href="#numpy-all" class="headerlink" title="numpy.all"></a>numpy.all</h3><p>Test whether all array elements along a given axis evaluate to True<strong>(not zero?)</strong>.</p><p>Not a Number (NaN), positive infinity and negative infinity evaluate to <em>True</em> because these are not equal to <strong>zero</strong>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">numpy.<span class="built_in">all</span>(a, axis=<span class="literal">None</span>, out=<span class="literal">None</span>, keepdims=&lt;no value&gt;, *, where=&lt;no value&gt;)</span><br><span class="line"></span><br><span class="line">np.<span class="built_in">all</span>([[<span class="literal">True</span>,<span class="literal">False</span>],[<span class="literal">True</span>,<span class="literal">True</span>]])</span><br><span class="line"><span class="literal">False</span></span><br><span class="line">np.<span class="built_in">all</span>([-<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="numpy-equal"><a href="#numpy-equal" class="headerlink" title="numpy.equal"></a>numpy.equal</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">numpy.equal(x1, x2, /, out=<span class="literal">None</span>, *, where=<span class="literal">True</span>, casting=<span class="string">&#x27;same_kind&#x27;</span>, order=<span class="string">&#x27;K&#x27;</span>, dtype=<span class="literal">None</span>, subok=<span class="literal">True</span>[, signature, extobj]) = &lt;ufunc <span class="string">&#x27;equal&#x27;</span>&gt;</span><br><span class="line">Return (x1 == x2) element-wise.</span><br><span class="line"></span><br><span class="line">np.equal([<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>], np.arange(<span class="number">3</span>))</span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>])</span><br><span class="line"></span><br><span class="line">The == operator can be used <span class="keyword">as</span> a shorthand <span class="keyword">for</span> np.equal on ndarrays.</span><br><span class="line">a = np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br><span class="line">b = np.array([<span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>])</span><br><span class="line">a == b</span><br><span class="line">array([ <span class="literal">True</span>,  <span class="literal">True</span>, <span class="literal">False</span>])</span><br></pre></td></tr></table></figure><h2 id="Random-sampling"><a href="#Random-sampling" class="headerlink" title="Random sampling"></a>Random sampling</h2><h3 id="numpy-random-randint"><a href="#numpy-random-randint" class="headerlink" title="numpy.random.randint"></a>numpy.random.randint</h3><p>Return random integers from <em>low</em> (inclusive) to <em>high</em> (exclusive).</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">random.randint(low, high=<span class="literal">None</span>, size=<span class="literal">None</span>, dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">np.random.randint([<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>], [[<span class="number">10</span>], [<span class="number">20</span>]], dtype=np.uint8)</span><br><span class="line">array([[ <span class="number">8</span>,  <span class="number">6</span>,  <span class="number">9</span>,  <span class="number">7</span>], <span class="comment"># random</span></span><br><span class="line">       [ <span class="number">1</span>, <span class="number">16</span>,  <span class="number">9</span>, <span class="number">12</span>]], dtype=uint8)</span><br></pre></td></tr></table></figure><h3 id="numpy-random-shuffle"><a href="#numpy-random-shuffle" class="headerlink" title="numpy.random.shuffle"></a>numpy.random.shuffle</h3><p>Modify a sequence in-place by shuffling its contents.</p><p><strong>Multi-dimensional arrays are only shuffled along the first axis:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(x)</span><br><span class="line">arr = np.arange(<span class="number">9</span>).reshape((<span class="number">3</span>, <span class="number">3</span>))</span><br><span class="line">np.random.shuffle(arr)</span><br><span class="line">arr</span><br><span class="line">array([[<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], </span><br><span class="line">       [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h2 id="Sorting-searching-and-counting"><a href="#Sorting-searching-and-counting" class="headerlink" title="Sorting, searching, and counting"></a>Sorting, searching, and counting</h2><h2 id="numpy-argmax"><a href="#numpy-argmax" class="headerlink" title="numpy.argmax"></a>numpy.argmax</h2><p>Returns the indices of the maximum values along an axis.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">numpy.argmax(a, axis=<span class="literal">None</span>, out=<span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">a = np.arange(<span class="number">6</span>).reshape(<span class="number">2</span>,<span class="number">3</span>) + <span class="number">10</span></span><br><span class="line">a</span><br><span class="line">array([[<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>],</span><br><span class="line">       [<span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]])</span><br><span class="line">np.argmax(a)</span><br><span class="line"><span class="number">5</span></span><br><span class="line">np.argmax(a, axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>])</span><br><span class="line">np.argmax(a, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">2</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常用函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习知识</title>
      <link href="/p/c9b2.html"/>
      <url>/p/c9b2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="数学基础"><a href="#数学基础" class="headerlink" title="数学基础"></a>数学基础</h1><h2 id="KL-散度"><a href="#KL-散度" class="headerlink" title="KL 散度"></a>KL 散度</h2><p>KL 散度是描述两个概率分布P 和Q差异一种方法。</p><p>离散概率分布的KL散度计算公式为:</p><script type="math/tex; mode=display">KL(p||q) = \sum p(x)\log\frac{p(x)}{q(x)}</script><p>连续概率分布的KL散度计算公式为：</p><script type="math/tex; mode=display">KL(p||q)=\int p(x)\log\frac{p(x)}{q(x)}\mathrm{d}x</script><p>分布越相近，KL散度越小，分布越远，KL散度越大。</p><p>由上凸函数可证KL散度的结果非负。</p><ul><li>非对称</li><li>不满足三角不等式</li></ul><p>从熵的角度看：</p><p>基于P编码P的熵：</p><script type="math/tex; mode=display">H(x) = \sum_{i\in X}p(i) * \log\frac{1}{p(i)}</script><p>基于P编码Q的熵：</p><script type="math/tex; mode=display">H^{\prime}(x) = \sum_{i\in X}p(i) * \log\frac{1}{q(i)}</script><p>相减:</p><script type="math/tex; mode=display">H^{\prime}(x) - H(x) = \sum p(x)\log\frac{p(x)}{q(x)}</script><p>一些计算例子: <a href="https://hsinjhao.github.io/2019/05/22/KL-DivergenceIntroduction/">orz</a></p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/p/3baf.html"/>
      <url>/p/3baf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="冷知识"><a href="#冷知识" class="headerlink" title="冷知识"></a>冷知识</h2><ul><li>vector可以直接比大小…</li><li></li></ul><h2 id="C-基础语法"><a href="#C-基础语法" class="headerlink" title="C++ 基础语法"></a>C++ 基础语法</h2><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ... = ...;</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br></pre></td></tr></table></figure><p>在语法的别名声明，using的使用类似于typedef，但用法更为精妙。</p><h3 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a>stoi</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> wstring&amp; str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>stoi()的输入要不为空，否则可以使用atoi(().c.str())</p><h3 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a><a href="https://www.cplusplus.com/reference/sstream/">sstream</a></h3><p>istringstream类用于执行C++风格的字符串流的输入操作，支持&gt;&gt;;</p><p>ostringstream类用于执行C++风格的字符串流的输出操作，支持&lt;&lt;；</p><p>stringstream类同时可以支持C++风格的串流的输入输出操作，同时支持&gt;&gt;和&lt;&lt;；</p><p>即 stringstream = istringstream + ostringstream。</p><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><ul><li><p>numeric</p></li><li><p><a href="http://c.biancheng.net/view/681.html">详细的说明</a></p></li><li>定义在 numeric 头文件中的 iota() 函数模板会用连续的 T 类型值填充序列。前两个参数是定义序列的正向迭代器，第三个参数是初始的 T 值。第三个指定的值会被保存到序列的第一个元素中。保存在第一个元素后的值是通过对前面的值运用自增运算符得到的。当然，这意味着 T 类型必须支持 operator++()。</li></ul><h3 id="builtin-popcount"><a href="#builtin-popcount" class="headerlink" title="__builtin_popcount"></a>__builtin_popcount</h3><ul><li>统计二进制中1的个数</li></ul><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><a href="http://c.biancheng.net/stl/stl_basic/">C++ STL</a></p><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html">不错的博客链接</a></p><h3 id="distance"><a href="#distance" class="headerlink" title="distance"></a>distance</h3><ul><li><p><a href="http://c.biancheng.net/view/7372.html">详细的说明</a></p></li><li><p>distance() 函数用于计算两个迭代器表示的范围内包含元素的个数</p></li><li><p>distance() 函数定义在<code>&lt;iterator&gt;</code>头文件，并位于 std 命名空间中</p></li><li><p>distance() 函数用于计算两个迭代器表示的范围内包含元素的个数，其语法格式如下：</p><blockquote><p>template<class inputiterator><br> typename iterator_traits<InputIterator>::difference_type distance (InputIterator first, InputIterator last);</InputIterator></class></p></blockquote><p>其中，first 和 last 都为迭代器，其类型可以是输入迭代器、前向迭代器、双向迭代器以及随机访问迭代器；该函数会返回<code>[first, last)</code>范围内包含的元素的个数。</p><p>注意，first 和 last 的迭代器类型，直接决定了 distance() 函数底层的实现机制：</p><ul><li>当 first 和 last 为随机访问迭代器时，distance() 底层直接采用 last - first 求得 [first, last) 范围内包含元素的个数，其时间复杂度为<code>O(1)</code>常数阶；</li><li>当 first 和 last 为非随机访问迭代器时，distance() 底层通过不断执行 ++first（或者 first++）直到 first==last，由此来获取 [first, last) 范围内包含元素的个数，其时间复杂度为<code>O(n)</code>线性阶。</li></ul></li></ul><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><ul><li><p><a href="http://c.biancheng.net/view/570.html">详细的说明</a></p></li><li><p>find() 为在输入迭代器所定义的范围内查找单个对象的算法，它可以在前两个参数指定的范围内查找和第三个参数相等的第一个对象。</p><p>find 算法会返回一个指向被找到对象的迭代器，如果没有找到对象，会返回这个序列的结束迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">InputIterator <span class="title">find</span> <span class="params">(InputIterator first, InputIterator last, <span class="keyword">const</span> T&amp; val)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound"></a>lower_bound</h3><ul><li><p><a href="http://c.biancheng.net/view/7521.html">详细的说明</a></p></li><li><p>find()、find_if()、search() 等这些函数的底层实现都采用的是顺序查找（逐个遍历）的方式，在某些场景中的执行效率并不高。</p></li><li><p>C++ STL标准库中还提供有 lower_bound()、upper_bound()、equal_range() 以及 binary_search() 这 4 个查找函数，它们的底层实现采用的都是二分查找的方式。</p></li><li><p>lower_bound() 函数用于在指定区域内查找不小于目标值的第一个元素。也就是说，使用该函数在指定范围内查找某个目标值时，最终查找到的不一定是和目标值相等的元素，还可能是比目标值大的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在 [first, last) 区域内查找不小于 val 的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//在 [first, last) 区域内查找第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">lower_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound"></a>upper_bound</h3><ul><li><p><a href="http://c.biancheng.net/view/7527.html">详细的说明</a></p></li><li><p>用于在指定范围内查找大于目标值的第一个元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找[first, last)区域中第一个大于 val 的元素。</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val)</span></span>;</span><br><span class="line"><span class="comment">//查找[first, last)区域中第一个不符合 comp 规则的元素</span></span><br><span class="line"><span class="function">ForwardIterator <span class="title">upper_bound</span> <span class="params">(ForwardIterator first, ForwardIterator last,</span></span></span><br><span class="line"><span class="params"><span class="function">                             <span class="keyword">const</span> T&amp; val, Compare comp)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><h3 id="gcd"><a href="#gcd" class="headerlink" title="__gcd()"></a>__gcd()</h3><ul><li>algorithm</li><li>__gcd(a, b)求解最大公因数</li></ul><h3 id="next-permutation"><a href="#next-permutation" class="headerlink" title="next_permutation"></a>next_permutation</h3><ul><li><p><a href="http://c.biancheng.net/view/597.html">详细的说明</a></p></li><li><p>next_permutation() 会生成一个序列的重排列，它是所有可能的字典序中的下一个排列，默认使用 &lt; 运算符来做这些事情。它的参数为定义序列的迭代器和一个返回布尔值的函数，这个函数在下一个排列大于上一个排列时返回 true，如果上一个排列是序列中最大的，它返回 false，所以会生成字典序最小的排列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; range &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::<span class="built_in">copy</span> (std::<span class="built_in">begin</span>(range), std::<span class="built_in">end</span>(range), std::ostream_iterator&lt;<span class="keyword">int</span>&gt;&#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;<span class="keyword">while</span>(std::<span class="built_in">next_permutation</span>(std::<span class="built_in">begin</span>(range), std::<span class="built_in">end</span>(range)));</span><br></pre></td></tr></table></figure></li></ul><h3 id="prev-permutation"><a href="#prev-permutation" class="headerlink" title="prev_permutation"></a>prev_permutation</h3><ul><li><p><a href="http://c.biancheng.net/view/598.html">详细的说明</a></p></li><li><p>next_permutation() 是按照字典升序的方式生成的排列。当我们想以降序的方式生成排列时，可以使用 prev_permutation()。</p></li><li><p>prev_permutation 和 next_permutation() 一样有两个版本，默认使用 &lt; 来比较元素。因为排列是以降序的方式生成的，所以算法大多数时候会返回 true。当生成最大排列时，返回 false。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">double</span>&gt; data &#123;<span class="number">44.5</span>, <span class="number">22.0</span>, <span class="number">15.6</span>, <span class="number">1.5</span>&#125;;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data), std::ostream_iterator&lt;<span class="keyword">double</span>&gt; &#123;std::cout, <span class="string">&quot; &quot;</span>&#125;);</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125; <span class="keyword">while</span>(std::<span class="built_in">prev_permutation</span>(std::<span class="built_in">begin</span>(data), std::<span class="built_in">end</span>(data)));</span><br></pre></td></tr></table></figure></li></ul><h3 id="binary-search"><a href="#binary-search" class="headerlink" title="binary_search"></a>binary_search</h3><ul><li><a href="http://c.biancheng.net/view/7537.html">详细的说明</a></li><li>二分查找值</li></ul><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul><li><p><a href="[C++ STL set容器完全攻略（超级详细） (biancheng.net">详细的说明</a>](<a href="http://c.biancheng.net/view/7192.html">http://c.biancheng.net/view/7192.html</a>))</p></li><li><p>后续程序中在使用 set 容器时，需手动注明 std 命名空间（强烈建议初学者使用,但不是必须的）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>,                        // 键 <span class="title">key</span> 和值 <span class="title">value</span> 的类型</span></span><br><span class="line"><span class="class">           <span class="keyword">class</span> <span class="title">Compare</span> =</span> less&lt;T&gt;,        <span class="comment">// 指定 set 容器内部的排序规则</span></span><br><span class="line">           <span class="class"><span class="keyword">class</span> <span class="title">Alloc</span> =</span> allocator&lt;T&gt;      <span class="comment">// 指定分配器对象的类型</span></span><br><span class="line">           &gt; <span class="class"><span class="keyword">class</span> <span class="title">set</span>;</span></span><br></pre></td></tr></table></figure></li><li><p>C++ 11 标准还为 set 类模板新增了移动构造函数，其功能是实现创建新 set 容器的同时，利用临时的 set 容器为其初始化。</p></li><li><p>set 类模板还支持取已有 set 容器中的部分元素，来初始化新 set 容器。</p></li><li><p>借助 set 类模板定义中第 2 个参数，我们完全可以手动修改 set 容器中的排序规则。</p></li><li><p>若干成员方法。。。</p></li></ul><h3 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h3><ul><li><p><a href="http://c.biancheng.net/view/607.html">详细的说明</a></p></li><li><p>unique() 算法可以在序列中原地移除重复的元素，这就要求被处理的序列必须是正向迭代器所指定的。在移除重复元素后，它会返回一个正向迭代器作为新序列的结束迭代器。可以提供一个函数对象作为可选的第三个参数，这个参数会定义一个用来代替 <code>==</code> 比较元素的方法。</p></li><li><p>容器的成员函数 erase() 会移除新的结束迭代器之后的所有元素，因此 end(words) 会返回 end_iter。</p></li><li><p>可以将 unique() 运用到字符串中的字符上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string text &#123;<span class="string">&quot;There&#x27;s no air in spaaaaaace!&quot;</span>&#125;;</span><br><span class="line">text.<span class="built_in">erase</span>(std::<span class="built_in">unique</span>(std::<span class="built_in">begin</span>(text), std::<span class="built_in">end</span>(text),[](<span class="keyword">char</span> ch1, <span class="keyword">char</span> ch2) &#123; <span class="keyword">return</span> ch1 = <span class="string">&#x27; &#x27;</span>&amp;&amp; ch1 = ch2; &#125;), std::<span class="built_in">end</span>(text));</span><br><span class="line">std::cout &lt;&lt; text &lt;&lt; std::endl; <span class="comment">// Outputs: There&#x27;s no air in spaaaaaace!</span></span><br></pre></td></tr></table></figure><p>这里使用 unique() 会移除字符串 text 中的连续重复的空格。这段代码会用 unique() 返回的迭代器作为 text 成员函数 erase() 的第一个参数，而且它会指向被移除的第一个字符。erase() 的第二个参数是 text 的结束迭代器，因此在没有重复元素的新字符串之后的所有字符都会被移除。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProjectEuler 031 - 040</title>
      <link href="/p/bae8.html"/>
      <url>/p/bae8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以回顾的题目:</p><ul><li>TODO</li></ul><h2 id="031"><a href="#031" class="headerlink" title="031"></a>031</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>无穷背包问题，略</p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">50</span>, <span class="number">100</span>, <span class="number">200</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = a[i]; j &lt;= <span class="number">100000</span>; j++)&#123;</span><br><span class="line">            s[j] += s[j - a[i]];</span><br><span class="line">            s[j] %= mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; s[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="032"><a href="#032" class="headerlink" title="032"></a>032</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># </span><br></pre></td></tr></table></figure><h2 id="033"><a href="#033" class="headerlink" title="033"></a>033</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="034"><a href="#034" class="headerlink" title="034"></a>034</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="035"><a href="#035" class="headerlink" title="035"></a>035</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="036"><a href="#036" class="headerlink" title="036"></a>036</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">＃</span><br></pre></td></tr></table></figure><h2 id="037"><a href="#037" class="headerlink" title="037"></a>037</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="038"><a href="#038" class="headerlink" title="038"></a>038</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-7"><a href="#AC-Code-7" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="039"><a href="#039" class="headerlink" title="039"></a>039</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-8"><a href="#AC-Code-8" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="040"><a href="#040" class="headerlink" title="040"></a>040</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-9"><a href="#AC-Code-9" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ProjectEuler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProjectEuler 021 - 030</title>
      <link href="/p/c681.html"/>
      <url>/p/c681.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以回顾的题目:</p><ul><li>023 线性筛法的拓展</li><li>024 康托展开+树状数组</li><li>026 除法，循环节的一些问题</li><li>029 溢出问题，非常吐血，高精度都打不过系列</li></ul><h2 id="021"><a href="#021" class="headerlink" title="021"></a>021</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n / i; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n % i) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(i * i == n) s += i;</span><br><span class="line">        <span class="keyword">else</span> s += (i + n / i);</span><br><span class="line">    &#125;</span><br><span class="line">    dp[n] = s - n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) <span class="built_in">init</span>(i);</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = i;</span><br><span class="line">            <span class="keyword">int</span> b = dp[a];</span><br><span class="line">            <span class="keyword">if</span>(a != b &amp;&amp; b &lt; N &amp;&amp; dp[b] == a) res += a;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="022"><a href="#022" class="headerlink" title="022"></a>022</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; a;</span><br><span class="line">string b;</span><br><span class="line"><span class="keyword">int</span> n, q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] == s) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt; s) r = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        a.<span class="built_in">push_back</span>(b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>());</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">        cin &gt;&gt; b;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : b) res += c - <span class="string">&#x27;A&#x27;</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> id = <span class="built_in">find</span>(b) + <span class="number">1</span>;</span><br><span class="line">        cout &lt;&lt; res * id &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="023"><a href="#023" class="headerlink" title="023"></a>023</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>线性筛的应用，包括因数个数等解法，非常有用。</p><p>推荐博客。</p><p><a href="https://blog.csdn.net/m0_49959202/article/details/108684545">线性筛法</a></p><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="keyword">int</span> f[N], g[N];</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line">set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    f[<span class="number">1</span>] = g[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">            f[i] = <span class="number">1</span> + i;</span><br><span class="line">            g[i] = <span class="number">1</span> + i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= N / i; j++)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>)&#123;</span><br><span class="line">                g[i * primes[j]] = g[i] * primes[j] + <span class="number">1</span>;</span><br><span class="line">                f[i * primes[j]] = f[i] / g[i] * g[i * primes[j]];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            g[i * primes[j]] = primes[j] + <span class="number">1</span>;</span><br><span class="line">            f[i * primes[j]] = f[i] * g[i * primes[j]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(f[i] - i &gt; i) s.<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="comment">//for(auto c : s) cout &lt;&lt; c &lt;&lt; &quot; &quot;;</span></span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c &lt; n &amp;&amp; s.<span class="built_in">count</span>(n - c))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="024"><a href="#024" class="headerlink" title="024"></a>024</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>康托展开和逆康托展开<a href="https://oi-wiki.org/math/combinatorics/cantor/">OI-wiki</a></p><p>一个非常amazing的东西<a href="https://en.wikipedia.org/wiki/Factorial_number_system">Factorial_number_system</a></p><script type="math/tex; mode=display">\text{int} \rightarrow 12! \rightarrow 4 7900 1600 \rightarrow 4\times 10^8</script><script type="math/tex; mode=display">\text{long long} \rightarrow 20! \rightarrow 2 43 2902 0081 7664 0000 \rightarrow 2\times 10^{18}</script><p>树状数组还忘记差不多了，难受</p><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">16</span>;</span><br><span class="line">ll dp[N], a[N], c[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lowbit</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &amp; -x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i &lt;= <span class="number">13</span>; i += <span class="built_in">lowbit</span>(i)) c[i] += y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = x; i; i -= <span class="built_in">lowbit</span>(i)) res += c[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++) dp[i] = dp[i - <span class="number">1</span>] * i;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        n -= <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++) <span class="built_in">add</span>(i, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = n / dp[<span class="number">13</span> - i] + <span class="number">1</span>;</span><br><span class="line">            n %= dp[<span class="number">13</span> - i];</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = <span class="number">13</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">sum</span>(mid) &gt;= k) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            a[i] = r;</span><br><span class="line">            <span class="built_in">add</span>(r, <span class="number">-1</span>); </span><br><span class="line">            <span class="comment">// cout &lt;&lt; k &lt;&lt; &quot; &quot;  &lt;&lt; n &lt;&lt; &quot; &quot; &lt;&lt; a[i] &lt;&lt; &quot; &quot; &lt;&lt; endl;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">13</span>; i++) cout &lt;&lt; (<span class="keyword">char</span>)(<span class="string">&#x27;a&#x27;</span> + a[i] - <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="025"><a href="#025" class="headerlink" title="025"></a>025</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>记忆化，思路比较简单，实现一下高精度加法</p><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> alen = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> blen = b.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; alen || i &lt; blen || carry; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; alen) carry += a[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; blen) carry += b[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>&#125;);</span><br><span class="line">    s.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">back</span>().<span class="built_in">size</span>() &gt;= n)&#123;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">1</span>, r = s.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">                <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>((<span class="keyword">int</span>)s[mid].<span class="built_in">size</span>() &gt;= n) r = mid;</span><br><span class="line">                <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; r &lt;&lt; endl;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">while</span>((<span class="keyword">int</span>)s.<span class="built_in">back</span>().<span class="built_in">size</span>() &lt; n)&#123;</span><br><span class="line">                <span class="keyword">int</span> k = s.<span class="built_in">size</span>();</span><br><span class="line">                s.<span class="built_in">push_back</span>(<span class="built_in">add</span>(s[k - <span class="number">2</span>], s[k - <span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; s.<span class="built_in">size</span>() - <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="026"><a href="#026" class="headerlink" title="026"></a>026</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>非常有趣，补充几道题</p><ul><li><a href="https://leetcode-cn.com/problems/fraction-to-recurring-decimal/">LeetCode 166</a></li><li><a href="https://leetcode-cn.com/problems/divide-two-integers/">LeetCode 29</a></li><li><a href="https://www.acwing.com/problem/content/796/">高精度除法</a></li><li><a href="https://en.wikipedia.org/wiki/Repeating_decimal">知识点</a></li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>这题评测机有点搞笑，一次性计算可以过，根据n计算反而不可以过，离谱到家。</p><p>此外用unordered_map也可以过。</p><p>即<code>f</code>函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;ll, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    ll a = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(mp.<span class="built_in">count</span>(a))&#123;</span><br><span class="line">            <span class="keyword">return</span> pos - mp[a];</span><br><span class="line">        &#125;</span><br><span class="line">        mp[a] = pos;</span><br><span class="line">        a = a * <span class="number">10</span> % x;</span><br><span class="line">        pos++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TLE-Code"><a href="#TLE-Code" class="headerlink" title="TLE Code"></a>TLE Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pos, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pos));</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    ll a = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos[a])&#123;</span><br><span class="line">            <span class="keyword">return</span> p - pos[a];</span><br><span class="line">        &#125;</span><br><span class="line">        pos[a] = p;</span><br><span class="line">        a = a * <span class="number">10</span> % x;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    cnt = <span class="number">3</span>;</span><br><span class="line">    d[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cnt + <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">                d[i] = <span class="built_in">f</span>(i);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; : &quot; &lt;&lt; d[i] &lt;&lt; endl; </span></span><br><span class="line">                s[i] = d[i] &gt; d[s[i - <span class="number">1</span>]] ? i : s[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; s[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> d[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> pos[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(pos, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(pos));</span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">0</span>;</span><br><span class="line">    ll a = <span class="number">1ll</span>;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        <span class="keyword">if</span>(pos[a])&#123;</span><br><span class="line">            <span class="keyword">return</span> p - pos[a];</span><br><span class="line">        &#125;</span><br><span class="line">        pos[a] = p;</span><br><span class="line">        a = a * <span class="number">10</span> % x;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    cnt = <span class="number">3</span>;</span><br><span class="line">    d[<span class="number">3</span>] = <span class="number">1</span>;</span><br><span class="line">    s[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>; i &lt; <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        d[i] = <span class="built_in">f</span>(i);</span><br><span class="line">        s[i] = d[i] &gt; d[s[i - <span class="number">1</span>]] ? i : s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; s[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="027"><a href="#027" class="headerlink" title="027"></a>027</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>暴力枚举</p><p>n = 0, s = b;</p><p>n = 1, s = 1 + a + b</p><p>因此b , 1+ a + b起码为素数，可以简化很多</p><p>continue不要搞成break就行了。。。</p><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">4020</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    st[<span class="number">1</span>] = st[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i]) primes[cnt++] = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt; N / i; j++)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n * n + n * a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(x &lt; N) <span class="keyword">return</span> !st[x];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x / i; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x % i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> ra = <span class="number">-1</span>, rb = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = -n; a &lt;= n; a++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> b = -n; b &lt;= n; b++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(st[<span class="number">1</span> + a + b]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> s = <span class="built_in">f</span>(a, b, k);</span><br><span class="line">                <span class="comment">//cout &lt;&lt; a &lt;&lt; &quot; &quot;  &lt;&lt; b &lt;&lt; &quot; &quot; &lt;&lt; s&lt;&lt;endl;</span></span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">isPrime</span>(s)) <span class="keyword">break</span>;</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(k &gt; mx)&#123;</span><br><span class="line">                ra = a;</span><br><span class="line">                rb = b;</span><br><span class="line">                mx = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ra &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rb &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="028"><a href="#028" class="headerlink" title="028"></a>028</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>有点吐血，全程高精度，但是最后一个TLE。。。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><h4 id="TLE-Code-1"><a href="#TLE-Code-1" class="headerlink" title="TLE Code"></a>TLE Code</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mull</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> n = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; n || carry; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n) carry += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>() || i &lt; b.<span class="built_in">size</span>() || carry; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; a.<span class="built_in">size</span>()) carry += a[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; b.<span class="built_in">size</span>()) carry += b[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> res = <span class="built_in">mull</span>(a, b[i]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) res.<span class="built_in">insert</span>(res.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">        c = <span class="built_in">add</span>(c, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">sub</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, r = b; i &lt; a.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &gt;= r)&#123;</span><br><span class="line">            a[i] -= r;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a[i] = (a[i] + <span class="number">10</span> - r);</span><br><span class="line">        r = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">div</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>, r = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        r = r * <span class="number">10</span> + a[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(c.<span class="built_in">begin</span>(), c.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">while</span>(c.<span class="built_in">size</span>() &gt; <span class="number">0</span> &amp;&amp; c.<span class="built_in">back</span>() == <span class="number">0</span>) c.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">div2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, ll b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    ll r = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = a.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        r =  r * <span class="number">10</span> + a[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(r / b);</span><br><span class="line">        r %= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(ll a)</span></span>&#123;</span><br><span class="line">    <span class="comment">// (4n^3 + 3n^2 + 8n - 9) / 6</span></span><br><span class="line">    <span class="keyword">if</span>(a == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; n1;</span><br><span class="line">    <span class="keyword">while</span>(a)&#123;</span><br><span class="line">        n1.<span class="built_in">push_back</span>(a % <span class="number">10</span>);</span><br><span class="line">        a /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> n2 = <span class="built_in">mul</span>(n1, n1);</span><br><span class="line">    <span class="keyword">auto</span> n3 = <span class="built_in">mul</span>(n2, n1);</span><br><span class="line">    <span class="keyword">auto</span> s1 = <span class="built_in">mull</span>(n3, <span class="number">4</span>);</span><br><span class="line">    <span class="keyword">auto</span> s2 = <span class="built_in">mull</span>(n2, <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">auto</span> s3 = <span class="built_in">mull</span>(n1, <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">auto</span> res = <span class="built_in">add</span>(s1, s2);</span><br><span class="line">    res = <span class="built_in">add</span>(res, s3);</span><br><span class="line">    res = <span class="built_in">sub</span>(res, <span class="number">9</span>);</span><br><span class="line">    res = <span class="built_in">div</span>(res, <span class="number">6</span>);</span><br><span class="line">    ll r = <span class="built_in">div2</span>(res, N);</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AC-Code-7"><a href="#AC-Code-7" class="headerlink" title="AC Code"></a>AC Code</h4><p>答案</p><script type="math/tex; mode=display">=\frac{4n^3+3n^2+8n-9}{6}</script><p>不好整，令 $k = (n - 1) / 2 = \lfloor n/2 \rfloor$，即 $n = 2k + 1$</p><p>从而化为</p><script type="math/tex; mode=display">1 + \frac{8k(k+1)(2k+1)}{3} + 2k(k+1) + 4k</script><p>这可以先求每一项取模后的结果，其中 $\frac{8k(k+1)(2k+1)}{3}$ 可以对k三分类讨论去掉从而去掉分母。</p><p>然后$k * k$ 量级依然可能溢出，因此需要对 $k, k + 1$等先取模后相乘。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">using ll = unsigned long long;</span><br><span class="line">const int mod = 1e9 + 7;</span><br><span class="line"></span><br><span class="line">ll g(ll n)&#123;</span><br><span class="line">    ll res = 1;</span><br><span class="line">    ll k = n / 2;</span><br><span class="line">    res = (res + k % mod * 4 % mod) % mod;</span><br><span class="line">    res = (res + k % mod * 2 % mod * ((k + 1) % mod)) % mod;</span><br><span class="line">    if(k % 3 == 0)&#123;</span><br><span class="line">        res = (res + (k / 3) % mod * 8 % mod * ((k + 1) % mod) % mod * ((2 * k + 1) % mod)) % mod;</span><br><span class="line">    &#125;else if(k % 3 == 1)&#123;</span><br><span class="line">        res = (res + k % mod * 8 % mod * ((k + 1) % mod) % mod * ((2 * k + 1) / 3 % mod)) % mod;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        res = (res + k % mod * 8 % mod * ((k + 1) / 3 % mod) % mod * ((2 * k + 1) % mod)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    return (res + mod) % mod;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    while(t--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; g(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="029"><a href="#029" class="headerlink" title="029"></a>029</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-8"><a href="#AC-Code-8" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="030"><a href="#030" class="headerlink" title="030"></a>030</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-9"><a href="#AC-Code-9" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ProjectEuler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProjectEuler 011 - 020</title>
      <link href="/p/27f7.html"/>
      <url>/p/27f7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以回顾的题目:</p><ul><li>016</li><li>017</li></ul><h2 id="011"><a href="#011" class="headerlink" title="011"></a>011</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">grid</span>(<span class="number">20</span>,vector&lt;<span class="keyword">int</span>&gt;(<span class="number">20</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> grid_i = <span class="number">0</span>;grid_i &lt; <span class="number">20</span>;grid_i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> grid_j = <span class="number">0</span>;grid_j &lt; <span class="number">20</span>;grid_j++)&#123;</span><br><span class="line">            cin &gt;&gt; grid[grid_i][grid_j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 可能会忘记反对角线</span></span><br><span class="line">    <span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> ay = <span class="number">0</span>; ay &lt; <span class="number">20</span>; ay++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ax = <span class="number">0</span>; ax &lt; <span class="number">20</span>; ax++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> d = <span class="number">0</span>; d &lt; <span class="number">4</span>; d++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(ax + <span class="number">3</span> * dx[d] &lt; <span class="number">0</span> || ax + <span class="number">3</span> * dx[d] &gt;= <span class="number">20</span> || ay + <span class="number">3</span> * dy[d] &lt; <span class="number">0</span> || ay + <span class="number">3</span> * dy[d] &gt;= <span class="number">20</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> res = grid[ax][ay] * grid[ax + dx[d]][ay + dy[d]] * grid[ax + <span class="number">2</span> * dx[d]][ay + <span class="number">2</span> * dy[d]] * grid[ax + <span class="number">3</span> * dx[d]][ay + <span class="number">3</span> * dy[d]];</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="012"><a href="#012" class="headerlink" title="012"></a>012</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= k / i; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(k % i == <span class="number">0</span>)&#123;</span><br><span class="line">            s++;</span><br><span class="line">            k /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        res *= (s + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(k &gt; <span class="number">1</span>) res *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> res &gt; n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; ; j++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = j * (j + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(n, k))&#123;</span><br><span class="line">            <span class="keyword">return</span> k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="013"><a href="#013" class="headerlink" title="013"></a>013</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e3</span> + <span class="number">10</span>;</span><br><span class="line">string s[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) cin &gt;&gt; s[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">49</span>; j &gt;=<span class="number">0</span>; j--)&#123;</span><br><span class="line">            a[i].<span class="built_in">push_back</span>(s[i][j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; <span class="number">50</span> || carry; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">50</span>)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                carry += a[j][i];</span><br><span class="line">            &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">        carry /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = res.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt;= len - <span class="number">10</span>; i--) cout &lt;&lt; res[i];</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="014"><a href="#014" class="headerlink" title="014"></a>014</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>记忆化，注意用long long处理溢出</p><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 否则卡四个例子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5000010</span>;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"><span class="keyword">int</span> step[N];</span><br><span class="line"><span class="keyword">int</span> dp[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    step[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    step[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        ll s = <span class="number">0</span>, t = i;</span><br><span class="line">        <span class="keyword">while</span>((t &lt;= n &amp;&amp; step[t] == <span class="number">0</span>) || t &gt; n)&#123;</span><br><span class="line">            <span class="keyword">if</span>(t &amp; <span class="number">1</span>)&#123;</span><br><span class="line">                t = t * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                t = t / <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s++;</span><br><span class="line">        &#125;</span><br><span class="line">        step[i] = s + step[t];</span><br><span class="line">        <span class="keyword">if</span>(step[i] &gt;= step[dp[i - <span class="number">1</span>]])&#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">int</span> mx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        cin &gt;&gt; q[i];</span><br><span class="line">        mx = <span class="built_in">max</span>(mx, q[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">init</span>(mx);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">        cout &lt;&lt; dp[q[i]] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="015"><a href="#015" class="headerlink" title="015"></a>015</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, mod = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">int</span> dp[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; N; j++)&#123;</span><br><span class="line">            dp[i][j] = (dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>]) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n, m;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        cout &lt;&lt; dp[n][m] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="016"><a href="#016" class="headerlink" title="016"></a>016</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>想多了，正常记忆化就行</p><h3 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> k = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; t = s.<span class="built_in">back</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">            <span class="keyword">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, carry = <span class="number">0</span>; i &lt; m || carry; i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i &lt; m) carry += t[i] * <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">                carry /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(s[n].<span class="built_in">begin</span>(), s[n].<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="017"><a href="#017" class="headerlink" title="017"></a>017</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>感觉每次都要写错几次系列。。。</p><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line">vector&lt;string&gt; v1 = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;One&quot;</span>, <span class="string">&quot;Two&quot;</span>, <span class="string">&quot;Three&quot;</span>, <span class="string">&quot;Four&quot;</span>, <span class="string">&quot;Five&quot;</span>, <span class="string">&quot;Six&quot;</span>, <span class="string">&quot;Seven&quot;</span>, <span class="string">&quot;Eight&quot;</span>, <span class="string">&quot;Nine&quot;</span>, <span class="string">&quot;Ten&quot;</span>, <span class="string">&quot;Eleven&quot;</span>, <span class="string">&quot;Twelve&quot;</span>, <span class="string">&quot;Thirteen&quot;</span>, <span class="string">&quot;Fourteen&quot;</span>, <span class="string">&quot;Fifteen&quot;</span>, <span class="string">&quot;Sixteen&quot;</span>, <span class="string">&quot;Seventeen&quot;</span>, <span class="string">&quot;Eighteen&quot;</span>, <span class="string">&quot;Nineteen&quot;</span>&#125;;</span><br><span class="line">vector&lt;string&gt; v2 = &#123;<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Twenty&quot;</span>, <span class="string">&quot;Thirty&quot;</span>, <span class="string">&quot;Forty&quot;</span>, <span class="string">&quot;Fifty&quot;</span>, <span class="string">&quot;Sixty&quot;</span>, <span class="string">&quot;Seventy&quot;</span>, <span class="string">&quot;Eighty&quot;</span>, <span class="string">&quot;Ninety&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">convertHundred</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">    string res;</span><br><span class="line">    <span class="keyword">int</span> a = num / <span class="number">100</span>, b = num % <span class="number">100</span>, c = num % <span class="number">10</span>;</span><br><span class="line">    res = b &lt; <span class="number">20</span> ? v1[b] : v2[b / <span class="number">10</span>] + (c ? <span class="string">&quot; &quot;</span> + v1[c] : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(a &gt; <span class="number">0</span>) res = v1[a] + <span class="string">&quot; Hundred&quot;</span> + (b ? <span class="string">&quot; &quot;</span> + res : <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>  res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">numberToWords</span><span class="params">(ll num)</span> </span>&#123;</span><br><span class="line">    string res = <span class="built_in">convertHundred</span>(num % <span class="number">1000</span>);</span><br><span class="line">    vector&lt;string&gt; v = &#123;<span class="string">&quot;Thousand&quot;</span>, <span class="string">&quot;Million&quot;</span>, <span class="string">&quot;Billion&quot;</span>, <span class="string">&quot;Thousand Billion&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        num /= <span class="number">1000</span>;</span><br><span class="line">        res = num % <span class="number">1000</span> ? <span class="built_in">convertHundred</span>(num % <span class="number">1000</span>) + <span class="string">&quot; &quot;</span> + v[i] + <span class="string">&quot; &quot;</span> + res : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(res.<span class="built_in">back</span>() == <span class="string">&#x27; &#x27;</span>) res.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span> res.<span class="built_in">empty</span>() ? <span class="string">&quot;Zero&quot;</span> : res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        ll n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">numberToWords</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="018"><a href="#018" class="headerlink" title="018"></a>018</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-7"><a href="#AC-Code-7" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">26</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                cin &gt;&gt; g[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                g[i][j] += <span class="built_in">max</span>(g[i + <span class="number">1</span>][j], g[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; g[<span class="number">1</span>][<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="019"><a href="#019" class="headerlink" title="019"></a>019</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>看着都烦，也是一写必错系列。。。</p><h3 id="AC-Code-8"><a href="#AC-Code-8" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#</span><br></pre></td></tr></table></figure><h2 id="020"><a href="#020" class="headerlink" title="020"></a>020</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>记忆化就够了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; s;</span><br><span class="line">    s.<span class="built_in">push_back</span>(&#123;<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> k = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt;= n; i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; t = s.<span class="built_in">back</span>(); <span class="comment">// (k - 1)!</span></span><br><span class="line">            <span class="keyword">int</span> m = t.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, carry = <span class="number">0</span>; j &lt; m || carry; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt; m) carry += t[j] * i;</span><br><span class="line">                res.<span class="built_in">push_back</span>(carry % <span class="number">10</span>);</span><br><span class="line">                carry /= <span class="number">10</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push_back</span>(res);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">accumulate</span>(s[n].<span class="built_in">begin</span>(), s[n].<span class="built_in">end</span>(), <span class="number">0</span>) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ProjectEuler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProjectEuler 001 - 010</title>
      <link href="/p/8a3d.html"/>
      <url>/p/8a3d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>可以回顾的题目:</p><ul><li>004</li><li>007</li><li>009</li></ul><h2 id="001"><a href="#001" class="headerlink" title="001"></a>001</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>计数问题，一步到位，否则超时</p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = x / y;</span><br><span class="line">    <span class="keyword">return</span>  (ll)k * (k + <span class="number">1</span>) / <span class="number">2</span> * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        ll res = <span class="number">0</span>;</span><br><span class="line">        res += <span class="built_in">f</span>(n - <span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line">        res += <span class="built_in">f</span>(n - <span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">        res -= <span class="built_in">f</span>(n - <span class="number">1</span>, <span class="number">15</span>);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="002"><a href="#002" class="headerlink" title="002"></a>002</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function">ll <span class="title">f</span><span class="params">(<span class="keyword">long</span> n)</span></span>&#123;</span><br><span class="line">    ll res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> pre = <span class="number">1</span>, now = <span class="number">1</span>, next;</span><br><span class="line">    <span class="keyword">while</span>(now &lt; n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(now % <span class="number">2</span> == <span class="number">0</span>) res += now;</span><br><span class="line">        next = pre + now;</span><br><span class="line">        pre = now;</span><br><span class="line">        now = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">long</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="003"><a href="#003" class="headerlink" title="003"></a>003</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">long</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">long</span> mx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">long</span> i = <span class="number">2</span>; i &lt;= n / i; i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(n % i == <span class="number">0</span>)&#123;</span><br><span class="line">                n /= i;</span><br><span class="line">                mx = <span class="built_in">max</span>(mx, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">1</span>) mx = <span class="built_in">max</span>(mx, n);</span><br><span class="line">        cout &lt;&lt; mx &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="004"><a href="#004" class="headerlink" title="004"></a>004</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>算有点小技巧吧，巧用upper_bound函数</p><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp; b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a &gt; b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> t = n;</span><br><span class="line">    <span class="keyword">while</span>(t)&#123;</span><br><span class="line">        res = res * <span class="number">10</span> + t % <span class="number">10</span>;</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res == n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">100</span>; i &lt;= <span class="number">999</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt;= <span class="number">999</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> k = i * j;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(k)) s.<span class="built_in">push_back</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">sort</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), cmp);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; *<span class="built_in">upper_bound</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), n, cmp) &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="005"><a href="#005" class="headerlink" title="005"></a>005</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lcm</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (ll)a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">lcm</span>(res, i);</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="006"><a href="#006" class="headerlink" title="006"></a>006</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>求一下通项公式</p><h3 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; (ll)(n - <span class="number">1</span>) * n * (n + <span class="number">1</span>) / <span class="number">6</span> * (<span class="number">3</span> * n + <span class="number">2</span>) / <span class="number">2</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="007"><a href="#007" class="headerlink" title="007"></a>007</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>线性筛，有趣的bug</p><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">120000</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="comment">//if(cnt &gt; 10000) break;</span></span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            a[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; a[j] &lt;= N / i; j++)&#123;</span><br><span class="line">            st[a[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % a[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; a[n - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="008"><a href="#008" class="headerlink" title="008"></a>008</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>略</p><h3 id="AC-Code-7"><a href="#AC-Code-7" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">int</span> k;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        string num;</span><br><span class="line">        cin &gt;&gt; num;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : num) a.<span class="built_in">push_back</span>(c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            res *= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; k; j++) t *= a[i - j];</span><br><span class="line">            res = <span class="built_in">max</span>(res, t);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="009"><a href="#009" class="headerlink" title="009"></a>009</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>一点小技巧吧，若成立则有:</p><script type="math/tex; mode=display">\begin{aligned}    a + b + c &= n\\    a^2 + b^2 &= c^2\\    a^2 + b^2 &= (n - a - b)^2\\    a^2 + b^2 &= n^2 + a^2 + b^2 + 2ab - 2n(a +  b)\\    0 &= n^2 + 2ab - 2na - 2nb\\    b &= (n^2 - 2na)/ (2a - 2n) \\    b & = (a ^ 2 - (a - n)^2) / 2(n - a)\end{aligned}</script><p>即有：</p><script type="math/tex; mode=display">b = \frac{a ^ 2 - (a - n)^2}{2(n - a}</script><p>于是，所以，易得。</p><h3 id="AC-Code-8"><a href="#AC-Code-8" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &amp; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a = n / <span class="number">3</span>; a &gt;= <span class="number">1</span>; a--)&#123;</span><br><span class="line">        <span class="keyword">int</span> b = (a * a - (a - n) * (a - n)) / <span class="number">2</span> / (a - n);</span><br><span class="line">        <span class="keyword">int</span> c = n - a - b;</span><br><span class="line">        <span class="keyword">if</span>(a &gt;= b || b &gt;= c) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(a * a + b * b == c * c)&#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, a * b * c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="010"><a href="#010" class="headerlink" title="010"></a>010</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><p>基本就是线性筛法</p><h3 id="AC-Code-9"><a href="#AC-Code-9" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> primes[N];</span><br><span class="line">ll s[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= N; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!st[i])&#123;</span><br><span class="line">            primes[cnt++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; primes[j] &lt;= N / i; j++)&#123;</span><br><span class="line">            st[primes[j] * i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(i % primes[j] == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] + i * (<span class="number">1</span> - st[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> a0 = <span class="number">0</span>; a0 &lt; t; a0++)&#123;</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        cout &lt;&lt; s[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ProjectEuler </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉计划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNets v3</title>
      <link href="/p/e50e.html"/>
      <url>/p/e50e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Searching for MobileNetV3</p><p>目标仍然时优化移动设备上的精度延迟权衡(accuracy-latency trade off)，引入了一些新的概念：</p><ul><li><p>complementary search technique 互补搜索技术</p></li><li><p>new efficient versions of nonlinearities practical for the mobile setting 新的高效版本的非线性使用的移动设置</p></li><li><p>new efficient network design 新的高效的网络设计</p></li><li><p>new efficient segmentation decoder 新的高效的分割解码器</p></li></ul><p>涉及的其他一些知识。</p><ul><li>swish</li><li>sigmoid $\rightarrow$ hard sigmoid </li></ul><p>展望：It remians an open question of how best to blend automatic search techniques with human intuition，即如何将自动搜索技术和人类直觉相结合。</p><h2 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h2><p>总结回顾了一部分网络, 参数数量和 MAdds是不同的概念，MAdds和参数数量的关系不是严格的相等。</p><ul><li><p>SqueezeNet: 广泛使用 $1\times 1$ 卷积，squeeze 和 expand模块来减少参数数量</p></li><li><p>MobileNet v1: 使用深度可分离卷积(depthwise deparable convolution)来提高卷积计算的效率</p></li><li><p>MobileNet v2: 引入了反向残差连接(inverted residuals)和线性瓶颈(linear bottlenecks)来构建高效资源块</p><p>下面的几个目前我还没读</p></li><li><p>ShuffleNet: 使用了组卷积(group convolution)和通道打乱(channel shuffle)进一步降低MAdds</p></li><li><p>CondenseNet: 在训练阶段学习组卷积，以保持层之间有用的密集连接，以便特征重用(feature re-use)。</p></li><li><p>ShiftNet: 提出了与逐点卷积交错的移位操作(shift operation)来代替空间卷积(expensive)。</p><p>上面三个后续如果有需要再进行补充。</p></li></ul><p>随后提到了结构设计的问题，相关论文在参考文献自寻。</p><p>为了实现结构设计过程的自动化，RL被引入到了搜索具有挑战的高效的架构中，但是搜索空间可能是指数级增长并且难以处理。因此早期的架构搜索都是集中在了单元级别的结构搜索，同一单元在所有层重用。MnasNet 搜索一个块级分层搜索空间，允许网络在不同分辨率块上使用不同的层结构。为了减少搜索的代价，[…]使用了差分(differentiable)结构搜索框架，并进行了基于梯度的优化(gradient-based optimization)。为了使现有网络适用于受限的移动平台，[…]提出了更高效的自动化网络简化算法。</p><p>[…]量化(Quantization)是通过降低算术精度来提高网络效率的一个补充方法，[…]知识蒸馏(distillation)提供了一个额外的补充方法，可以在大的 “teacher”网络下训练精确的小”student”网络。</p><p>[…]涉及的论文目前没有看过，自行在论文中查找。</p><h2 id="Efficient-Mobile-Building-Blocks"><a href="#Efficient-Mobile-Building-Blocks" class="headerlink" title="Efficient Mobile Building Blocks"></a>Efficient Mobile Building Blocks</h2><p>MobileNet v1和MobileNet v2说累了，这里跳过了。</p><p>MnasNet 建立在MobileNet v2结构之上，在瓶颈结构中引入了基于挤压(squeeze)和激励(excitation)的轻量化注意力模块(attention)。挤压和激励模块集成在不同的位置，而不是像基于ResNet的模块。模块放置在扩展层(expansion)的深度过滤器模块(depthwise filters)之后，以便注意力应用于下图中的最大表示。</p><p><img src="/p/e50e/MobileNetsv3-2.png" style="zoom:60%;"></p><p> 对于MobileNet v3,使用了这些层的组合来构建块以便于构建最有效的模型，并且每一层还是用改进的 Swish激活函数，挤压和激励模块以及swish都是用 sigmoid，这个在计算上效率是低下的，并且在固点算法中保持精度，因此将其替换成了 hard sigmoid.</p><h2 id="NetWork-Search"><a href="#NetWork-Search" class="headerlink" title="NetWork Search"></a>NetWork Search</h2><p>网络搜索时探索和优化网络架构中的一个非常强大的工具[…]，对于MobileNet v3，使用了平台感知的NAS，通过优化每个网络来搜索全局网络结构，然后使用了NetAdapt算法来搜索每一层的过滤器数量。这些技术是互补的，并且可以结合起来有效地找到针对于给定硬件平台的优化模型。</p><h3 id="Platform-Aware-NAS-for-Block-wise-Search"><a href="#Platform-Aware-NAS-for-Block-wise-Search" class="headerlink" title="Platform-Aware NAS for Block-wise Search"></a>Platform-Aware NAS for Block-wise Search</h3><p>这里直接使用了 MnasNet-A1来作为初始的大型移动模型(因为使用了和 MasNet相同的基于rnn的控制器和相同的分解层次搜索空间，所以结构肯定类似，于是直接重用了？并不理解表达的意思)，然后在其上应用 NetAdapt和其他的优化算法。</p><p>但是最初的奖励函数的设计并没有针对小型移动模型进行优化，具体的来说，它使用的是多目标的奖励函数：$ACC(m)\times[LAT(m)/TAR]^w$ 来近似帕累托最优解(Pareto-optimal solutions)，并基于每个目标延迟 $TAR$ 对每个模型 $m$ 平衡模型精度 $ACC(m)$ 和延迟 $LAT(m)$。对于小模型，精度随延迟的变化显著，因此需要一个更小的权重因子 $w = -0.15$ (origin = -0.07)，以补偿不同延迟下较大的精度变化。在新的权重因子 $w$的增强加，从头构建一个新的架构，以找到一个初始种子模型，然后应用 NetAdapt和其他优化手段来获得最终的 MobileNetV3-Small模型。</p><h3 id="NetAdapt-for-Layer-wise-Search"><a href="#NetAdapt-for-Layer-wise-Search" class="headerlink" title="NetAdapt for Layer-wise Search"></a>NetAdapt for Layer-wise Search</h3><p>架构搜索中使用的第二个技术是 NetAdapt，这是对平台感知的NAS的补充，它允许以顺序的方式微调各个层，而不是试图推断粗糙但全局的架构。具体可看原文。简而言之，这个过程是这样运行的：</p><ul><li>首先从平台感知的NAS找到的种子网络架构开始</li><li>然后对于每一步：<ul><li>生成一组proposals，每个proposal 代表了对体系结构的修改，与前一步相比，延迟至少减少了 $\delta$</li><li>对于每个proposal，使用前一步中得到的预训练的模型，并填充新提出的架构，适当的裁剪和随机初始化缺失的权值。对每一项proposal进行微调 $T$ 次，以得到精度的粗略估计。</li><li>根据指标选出最佳的proposal。</li></ul></li><li>迭代每一步直到达到目标延迟。</li></ul><p>原文中的评价指标是最小化精度的变化。这里对该算法进行改进，使延迟变化和精度变化比例最小化。也就是说，对于 NetAdapt中的每一步中生成的所有的proposals，选择其中最大化 $\frac{\Delta Acc}{\Delta latency}$ 的一项，并且满足 $\Delta Acc$ 满足前面提到的 $\delta$ 减少的限制。直觉上，proposal 是离散的，因此更倾向于能够使 trade-off 曲线斜率最大的 proposal。</p><p>这个过程重复进行，直到达到目标的延迟，然后从头开始训练新的体系结构。对 MobileNet v2使用与原始 NetAdapt相同proposal生成器。具体来说，允许两类proposals。</p><ul><li>减少 expansion layer的尺寸</li><li>减少所有共享相同 bottleneck 大小的块中的 bottleneck——以保持残差连接。</li></ul><p>实验中设置 $T = 10000$，虽然增加了初始微调的准确性，但是从零开始训练时，它不会改变最终结果的准确性。设置 $\delta = 0.01|L|$，这里 $L$ 是种子模型的延迟。</p><h2 id="NetWork-Improvement"><a href="#NetWork-Improvement" class="headerlink" title="NetWork Improvement"></a>NetWork Improvement</h2><p>除了 Network Search外，还在模型中引入了几个组件以改进最终模型。</p><ul><li>在网络的开始和结束部分重新设计计算开销较大的层</li><li>引入一种新的非线性函数 h-swich，是swich的改进，计算速度更快，也更适合量化</li></ul><h3 id="Redesigning-Expensive-Layers"><a href="#Redesigning-Expensive-Layers" class="headerlink" title="Redesigning Expensive Layers"></a>Redesigning Expensive Layers</h3><p>架构搜索找到模型之后，网络的开始和结束部分的很多层的计算代价很高，因此对模型架构进行了修改来减少这一部分层的延迟，同时保持正确性。这些改进是在当前搜索空间以外的。</p><p>第一个修改改进了网络最后几次的交互，以便更有效地生成最终的特征。目前基于MobileNetv2地inverted bottleneck 结构和变种地模型使用 $1\times 1$卷积作为最后一层，以扩展到更高维度地特征空间。这一层是至关重要的，为了能够获得更富集的特征用于预测，然而吗，这是以额外的延迟为代价的。</p><p>为了减少延迟并保留高维的特征，将这一层移到了最后的平均池化层。最后的一组特征将以$1\times1$ 的空间分辨率计算而不是 $7\times 7$空间分辨率。这种设计选择的结果是，特征的计算在计算和延迟方面上几乎free。</p><p>一旦减轻了特征生成层的计算代价，就不需要使用之前的bottleneck projection 层来减少计算量。从而可以移除前面bottleneck层中的projection和filtering层，进一步降低计算复杂度。原始和优化后的最终阶段图下所示。有效的最后阶段减少了7ms的延迟，这是运行时的11%，减少了3000层MAdds的操作数量，并且几乎没有降低正确性。</p><p><img src="/p/e50e/MobileNetsv3-3.png" style="zoom:60%;"></p><p>另一个计算代价高的层就是初始的一组滤波器。目前的移动模型倾向于在一个完整的 $3\times 3$ 卷积中使用 32个</p><p>滤波器来构建边缘检测的初始滤波器组。这些滤波器通常是彼此的镜像。尝试减少滤波器的数量，使用不同的非线性来尝试减少冗余。最后选定在这一层使用 hard swish非线性函数，因此在测试中它的性能其他非线性相当。可以将滤波器的数量减少到16个，同时使用 ReLU或 swish保持与 32个滤波器相同的精度。这额外减少了2ms 的运行时和 1000万的MAdds计算量。</p><h3 id="Nonlinearities"><a href="#Nonlinearities" class="headerlink" title="Nonlinearities"></a>Nonlinearities</h3><p>[…]引入了 swish 非线性函数把他作为 ReLU的临时替代，并且显著提高了神经网络的准确性。这个非线性函数定义为：</p><script type="math/tex; mode=display">swish(x)=x \cdot \sigma(x)</script><p>尽管这种非线性提高了精度，但是它在嵌入式环境中的代价非零，因为在移动设备上计算 sigmoid函数代价较高。使用两种方法来处理这个问题：</p><ul><li><p>类似于[..]，将sigmoid函数替换为它的分段线性硬模拟函数: $\frac{ReLU6(x+3)}{6}$, 最小的区别就是使用 ReLU6而不是传统的裁剪常量。类似的，硬版本的 swish 就变成了:</p><script type="math/tex; mode=display">h-swish(x)=x\frac{ReLU6(x+3)}{6}</script><p>[…]也提出了一个版本的hard-swish。 sigmoid和swish的对比图如下所示。</p><p><img src="/p/e50e/MobileNetsv3-4.png" style="zoom:60%;"></p><p>常量的选择动机就是简化并且尽可能好的匹配原始版本。实验中发现所有这些功能在 hard 版上的准确性没有明显的差异，但是在部署的角度上却有很多优势：</p><ul><li>在几乎所有的软硬件框架下都有ReLU6的优化实现</li><li>在量化模式下，消除了由于不同的近似 sigmoid实现可能造成的数值精度损失</li><li>在实践中，h-swish 可以实现为分段函数来减少内存访问的次数，从而大大降低延迟的成本</li></ul></li><li><p>应用非线性函数的代价会随着网络的深入而降低，因为每一层的激活体内存会在分辨率下降时减半。只有在更深的层次中使用才可以实现 swish 的大部分的优势。因此，在网络架构的后半部分使用h-swish，具体的网络布局如下所示。</p><ul><li><p>MobileNetV3 Large</p><p><img src="/p/e50e/MobileNetsv3-5.png" style="zoom:60%;"></p></li><li><p>MobileNet V3 Small</p><p><img src="/p/e50e/MobileNetsv3-6.png" style="zoom:60%;"></p></li></ul></li></ul><p>尽管有了这些优化，h-swish仍然会带来一些延迟代价。后面的实验演示中说明了，网络对精确度和延迟上，在没有优化的情况下是积极的，在使用基于分段函数的优化实现时，影响是显著的。</p><h3 id="Large-squeeze-and-excite"><a href="#Large-squeeze-and-excite" class="headerlink" title="Large squeeze-and-excite"></a>Large squeeze-and-excite</h3><p>MnasNet中，squeeze-and-excite bottleneck的大小与 convolution bottleneck相关。相反，这里将他们全部替换为固定，使其为 expansion层的 $1/4$，这样做可以在增加参数数量的情况下提高准确性，并且没有显著的延迟代价。</p><h3 id="MobileNetV3-Definitions"><a href="#MobileNetV3-Definitions" class="headerlink" title="MobileNetV3 Definitions"></a>MobileNetV3 Definitions</h3><p>MobileNetV3 定义为两个模型：MobileNetV3-Large和MobileNetV3-Small，这两个模型分别用于高资源和低资源用例。这些模型通过平台感知NAS和NetAdapt进行网络搜索，并结合定义的网络改进方法来创建。具体见Table 1&amp;Table 2。</p>]]></content>
      
      
      <categories>
          
          <category> 轻量化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MobileNets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Luogu-[图论2-3]-最小生成树</title>
      <link href="/p/b241.html"/>
      <url>/p/b241.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://www.luogu.com.cn/training/209#problems">题单链接</a></p><h2 id="P3366-模板-最小生成树"><a href="#P3366-模板-最小生成树" class="headerlink" title="P3366 [模板][最小生成树]"></a>P3366 [模板][最小生成树]</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>模板题而已</p><h3 id="AC-Code"><a href="#AC-Code" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>, cost = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = e[i].a, b = e[i].b;</span><br><span class="line">        <span class="keyword">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            cost += e[i].w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt; n - <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;orz&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; cost &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 4 5</span></span><br><span class="line"><span class="comment"> 1 2 2</span></span><br><span class="line"><span class="comment"> 1 3 2</span></span><br><span class="line"><span class="comment"> 1 4 3</span></span><br><span class="line"><span class="comment"> 2 3 4</span></span><br><span class="line"><span class="comment"> 3 4 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 7</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P2872-USACO07DEC-Building-Roads-S"><a href="#P2872-USACO07DEC-Building-Roads-S" class="headerlink" title="P2872  USACO07DEC Building Roads S"></a>P2872  USACO07DEC Building Roads S</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>如果 $i,j$ 之间有边，则设权重为 $0$, 否则计算出边权，然后MST算法。比较坑的地方在求欧氏距离的时候，$dx <em> dx + dy </em> dy$可能 int 溢出，所以需要转换成 long long 或者double。</p><h3 id="AC-Code-1"><a href="#AC-Code-1" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line">PII q[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">bool</span> st[N][N];</span><br><span class="line">vector&lt;e&gt; vece;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(PII a, PII b)</span></span>&#123;</span><br><span class="line">    ll dx = a.x - b.x;</span><br><span class="line">    ll dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        vece.<span class="built_in">push_back</span>(&#123;a, b, <span class="number">0</span>&#125;);</span><br><span class="line">        st[a][b] = st[b][a] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(st[i][j]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                vece.<span class="built_in">push_back</span>(&#123;i, j, <span class="built_in">get_dist</span>(q[i], q[j])&#125;);</span><br><span class="line">                st[i][j] = st[j][i] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vece.<span class="built_in">begin</span>(), vece.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : vece)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e.a), b = <span class="built_in">find</span>(e.b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += e.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 4 1</span></span><br><span class="line"><span class="comment"> 1 1</span></span><br><span class="line"><span class="comment"> 3 1</span></span><br><span class="line"><span class="comment"> 2 3</span></span><br><span class="line"><span class="comment"> 4 3</span></span><br><span class="line"><span class="comment"> 1 4</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 4.00</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>可能溢出的一组数据:</p><p>in:<a href="/downloads/Luogu/P2872_2.in">输入</a></p><p>out:<a href="/downloads/Luogu/P2872_2.out">输出</a></p><h2 id="P1991-无线通讯网"><a href="#P1991-无线通讯网" class="headerlink" title="P1991 无线通讯网"></a>P1991 无线通讯网</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>根据坐标建图，然后MST，只需要在连通分量树 $cnt \leq k$ 时即可，k为卫星电话数，res为记录中的最小值。</p><p>原理很好理解，连通分量随加边而减少，且边权递减，因此序列性保证了答案的正确性。</p><h3 id="AC-Code-2"><a href="#AC-Code-2" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line">PII q[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">vector&lt;e&gt; vece;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(PII a, PII b)</span></span>&#123;</span><br><span class="line">    ll dx = a.x - b.x;</span><br><span class="line">    ll dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; q[i].x &gt;&gt; q[i].y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            vece.<span class="built_in">push_back</span>(&#123;i, j, <span class="built_in">get_dist</span>(q[i], q[j])&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(vece.<span class="built_in">begin</span>(), vece.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : vece)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= m) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e.a), b = <span class="built_in">find</span>(e.b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = e.w;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf\n&quot;</span>, res);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 2 4</span></span><br><span class="line"><span class="comment"> 0 100</span></span><br><span class="line"><span class="comment"> 0 300</span></span><br><span class="line"><span class="comment"> 0 600</span></span><br><span class="line"><span class="comment"> 150 750</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 212.13</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P1967-NOIP2013-提高组-货车运输"><a href="#P1967-NOIP2013-提高组-货车运输" class="headerlink" title="P1967 [NOIP2013 提高组] 货车运输"></a>P1967 [NOIP2013 提高组] 货车运输</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-3"><a href="#AC-Code-3" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h2 id="P4047-JSOI2010-部落划分"><a href="#P4047-JSOI2010-部落划分" class="headerlink" title="P4047 [JSOI2010] 部落划分"></a>P4047 [JSOI2010] 部落划分</h2><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>暴力存边，MST直到连通分量数为k，然后继续MST，第一个连接两个不同分量的边对应的权值即为答案。</p><p>二分以后补充</p><h3 id="AC-Code-4"><a href="#AC-Code-4" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> x first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> y second</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; PII;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">double</span> w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N * N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line">PII q[N];</span><br><span class="line"><span class="keyword">int</span> n, k, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_dist</span><span class="params">(PII a, PII b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dx = a.x - b.x;</span><br><span class="line">    <span class="keyword">int</span> dy = a.y - b.y;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>(dx * dx + dy * dy);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; q[i].x &gt;&gt; q[i].y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            e[t++] = &#123;i, j, <span class="built_in">get_dist</span>(q[i], q[j])&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt = n;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; t; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= k) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> res;</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; t; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            res = e[i].w;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2lf&quot;</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 4 2</span></span><br><span class="line"><span class="comment"> 0 0</span></span><br><span class="line"><span class="comment"> 0 1</span></span><br><span class="line"><span class="comment"> 1 1</span></span><br><span class="line"><span class="comment"> 1 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 1.00</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P1396-营救"><a href="#P1396-营救" class="headerlink" title="P1396 营救"></a>P1396 营救</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>正常的MST求解，当s,t联通时退出</p><p>当然二分最短路应该也可以。</p><h3 id="AC-Code-5"><a href="#AC-Code-5" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m, s, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s &gt;&gt; t;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(s) == <span class="built_in">find</span>(t)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res = e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 3 3 1 3</span></span><br><span class="line"><span class="comment"> 1 2 2</span></span><br><span class="line"><span class="comment"> 2 3 1</span></span><br><span class="line"><span class="comment"> 1 3 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 2</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P2121-拆地毯"><a href="#P2121-拆地毯" class="headerlink" title="P2121 拆地毯"></a>P2121 拆地毯</h2><h3 id="思路-6"><a href="#思路-6" class="headerlink" title="思路"></a>思路</h3><p>等价于最大生成树中的前k个边</p><h3 id="AC-Code-6"><a href="#AC-Code-6" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &gt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &lt;= <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">            k--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 5 4 3</span></span><br><span class="line"><span class="comment"> 1 2 10</span></span><br><span class="line"><span class="comment"> 1 3 9</span></span><br><span class="line"><span class="comment"> 2 3 7</span></span><br><span class="line"><span class="comment"> 4 5 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 22</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P1194-买礼物"><a href="#P1194-买礼物" class="headerlink" title="P1194 买礼物"></a>P1194 买礼物</h2><h3 id="思路-7"><a href="#思路-7" class="headerlink" title="思路"></a>思路</h3><p>超级源点，建立源点0和其他点之间的边，e[0, i] = A然后跑 MST即可。</p><h3 id="AC-Code-7"><a href="#AC-Code-7" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N * N];</span><br><span class="line"><span class="keyword">int</span> p[N], g[N][N];</span><br><span class="line"><span class="keyword">int</span> n, m, t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        e[t++] = &#123;<span class="number">0</span>, i, m&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(g[i][j] != <span class="number">0</span>) e[t++] = &#123;i, j, g[i][j]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + t);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 3 3</span></span><br><span class="line"><span class="comment"> 0 2 4</span></span><br><span class="line"><span class="comment"> 2 0 2</span></span><br><span class="line"><span class="comment"> 4 2 0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 7</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P1195-口袋的天空"><a href="#P1195-口袋的天空" class="headerlink" title="P1195 口袋的天空"></a>P1195 口袋的天空</h2><h3 id="思路-8"><a href="#思路-8" class="headerlink" title="思路"></a>思路</h3><p>MST每一次merge的时候连通分量减1，初始为n，即将连通分量减少到k即可。</p><p>如果可以，则输出权值和，否则连通分量＞0，则“No Answer”。</p><h3 id="AC-Code-8"><a href="#AC-Code-8" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e)&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        e[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(e, e + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, cnt = n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b);</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= k) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">            p[a] = b;</span><br><span class="line">            res += e[i].w;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(cnt &lt;= k) cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No Answer&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 3 1 2</span></span><br><span class="line"><span class="comment"> 1 2 1</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="P4180-BJWC2010-严格次小生成树"><a href="#P4180-BJWC2010-严格次小生成树" class="headerlink" title="P4180 [BJWC2010] 严格次小生成树"></a>P4180 [BJWC2010] 严格次小生成树</h2><h3 id="思路-9"><a href="#思路-9" class="headerlink" title="思路"></a>思路</h3><h3 id="AC-Code-9"><a href="#AC-Code-9" class="headerlink" title="AC Code"></a>AC Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Luogu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1489</title>
      <link href="/p/3db0.html"/>
      <url>/p/3db0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1489-找到最小生成树里的关键边和伪关键边"><a href="#1489-找到最小生成树里的关键边和伪关键边" class="headerlink" title="1489. 找到最小生成树里的关键边和伪关键边"></a><a href="https://leetcode-cn.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/">1489. 找到最小生成树里的关键边和伪关键边</a></h2><p><img src="/p/3db0/LeetCode-1489-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>基础的kruskal基础上区分两种边，首先求一下MST的Mcost：</p><ul><li>关键边，删除该边，再求MST，若cost &gt; Mcost (或者不连通，也满足大于)则该边为关键边</li><li>伪关键边，非关键边有可能是伪关键边，可以先将该边加入MST，然后继续kruskal， 若cost == Mcost吗，则为非关键边，否则“啥也不是边”</li></ul><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">kruskal</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; del)</span></span>&#123;</span><br><span class="line">        p.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e == del) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="comment">// printVector1d(e);</span></span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], w = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                cnt++;</span><br><span class="line">                cost += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == n - <span class="number">1</span> ? cost : inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rekruskal</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, vector&lt;<span class="keyword">int</span>&gt;&amp; del)</span></span>&#123;</span><br><span class="line">        p.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) p[i] = i;</span><br><span class="line">        p[del[<span class="number">0</span>]] = del[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> cost = del[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e == del) <span class="keyword">continue</span>; </span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], w = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">            <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">                p[pa] = pb;</span><br><span class="line">                cnt++;</span><br><span class="line">                cost += w;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == n - <span class="number">1</span> ? cost : inf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">findCriticalAndPseudoCriticalEdges</span>(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges) &#123;</span><br><span class="line">        <span class="keyword">int</span> edgen = edges.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edgen; i++) edges[i].<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">sort</span>(edges.<span class="built_in">begin</span>(), edges.<span class="built_in">end</span>(), [&amp;](<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; b)&#123;</span><br><span class="line">            <span class="keyword">return</span> a.<span class="built_in">at</span>(<span class="number">2</span>) &lt; b.<span class="built_in">at</span>(<span class="number">2</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; del;</span><br><span class="line">        <span class="keyword">int</span> minCost = <span class="built_in">kruskal</span>(n, edges, del);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            del = e;</span><br><span class="line">            <span class="keyword">int</span> cost = <span class="built_in">kruskal</span>(n, edges, del);</span><br><span class="line">            <span class="comment">//cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; cost &lt;&lt; endl;</span></span><br><span class="line">            <span class="keyword">if</span>(cost &gt; minCost) res[<span class="number">0</span>].<span class="built_in">push_back</span>(e[<span class="number">3</span>]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">rekruskal</span>(n, edges, del) == minCost) res[<span class="number">1</span>].<span class="built_in">push_back</span>(e[<span class="number">3</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双深科技</title>
      <link href="/p/cb50.html"/>
      <url>/p/cb50.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><h3 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h3><p>给定数组有N+M个数字, 数字的范围为1…N, 打印重复的元素, 要求算法的时 间渐进复杂度为O(M+N)，算法的额外空间复杂度为O(1)。  输入格式：两行，第一行为N、M两个整数（int）；第二行为M+N个整数。各整数 之间均用空格间隔。 输出格式：一行，若干个整数，可重复输出，顺序无所谓， 各 整数之间均用空格间隔。 </p><p>输入：</p><blockquote><p>5 3  </p><p>1 5 4 5 3 2 5 4</p></blockquote><p>输出</p><blockquote><p>5 5 4 </p></blockquote><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n, m, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(a, <span class="number">0xff</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>, t = n + m; i &lt;= t; i++)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        <span class="keyword">if</span>(a[s] != s)&#123;</span><br><span class="line">            a[s] = s;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cout &lt;&lt; s &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">solve1</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><h3 id="题面-1"><a href="#题面-1" class="headerlink" title="题面"></a>题面</h3><p>=LeetCode 接雨水</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, l = <span class="number">1</span>, r = n;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">int</span> minn = <span class="built_in">min</span>(a[l], a[r]);</span><br><span class="line">        <span class="keyword">if</span>(a[l] == minn)&#123;</span><br><span class="line">            l++;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; a[l] &lt; minn)&#123;</span><br><span class="line">                res += minn - a[l];</span><br><span class="line">                l++; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            r--;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r &amp;&amp; a[r] &lt; minn)&#123;</span><br><span class="line">                res += minn - a[r];</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><h3 id="题面-2"><a href="#题面-2" class="headerlink" title="题面"></a>题面</h3><p>给定一个正整数 N（1 ≤ N ≤ $2^{59}$）,求出1…N 这N个数的二进制表示中总共的1的个数。 </p><p>输入: (1-10)二进制串为 11011100101110111100010011010 有17个1.</p><blockquote><p>10</p></blockquote><p>输出:</p><blockquote><p>17</p></blockquote><p>数位dp = 找规律</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> ull;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="comment">//1ll &lt;&lt; 59 -&gt; 17005592192950992897</span></span><br><span class="line">    <span class="comment">//1ll &lt;&lt; 30 -&gt; 16106127361</span></span><br><span class="line">    <span class="comment">//n = (1ll &lt;&lt; 59);</span></span><br><span class="line">    ll k = <span class="number">1</span>; <span class="comment">// 2 ^ k</span></span><br><span class="line">    ull res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(; n &gt;= k; )&#123;</span><br><span class="line">        ll tn = n - (k - <span class="number">1</span>);</span><br><span class="line">        res += (tn / (k * <span class="number">2</span>)) * k + <span class="built_in">min</span>(tn % (k * <span class="number">2</span>), k);</span><br><span class="line">        k *= <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; res &lt;&lt; endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><h3 id="题面-3"><a href="#题面-3" class="headerlink" title="题面"></a>题面</h3><p>给定非负整数N、M，求出N的M次幂的准确结果。  </p><p>输入格式：一行，包含两个32位整数（int）N和M。各整数之间均用空格间隔。  </p><p>输出格式：一行，输出N的M次幂结果即可。 </p><p>输入:</p><blockquote><p>2 65</p></blockquote><p>输出:</p><blockquote><p>36893488147419103232</p></blockquote><p>快速幂 + 高精度</p><h3 id="Code1"><a href="#Code1" class="headerlink" title="Code1"></a>Code1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">add</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> alen = a.<span class="built_in">size</span>(), blen = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; alen || i &lt; blen || t; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; alen) t += a[i];</span><br><span class="line">        <span class="keyword">if</span>(i &lt; blen) t += b[i];</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mull</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, <span class="keyword">int</span> b, <span class="keyword">int</span> off)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    <span class="keyword">int</span> len = a.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, t = <span class="number">0</span>; i &lt; len || t; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; len) t += a[i] * b;</span><br><span class="line">        c.<span class="built_in">push_back</span>(t % <span class="number">10</span>);</span><br><span class="line">        t /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(off--)&#123;</span><br><span class="line">        c.<span class="built_in">insert</span>(c.<span class="built_in">begin</span>(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">mul</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; a, vector&lt;<span class="keyword">int</span>&gt; b)</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; c;</span><br><span class="line">    c.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> len = b.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> k = b[i];</span><br><span class="line">        c = <span class="built_in">add</span>(c, <span class="built_in">mull</span>(a, k, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    res.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; base;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        base.<span class="built_in">push_back</span>(n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(m)&#123;</span><br><span class="line">        <span class="keyword">if</span>(m &amp; <span class="number">1</span>) res = <span class="built_in">mul</span>(res, base);</span><br><span class="line">        base = <span class="built_in">mul</span>(base, base);</span><br><span class="line">        m &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: res) cout &lt;&lt; c;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Code2"><a href="#Code2" class="headerlink" title="Code2"></a>Code2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing1148-秘密的奶牛运输</title>
      <link href="/p/bdf0.html"/>
      <url>/p/bdf0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://oi-wiki.org/graph/mst/#_8">复习一手原理(知识点)</a></p><p>OIwiki上的拓展知识点好多，我是废物。</p><h2 id="1148-秘密的牛奶运输"><a href="#1148-秘密的牛奶运输" class="headerlink" title="1148. 秘密的牛奶运输"></a><a href="https://www.acwing.com/problem/content/1150/">1148. 秘密的牛奶运输</a></h2><p><img src="/p/bdf0/AcWing-1148-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Oiwiki上学一下知识点就行了，区分一下严格和非严格的处理细节。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">510</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> f;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; t) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; t.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dist[<span class="number">2</span>][N][N];</span><br><span class="line"><span class="keyword">int</span> h[N], e[N * <span class="number">2</span>], ne[N * <span class="number">2</span>], w[N * <span class="number">2</span>], idx;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f, <span class="keyword">int</span> mx1, <span class="keyword">int</span> mx2, <span class="keyword">int</span> d1[], <span class="keyword">int</span> d2[])</span></span>&#123;</span><br><span class="line">    d1[u] = mx1, d2[u] = mx2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(j != f)&#123;</span><br><span class="line">            <span class="keyword">int</span> t1 = mx1, t2 = mx2;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &gt; t1) t2 = t1, t1 = w[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w[i] &lt; t1 &amp;&amp; w[i] &gt; t2) t2 = w[i];</span><br><span class="line">            <span class="built_in">dfs</span>(j, u, t1, t2, d1, d2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, w;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">        edges[i] = &#123;a, b, w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges, edges + m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    </span><br><span class="line">    LL sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a = edges[i].a , b = edges[i].b, w = edges[i].w;</span><br><span class="line">        <span class="keyword">int</span> pa = <span class="built_in">find</span>(a), pb = <span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(pa != pb)&#123;</span><br><span class="line">            p[pa] = pb;</span><br><span class="line">            sum += w;</span><br><span class="line">            <span class="built_in">add</span>(a, b, w);</span><br><span class="line">            <span class="built_in">add</span>(b, a, w);</span><br><span class="line">            edges[i].f = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">dfs</span>(i, <span class="number">-1</span>, <span class="number">-1e9</span>, <span class="number">-1e9</span>, dist[<span class="number">0</span>][i], dist[<span class="number">1</span>][i]);</span><br><span class="line">    </span><br><span class="line">    LL res = <span class="number">1e18</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!edges[i].f)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = edges[i].a , b = edges[i].b, w = edges[i].w;</span><br><span class="line">            LL t;</span><br><span class="line">            <span class="keyword">if</span>(w &gt; dist[<span class="number">0</span>][a][b])</span><br><span class="line">                t = sum + w - dist[<span class="number">0</span>][a][b];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(w &gt; dist[<span class="number">1</span>][a][b])</span><br><span class="line">                t = sum + w - dist[<span class="number">1</span>][a][b];</span><br><span class="line">            res = <span class="built_in">min</span>(res, t);</span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing346-走廊泼水节</title>
      <link href="/p/9c3.html"/>
      <url>/p/9c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="346-走廊泼水节"><a href="#346-走廊泼水节" class="headerlink" title="346. 走廊泼水节"></a><a href="https://www.acwing.com/problem/content/348/">346. 走廊泼水节</a></h2><p><img src="/p/9c3/AcWing-346-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看代码就能理解该题思路，核心思想就是按照边权顺序生成完全图，新增的边权设置决定唯一性，证明略。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> p[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, w;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">            e[i] = &#123;a, b, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(e, e + n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                res += (s[a] * s[b] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                s[b] += s[a];</span><br><span class="line">                p[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing1146-新的开始</title>
      <link href="/p/d1bf.html"/>
      <url>/p/d1bf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1146-新的开始"><a href="#1146-新的开始" class="headerlink" title="1146. 新的开始"></a><a href="https://www.acwing.com/problem/content/1148/">1146. 新的开始</a></h2><p><img src="/p/d1bf/AcWing-1146-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立超级源点，添加所有点与源点的边，边权为该点的挖井费用，然后基本的最小生成树。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i) res += dist[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        cin &gt;&gt; w;</span><br><span class="line">        g[<span class="number">0</span>][i] = g[i][<span class="number">0</span>] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图论 </tag>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNets v2</title>
      <link href="/p/cd8f.html"/>
      <url>/p/cd8f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MobileNetV2-反向残差和线性瓶颈</p><p>MobileNetV1 中解读了深度可分离卷积，这里不做赘述。在 MobileNetV2 中增加了两个概念(idea) : Linear Bottleneck 和 Inverted Residuals。</p><p>不错的解读:</p><ul><li><p><a href="https://blog.csdn.net/flyfish1986/article/details/97017017">https://blog.csdn.net/flyfish1986/article/details/97017017</a></p></li><li><p><a href="https://www.cnblogs.com/hejunlin1992/p/9395345.html">https://www.cnblogs.com/hejunlin1992/p/9395345.html</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/33075914">https://zhuanlan.zhihu.com/p/33075914</a> 图很赞</p></li><li><p><a href="https://www.zhihu.com/question/265709710">https://www.zhihu.com/question/265709710</a></p></li><li><p><a href="https://yinguobing.com/bottlenecks-block-in-mobilenetv2/">https://yinguobing.com/bottlenecks-block-in-mobilenetv2/</a></p></li></ul><p>一些理解:</p><ul><li>因为 ReLU 导致信息丢失，所以使用了 Linear bottleneck</li><li>MobileNetV1: depthwise + pointwise</li><li>MobileNetV2: pointwise + depthwise + pointwise</li><li>几张图<ul><li><img src="/p/cd8f/MobileNetsv2-5.png" style="zoom:50%;"></li><li><img src="/p/cd8f/MobileNetsv2-6.png" style="zoom:50%;"></li></ul></li></ul><h2 id="Preliminaries-discussion-and-intuition"><a href="#Preliminaries-discussion-and-intuition" class="headerlink" title="Preliminaries, discussion and intuition"></a>Preliminaries, discussion and intuition</h2><h3 id="Depthwise-Separable-Convolutions"><a href="#Depthwise-Separable-Convolutions" class="headerlink" title="Depthwise Separable Convolutions"></a>Depthwise Separable Convolutions</h3><p>深度可分离卷积是许多高校神经网络架构的关键构建模块，本文也使用了这个。深度可分离卷积的基本思想就是用分解后的卷积算子替换原先的完整卷积，将卷积分成了两个独立的层。第一层为深度卷积，就是对每个输入通道进行了一个轻量化的滤波。第二个是$1\times 1$卷积，即点态卷积，用来将输入通道进行线性组合。</p><p>标准的卷积输入张量 $L_i(h_i\times w_i\times d_i)$, 通过应用卷积核 $K \in R^{k\times k \times d_i \times d_j}$ 产生一个 $h_i \times w_i\times d_j$ 的输出张量$L_j$，标准的卷积层的计算代价为 $h_i\times w_i \times d_i \times d_j \times k \times k$，</p><p>深度可分离卷积是标准卷积的直接替换，他和常规卷积性能相近，但代价只有 $h_i \times w_i \times d_i (k^2 + d_j)$，即两部分的代价和。与传统卷积层相比它有效的减少将近 $k^2$ 的代价。MobileNetV2 使用了 $k=3$ 的深度可分离卷积使得卷积代价是标准卷积的 $1/8\sim1/9$，精度只会有一点的降低。</p><p>这一方面可以在 MobileNets1中查阅。</p><h3 id="Linear-Bottlenecks"><a href="#Linear-Bottlenecks" class="headerlink" title="Linear Bottlenecks"></a>Linear Bottlenecks</h3><p>对于一个 $n$ 层的深度神经网络，每一层 $L_i$ 都有一个维度为 $h_i \times w_i \times d_i$的激活张量，(这部分主要说明这个激活张量的一些基本性质)，这可以看成一个含有 $h_i\times w_i$ 个 $d_i$ 维“像素”的容器。非正式地说，对于来自真是图像的输入集，可以说层激活体(对于任意层 $L_i$ )形成了一个<strong>“兴趣流形”</strong>。长期以来，一直假设神经网络中感兴趣的流形可以嵌入到低纬度的子空间中。换句话说，对于深度卷积层钟的所有独立的 $d$通道像素，编码在这些值中的信息实际上位于某些流形中，而这些流形则又可以嵌入到一个低维子空间中。</p><p>这种事实，可以通过简单地减少层的维数来获知和利用，并从而减少操作空间的维数。 MobileNetV1 利用了这一点，并通过一个宽度乘法因子有效的在计算量和精度之间进行权衡，并将其纳入其他网络中以及 ShuffleNet 中。根据这种直觉，宽度乘法因子允许人们减少激活体空间的维度，直到兴趣流体跨越整个空间。(意思就是说，假设激活体维度为 $M$, 实际上主要信息只需要 $m$ 维就可以，因此可以不断降低 $M$ 直到 $m$？)但是这种直觉似乎有点问题，因为深度神经网络中实际上都是使用的非线性的坐标变换。例如 <strong>ReLU</strong>。例如在 $1D$ 空间中对线使用 ReLU，则会产生一条射线。在 $n$ 维空间内使用，则会产生一个具有 $n$ 节点的分段线性曲线。</p><p>很容易的看出，如果有一层的变换 $ReLU(Bx)$ 的输出中含有一个非零体 $S$，那么 映射到 $S$ 内部中的点是通过一个线性变换获得的，也就是说，对于整个维度的输出空间，对应的输入空间的部分，是与线性变换控制的。(不好表达文章的意思，意思是说，对于输出 $M$ 维的中的非零体 $M^{\prime}$, 输入中的 $m$维，只有其中经过线性变换的 $m^{\prime}$ 部分有关，也就是说，线性变换 $B$ 决定了相关的输入，不然的话，非线性例如 <strong>ReLU</strong>，就会把一部分信息丢掉，比如 <strong>Relu</strong> 中 x &lt; 0)。换句话说，深度网络仅对非零体部分具有线性分类器的能力。</p><p>另一方面，当使用 <strong>ReLU</strong> 塌缩通道时，它不可避免地会导致这个通道的信息丢失。然而，如果有很多通道的时候，激活流形中可能有一个结构，其他通道的信息存储在其中。如果输入流形可以嵌入到激活空间的显著低维子空间中，那么 <strong>ReLU</strong> 变换将会在将所需的复杂性引入可表达函数集的同时保留信息。</p><p>总结来说，兴趣流形位于高维的激活空间中的低维子空间中：</p><ul><li>如果兴趣流形在 <strong>ReLU</strong> 后保持非零，那么它对应线性变换。</li><li>只有输入流形位于输入空间的低维子空间中时，<strong>ReLU</strong> 才能保留输入流形的完整信息。</li></ul><p>这对优化现有的神经网络架构进行了提示：假设兴趣流形是低维的，那么就可以通过在卷积块中添加 Linear bottleneck 层来获取它。实验表明使用线性层是重要的，这可以防止非线性破坏太多的信息(后续的实验证明了缺失会降低性能，还有一些工作，例如论文中提到的CIFAR数据集)。后面会使用 bottleneck convolutions，把输入瓶颈的大小和内部尺寸的大小的比例称为膨胀比。</p><h3 id="Inverted-residuals"><a href="#Inverted-residuals" class="headerlink" title="Inverted residuals"></a>Inverted residuals</h3><p>bottleneck 块类似 residual 块，每个块包含一个输入，后面是一些 bottleneck，然后是深度残差网络中的扩展块。因为 bottleneck 中包含了所有必要的信息，而扩展层仅仅作为一个实现细节伴随非线性的张量变换，因此在 bottleneck 中使用了 shortcurts。</p><h4 id="Running-time-and-parameter-count-for-bottleneck-convolution"><a href="#Running-time-and-parameter-count-for-bottleneck-convolution" class="headerlink" title="Running time and parameter count for bottleneck convolution"></a>Running time and parameter count for bottleneck convolution</h4><p>基本实现结构如下所示：</p><p><img src="/p/cd8f/MobileNetsv2-2.png" style="zoom:60%;"></p><p>对于一个大小为 $h\times w$ 的块，扩展因子为 $t$，核大小为 $k$， 输入通道数为 $d^{\prime}$, 输出通道数为 $d^{\prime\prime}$。总共的乘加计算为 $h \cdot w \cdot d^{\prime} \cdot t(d^{\prime} + k^2 + d^{\prime\prime})$。表达式中有一个额外的项，因为有一个额外的 $1\times 1$卷积，但是网络的性质允许使用更小的输入和输出维度。不同分辨率下的 MobileNetV1， MobileNetV2, ShuffleNet 对比如下。</p><p><img src="/p/cd8f/MobileNetsv2-3.png" style="zoom:80%;"></p><p>略略略</p><h2 id="Implements-Notes"><a href="#Implements-Notes" class="headerlink" title="Implements Notes"></a>Implements Notes</h2><h3 id="Memory-efficient-inference"><a href="#Memory-efficient-inference" class="headerlink" title="Memory efficient inference"></a>Memory efficient inference</h3><p>反向残差瓶颈层允许特别的内存高效实现，这对移动端应用非常重要。使用例如TensorFlow或者Caffe的一种标准高效的推理实现方式，是通过构建一个有向无环的计算超图 $G$，由表示操作的边和表示中间计算张量的结点组成。计算被安排进行时为了最小化存储在内存中的张量的总数。在一般的情况下，它搜索所有可能合理的计算顺序 $\sum(G)$，并且选择其中最小化下式的一项:</p><script type="math/tex; mode=display">M(G)=\min_{\pi \in \sum(G)} \max_{i\in 1..n}[\sum_{A\in R(i,\pi, G)}|A|] +size_{\pi_i}</script><p>其中 $R(i,\pi,G)$ 为中间张量的列表，这些张量与 $\pi_i…\pi_n$中的结点连接。$|A|$ 代表张量 $A$ 的大小，$size(i)$ 代表操作 i 期间内部存储所需要的内存总量。</p><p>对于只有平凡平行结构的图(例如残差连接)，只会由一个非平方可行的计算顺序，因此基于计算图 $G$ 的推理所使用内存总量和上界则可以简化为：</p><script type="math/tex; mode=display">M(G)=\max_{op\in G}[\sum_{A\in op_{inp}}|A|+\sum_{B\in op_{out}}|B|+|op|]</script><p>或者重新说明一下，内存的总量就是所有的输入和输出(combined)的总大小的最大值。如果把 bottleneck residual block看作一个单独操作，并且将内部的卷积看作是可丢弃的张量，那么内存的总量将由 bottleneck 张量的大小决定，而不是 bottleneck 的内部张量的大小(更大)。</p><h3 id="BottleNeck-Residual-Block"><a href="#BottleNeck-Residual-Block" class="headerlink" title="BottleNeck Residual Block"></a>BottleNeck Residual Block</h3><p><img src="/p/cd8f/MobileNetsv2-4.png" style="zoom:80%;"></p><p>如上图中的(b)，瓶颈块操作 $\mathcal{F}(x)$可以表达为三个操作的组合 $\mathcal{F}(x)=[A\circ \mathcal{N} \circ B]x$。在这里，</p><ul><li>$A$ 为线性变换 $A: \mathcal{R}^{s\times s\times k} \rightarrow \mathcal{R}^{s\times s\times n}$.</li><li>$\mathcal{N}$ 为一个非线性的逐通道的变换 $\mathcal{N}: \mathcal{R}^{s\times s\times n} \rightarrow \mathcal{R}^{s^{\prime}\times s^{\prime}\times n}$</li><li>$B$ 又是一个到输出域的线性变换 $B: \mathcal{R}^{s^{\prime}\times s^{\prime}\times n} \rightarrow \mathcal{R}^{s^{\prime}\times s^{\prime}\times k^{\prime}}$.</li></ul><p>在本文的网络中，$\mathcal{N} = $ <strong>ReLU6</strong> $\circ$ <strong>dwise</strong> $\circ$ <strong>ReLU6</strong>，但是结果适用于任何逐通道的变换，假定输入域大小为 $|x|$，输出域大小为 $|y|$，那么计算 $F(X)$的需要的内存将会低至 $|s^2k|+|{s^{\prime}}^2k^{\prime}|+O(\max(s^2,{s^{\prime}}^2))$</p><p>算法基于一个事实，内部张量 $\mathcal{I}$ 可以表示为 $t$ 个张量的连接，每一个大小为 $n/t$，那么函数就可以表示为:</p><script type="math/tex; mode=display">\mathcal{F}(x) = \sum_{i = 1}^t(A_i\circ N \circ B_i)*(x)</script><p>通过累加和，则只需要在所有时刻，只在内存中保存一个大小为 $n / t$ 的中间块。如果 $n = t$，则在所有时刻只需要保留内部表示的一个通道即可。(所以是整体计算变成了滑动计算的意思？)</p><p>可以使用这个技巧的两个约束条件:</p><ul><li>内部变换(包括非线性和深度)是逐通道的</li><li>连续的非逐通道的操作需要输入和输出的比率显著</li></ul><p>对于大多数的传统神经网络，这样的技巧不会产生显著的改进效果。</p><p>使用 $t$ 分割的方式来计算 $F(X)$ 的Multi-adds操作数与 $t$ 独立，但是在现在的一些实现中，使用较小的矩阵来替换乘法会损害运行时，这是因为缓存丢失的增加。这种方法最只用于 $t = 2\sim 5$ 的小常数。它显著降低了内存的需求，但仍然允许使用深度学习框架提供的高度优化的矩阵乘法和卷积算子获得的高效率。框架级别的优化是否可以带来进一步的运行时优化仍待研究。</p>]]></content>
      
      
      <categories>
          
          <category> 轻量化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MobileNets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Devon</title>
      <link href="/p/5a3.html"/>
      <url>/p/5a3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用于学习光流的可形变体网络</p><h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      
      
      <categories>
          
          <category> 光流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双帧光流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SqueezeNet</title>
      <link href="/p/92ec.html"/>
      <url>/p/92ec.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人觉得没啥卵用。。。</p><h2 id="。。。"><a href="#。。。" class="headerlink" title="。。。"></a>。。。</h2><h2 id="SqueezeNet-Preserving-accuracy-with-few-parameters"><a href="#SqueezeNet-Preserving-accuracy-with-few-parameters" class="headerlink" title="SqueezeNet: Preserving accuracy with few parameters"></a>SqueezeNet: Preserving accuracy with few parameters</h2><h3 id="Architectural-Design-Strategies"><a href="#Architectural-Design-Strategies" class="headerlink" title="Architectural Design Strategies"></a>Architectural Design Strategies</h3><p>主要目标是构建参数较少的 CNN 模型架构，但是仍保持不错的精度。为此，使用了三个主要策略。</p><ul><li><p>策略 $1$ : 使用 $1 \times 1$ 过滤器替换 $3 \times 3$ 过滤器。给定一定数量的卷积滤波器预算，这大部分的滤波器将使用 $1\times 1$ 大小，因为 $1\times 1$ 滤波器将比 $3 \times 3$ 滤波器减少了九倍的参数。</p></li><li><p>策略 $2$ : 减少输入到 $3 \times 3$ 滤波器的输入通道数。对于一个只包含 $3\times 3$ 滤波器的卷积层，这一层的参数总数等于</p><p>(number of channels)  * (number of filters) * (3 * 3)。因此，为了保持 CNN 中较少的参数总数，不仅要减少$3\times 3$滤波器的个数，还需要减少输入的通道数。后面使用 squeeze layers 来减少输入到滤波器的输入通道数。</p></li><li><p>策略 $3$ : 在网络的后期进行下采样，使卷积层有较大的激活图。在卷积网络中，每个卷积层产生一个输出激活映射，其空间分辨率至少为 $1\times 1$，并且通常大于 $1 \times 1$。这些激活映射图的宽和高由 (1) 输入数据的大小，(2) 在CNN中选择用哪些层来做下采样。常见的是，通过在 CNN 结构的一些卷积层或者池化层设置步长 (stride &gt; 1)。如果网络前面的层有较大的步长，那么大部分的激活层就会很小。相反地，如果网络中大部分的层的步长为 $1$, 并且步长大于 $1$ 的层都集中在网络末端，那么网络中的大部分层就会有大的激活图。在其他条件不变得情况下，直觉上看，大的激活图将会导致更高的分类精度。</p></li></ul><p>策略$1,2$ 是明智得减少 CNN 中得参数数量，并试图保持准确率。策略 3 是在有限的参数预算下最大化准确性。</p><h3 id="The-Fire-Module"><a href="#The-Fire-Module" class="headerlink" title="The Fire Module"></a>The Fire Module</h3><p>定义 Fire 模块。一个 Fire 模块包含一个 squeeze convolution layer，然后被送到一个 expand layer, 或者扩展层包含了 $1\times1$ 和 $3\times 3$ 两种卷积核。如下图所示。</p><p><img src="/p/92ec/SqueezeNet2.png" style="zoom:50%;"></p><p>在 Fire 模块中提供了三个可调的维度(超参数)： $s_{1x1},e_{1x1},e_{3x3}$。 $s_{1x1}$是 squeeze layer中的 $1\times1$ 滤波器个数，$e_{1x1}$ 是 expand 层中的 $1\times1$ 滤波器个数，$e_{3x3}$ 是 expand 层中的 $3\times3$ 滤波器个数。在使用 Fire 模块时，设定了 $s_{1x1} \lt (e_{1x1},e_{3x3})$， 因此 squeeze layer 将有助于减少输入到 $3\times 3$ 的输入通道数。</p><h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3>]]></content>
      
      
      <categories>
          
          <category> 轻量化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SqueezeNet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MobileNets v1</title>
      <link href="/p/9d20.html"/>
      <url>/p/9d20.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用于移动视觉应用的高效卷积网络</p><p>文献中引用的一些压缩方法，例如 production quantizationm, hashing, pruning, vector quantization 和 huffman coding 感觉值得了解一下(乘积量化，哈希，剪枝，矢量量化，哈夫曼编码)。至于SqueezeNets 等可以单独学习一下。Distillation(蒸馏)啥的也需要学学，还有Low Bit Networks(低比特网络)。啥也不会。。。orz</p><p>此外一些觉得不错的讲解，视频等等:</p><ul><li><a href="https://www.youtube.com/watch?v=kSGhpsme2mo">https://www.youtube.com/watch?v=kSGhpsme2mo</a></li><li><a href="https://yinguobing.com/separable-convolution/">https://yinguobing.com/separable-convolution/</a></li></ul><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一类可以i用于移动和嵌入式视觉应用的高校模型，称为 <strong>MobileNets</strong>。MobileNets基于流线型架构，使用<strong>深度可分离卷积</strong>构建轻量级深度神经网络。引入了两个简单的全局超参数，可以有效的权衡延迟(<strong>latency</strong>)和准确性(<strong>accuracy</strong>)。这些超参数允许模型构建者根据问题的约束条件为他们的应用选择合适的模型尺寸。在 ImageNet 分类上，进行了大量的资源和精度权衡实验，并与其他流行的模型进行对比，模型都表现出了很强的性能。最后，在广泛的应用和示例中演示了 MobileNets 的有效性，包括目标检测，细粒度分类，人脸属性和大规模地理定位。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>自从AlexNet 在 ImageNet 挑战赛(ILSVRC 2012) 上获胜，推广了深度卷积网络以来，卷积神经网络就在计算机视觉中变得无处不在，为了达到更高的精度，整体的趋势就是构建更深的，更复杂的网络。然而，这些提高准确性的改进方法并不一定会在模型规模和运行速度等方面变得高效。在许多现实世界的应用中，例如机器人，自动驾驶汽车，增强现实等，则需要子啊有限计算能力的平台上及时完成识别任务。</p><p>本文描述了一种高效的网络架构和一组两个超参数，以建立规模较小，低延迟的模型，可以很容易的匹配移动和嵌入式视觉应用程序的设计需求。第二节回顾了构建小型模型的前期工作。第三节描述了 MobileNets 架构和两个定义更小和更高效 MobileNets 的超参数：宽度乘法因子( width multiplier )和分辨率乘法因子( resolution multiplier )。第四节描述了在ImageNet 上的实验以及各种不同应用和使用案例。第五节以总结和结论结尾。 </p><h2 id="Prior-Work"><a href="#Prior-Work" class="headerlink" title="Prior Work"></a>Prior Work</h2><p>在最近的工作中，人们开始对构建小型高效神经网络感兴趣。这些不同的方法可以分为 <strong>压缩预训练模型</strong> 和 <strong>直接训练小网络</strong> 两种。本文提出了一类网络架构，它允许模型开发人员为他们的应用程序专门选择符合资源限制(延迟，网络规模)的小型网络。 MobileNets 主要专注于优化延迟，但也产生小型网络。许多关于小型网络的的论文只关于规模但是没有考虑到运行速度。</p><p>MobileNets 主要由深度可分离网络构建，最初在一个博士论文中，后来在 Inception 模型中使用用于减少前几层的计算。Flattened Networks 构建了一个完全分解的卷积网络，展示了极端分解网路的潜力。与本文无关的是，Factorized Networks 引入了一个类似的分解网络以及使用了拓扑连接。随后，在Xception Networks 演示了如何拓展深度可分离过滤器以超越 Inception V3网络。另一个小型网络是 SqueezeNet，它使用了瓶颈方法(bottleneck approach)去设计小型网络。其他简化计算的网络包括 Structured Transform Networks 和 Deep Fried ConvNets。（吓得我都不敢翻译了）</p><p>另一种获取小型网络的方法就是缩小，分解，或者压缩预训练模型。基于 production quantization, hashing, pruning, vector quantization 和 huffman coding 的压缩方法都有文献提及(乘积量化，哈希，剪枝，矢量量化，哈夫曼编码)。此外，还有一些分解方法来加速预训练网络的速度。另一种训练预训练网络的方法是 distillation (蒸馏)，它使用较大的网络来训练较小的网络，是本文方法的补充，在第四节的一些用例中也会涉及。另一种新型的方法是 low bit networks(低比特网络)。</p><h2 id="MobileNet-Architecture"><a href="#MobileNet-Architecture" class="headerlink" title="MobileNet Architecture"></a>MobileNet Architecture</h2><p>首先描述构建 MobileNets 的核心层，这些核心层由深度可分离过滤器组成。然后描述了 MobileNets 的网络结构，并对两种模型进行描述，即使用宽度乘法因子和分辨率乘法因子的缩小超参数的模型。</p><h3 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h3><p>模型基于深度可分离卷积，是一种分解卷积的形式，它将标准的卷积分解为深度卷积和一个 $1\times1$ 的称为点态卷积的卷积。对于 MobileNets， 深度卷积对每个输入通道应用一个滤波器。然后点态卷积会进行一个 $1 \times 1$ 卷积将深度卷积的结果结合起来。一个标准的卷积在一步之内过滤和将输入结合生成一组输出。而深度可分离卷积则将其分为两层，一层用于过滤和一层用于合并。这种分解可以显著减少运算量和模型大小。下图为标准卷积分解为深度卷积和 $1\times1$ 点态卷积的过程。</p><p><img src="/p/9d20/MobileNets2.png" style="zoom:60%;"></p><p>标准的卷积层将一个 $D_F \times D_F \times M$ 的特征图 $F$ 作为输入，并输出一个 $D_F\times D_F \times N$ 的特征图 $G$， 这里的 $D_F$代表特征图的空间宽度和高度，$M, N$ 为通道数，需要注意的是，很显然，这里的$D_F$只是代指，输入和输出的高度和宽度并不可能完全一样，这里只是为了方便分析。</p><p>标准的卷积层用卷积核 $K$ 参数化，大小为 $D_K\times D_K\times M\times N$，这里的$D_K$ 为卷积核的空间维度，假设为方形的卷积核，$M，N$ 分别为输入输出的通道数。</p><p>对于标准的卷积（假定步长为一并含有填充）的输出特征图则可以计算为:</p><script type="math/tex; mode=display">G_{k,l,n}=\sum_{i,j,m}K_{i,j,m,n}\cdot F_{k+i-1,l+j-1,m}</script><p>因此标准的计算代价为：</p><script type="math/tex; mode=display">D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F</script><p>即依赖于输入的卷积核大小，输入输出通道数，输出的特征图大小。</p><p>MobileNets 处理这里的每一项和之间的联系。首先使用深度可分离卷积来打断输出通道数和卷积核大小之间的关系。</p><p>标准的卷积操作在卷积核的基础上对特征进行过滤，并结合特征产生新的表示。滤波和组合步骤可以通过分解卷积分为两个步骤，这种分解叫做深度可分离卷积并且可以后续减少计算代价。</p><p>深度可分离卷积由于两层构成：深度卷积和点态卷积。使用深度卷积对每个输入通道(输入深度)应用一个简单的滤波器。点态卷积，一个简单的$1\times 1$ 卷积，用来创建深度卷积层输出的线性组合。MobileNets 对这两层都使用了batchnorm 和 ReLU非线性激活函数。</p><p>对每一个输入通道（输出通道）使用一个滤波器进行深度卷积可以表达为：</p><script type="math/tex; mode=display">\hat{G}_{k,l,m}=\sum_{i,j}\hat{K}_{i,j,m}\cdot F_{k+i-1,l+j-1,m}</script><p>这里 $\hat{K}$ 为深度卷积核，大小为 $D_K \times D_K \times M$ , $\hat{K}$ 第 $m_{th}$ 个滤波器应用在 $F$ 的 $m_{th}$通道，并产生输出特征图 $\hat{G}$ 的第 $m_{th}$ 个通道。</p><p>深度卷积的计算代价为:</p><script type="math/tex; mode=display">D_K \cdot D_K \cdot M \cdot D_F \cdot D_F</script><p>深度卷积相比标准卷积则非常有效。但是只是对输入的通道进行了滤波，并没有将滤波后的结果结合以产生新的特征。因此需要一个额外的层来计算深度卷积的输出的线性组合，这通过一个 $1 \times 1$ 的卷积来实现以生成新的特征。</p><p>深度可分离卷积的代价为：</p><script type="math/tex; mode=display">D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F</script><p>即深度卷积$1\times1$点态卷积的代价总和。</p><p>通过将卷积表达为两个步骤（滤波和组合）可以得到计算代价的减少：</p><script type="math/tex; mode=display">\begin{align} &\frac{D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F}{D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F} \notag \\ =&\frac{1}{N} + \frac{1}{D_K^2} \notag\end{align}</script><p>MobileNets 使用了$3 \times 3$ 深度可分离卷积比标准卷积减少 8 到 9倍的计算量，并且精确度只有一点点的下降。</p><p>空间维度上的额外分解并没有减少太多的额外计算，因为深度卷积减少了很多的计算量。</p><h3 id="Network-Structure-and-Training"><a href="#Network-Structure-and-Training" class="headerlink" title="Network Structure and Training"></a>Network Structure and Training</h3><p>MobileNets 架构是构建在深度可分离卷积的基础上，除了第一层使用仍是全卷积。通过这样定义网络，可以更容易的探索网络拓扑结构来找到一个好的网络。MobileNets体系结构如下所示。所有层后面都有一个 batchnorm 和 ReLU 非线性激活函数，除了最终的全连接层没有非线性函数以外，全连接需要送入 softmax 层来进行分类。</p><p><img src="/p/9d20/MobileNets3.png" style="zoom:60%;"></p><p>下图对比了标准卷积配有 batchnorm 和 ReLU 非线性激活函数和深度可分离卷积。</p><p><img src="/p/9d20/MobileNets4.png" style="zoom:60%;"></p><p>下采样通过跨步卷积来处理。在全连接层之前，使用均值池化层将空间分辨率降低到1。将深度卷积和点态卷积看成独立的层，MobileNets 则有28层。</p><p>使用少量的 Multi-Adds 定义网络是不够的，还需要保证这些操作可以有效的实现。例如非结构化的稀疏矩阵操作通常并不会比稠密矩阵快，除非达到非常高的稀疏级别。模型结构几乎将所有的计算都放在了稠密的 $1\times 1$ 卷积中，这可以通过GEMM实现。通常卷积是由GEMM实现的，但是需要在内存中进行一个称为 im2col 的操作来将其映射到 GEMM。例如，在Caffe库中，$1\times 1$卷积并不需要预先安排内存而可以直接使用 GEMM实现，这是最优化的数学线性代数算法之一。MobileNets 使用了将近 95% 的时间用于 $1\times1$卷积计算，也有 75% 的参数如下所示。几乎所有的额外参数都在全连接层。</p><p><img src="/p/9d20/MobileNets5.png" style="zoom:60%;"></p><p>MobileNets 模型在 TensorFlow中使用 RMSprop训练，并采用了类似于 Inception V3的异步梯度下降。然而，与训练大型模型相反，模型使用较少的正则化和数据增强技术，因为小模型有较少的过拟合问题。在训练 MobileNets 时，不使用 side head和label smoothing并且限制在 large Inception training 中使用的切割尺寸，来减少图像失真。此外，还发现，在深度滤波器层中需要使用小的甚至没有权重衰减(L2 正则化)，因为他们的参数太少。对于后面的ImageNet基准测试，不管模型的大小，都是用相同的训练参数进行训练。</p><h3 id="WidthMultiplier-Thinner-Models"><a href="#WidthMultiplier-Thinner-Models" class="headerlink" title="WidthMultiplier : Thinner Models"></a>WidthMultiplier : Thinner Models</h3><p>尽管基本的MobileNets 体系结构已经很小，并且延迟很低，但是很多时候一个特定的用例可能会要求模型更小更快。为了构建更小的，计算成本更小的模型，引入了一个简单的参数 $\alpha$，称为宽度乘法因子。宽度乘法因子 $\alpha$ 的作用是让网络的每一层均匀的变小。对于一个给定的层和一个宽度乘法因子 $\alpha$，那么输入的通道数将会变成 $\alpha M$，输出的通道数将会变为 $\alpha N$。</p><p>那么深度可分离卷积的计算代价将会变成：</p><script type="math/tex; mode=display">D_K \cdot D_K \cdot \alpha M \cdot D_F \cdot D_F + \alpha M \cdot \alpha N \cdot D_F \cdot D_F</script><p>这里的 $\alpha \in (0,1]$,通常设置为 1, 0.75, 0.5, 0.25。$\alpha = 1$ 为基线的 MobileNet，$\alpha &lt; 1$ 则为削减的 MobileNet。宽度乘法因子可以近似 $\alpha^2$二次降低计算成本和参数量。宽度乘法因子可以应用于任何模型结构以定义一个新的更小的模型。具有合理的精度，延迟和大小权衡。它可以用于定义新的需要从头训练的简化结构。</p><h3 id="Resolution-Multiplier-Reduced-Representation"><a href="#Resolution-Multiplier-Reduced-Representation" class="headerlink" title="Resolution Multiplier: Reduced Representation"></a>Resolution Multiplier: Reduced Representation</h3><p>第二个用于减少神经网络计算代价的超参数为分辨率乘法因子 $\rho$。将其应用于输入图像上，则每一层的内部表示都会随后以相同的乘法因子缩小。因此，只需要隐式的设置输入分辨率为 $\rho$  即可。</p><p>现在可以将网络的核心层的代价表达为具有宽度乘法因子 $\alpha$ 和分辨率乘法因子 $\rho$ 的深度可分离网络：</p><script type="math/tex; mode=display">D_K \cdot D_K \cdot \alpha M \cdot \rho D_F \cdot \rho D_F + \alpha M \cdot \alpha N \cdot \rho D_F \cdot \rho D_F</script><p>这里 $\rho\in (0,1]$。通常隐式设置以使得网络的输入分辨率为 224, 192, 160, 128。$\rho = 1$ 为基线的 MobileNet。$\rho &lt; 1$ 为削减的 MobileNet。分辨率乘法因子将可以使计算代价以 $\rho^2$ 减少。</p><p><img src="/p/9d20/MobileNets6.png" style="zoom:60%;"></p><p>上表显示了结构收缩方法依次应用各个层后的计算量和参数量。输入特征图大小为 $14\times 14 \times 512$, 核大小为 $3 \times 3 \times 512 \times 512$。</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>首先说明深度卷积的效果，以及通过减少网络宽度而不是层的数量来进行网路压缩。然后展示了基于两个超参数：宽度乘法因子和分辨率乘法因子削减网络的权衡，然后研究了应用于不同应用程序的从MobileNets。</p><h3 id="Model-Choices"><a href="#Model-Choices" class="headerlink" title="Model Choices"></a>Model Choices</h3><p>首先展示了带有深度卷积网络的模型和使用完全卷积的模型的对比结果。如下表，可以看出，使用深度可分离卷积相比使用完全卷积只会在 ImageNet 上减少 1%的精确度，但是会极大的减少 Multi-adds 和参数。 </p><p><img src="/p/9d20/MobileNets7.png" style="zoom:60%;"></p><p>然后展示带有 宽度乘法因子的 thinner 模型与层数较少的浅模型的对比。为了使 MobileNets 模型更浅，Table1.中的五层独立滤波器(大小为$14 \times 14 \times 512$)被移除。下表展示了在相似的计算量和参数数量下，使MobileNets 更thinner比使其更浅的性能好 3%。</p><p>后面的具体实验结果建议直接看论文的图表。</p>]]></content>
      
      
      <categories>
          
          <category> 轻量化模型 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MobileNets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FastFlowNet</title>
      <link href="/p/a2c4.html"/>
      <url>/p/a2c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>代码开源了个寂寞，不过无所谓，只是看看他做了什么而已。<a href="https://github.com/ltkong218/FastFlowNet">官方链接</a></p><p>非常 amazing 的地方在于 FastFlowNet 只包含 1.37M 的参数，并且 fps 很不错。</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>FastFlowNet 仍然使用了广泛应用的 coarse-to-fine 策略，此外还有以下几个创新点。</p><ul><li><p>使用了一个 head enhanced pooling pyramid (HEPP) 特征提取器，在减少参数的同时增强了高分辨率的金字塔特征。</p></li><li><p>引入了一个 center dense dilated correlation (CDDC)层 用于构建紧凑的代价体，并且可以保持较大的搜索半径下减少计算量。</p></li><li><p>在每个金字塔层中植入了一个有效的 shuffle block decoder (SBD) 用于加速光流估计，不过边缘精度有所下降。但是相比同样精度的网络，只需要 $1/10$ 的计算量。</p></li></ul><p>FastFlowNet 只含有1.37M 个参数，对于一个分辨率为 $1024\times436$ 的Sintel图片，在单个 GTX 1080Ti 下可以做到 90 FPS，嵌入JetSon TX2 GPU 可以做到 5.7 FPS。</p><h2 id="INTRODUCTION-amp-amp-RELATED-WORK"><a href="#INTRODUCTION-amp-amp-RELATED-WORK" class="headerlink" title="INTRODUCTION&amp;&amp; RELATED WORK"></a>INTRODUCTION&amp;&amp; RELATED WORK</h2><p>这部分说的很牛逼，后面写论文可以参考。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="OverView-of-the-Approach"><a href="#OverView-of-the-Approach" class="headerlink" title="OverView of the Approach"></a>OverView of the Approach</h3><p><img src="/p/a2c4/FastFlowNet1.png" style="zoom:80%;"></p><p>给定两个时间域相邻的输入图片$I_1,I_2 \in \mathbb{R}^{H \times W \times 3}$, 提出的 FastFlowNet 模型将会利用由粗到细的残差结构来逐渐估计精化后的光流 $F^{l} \in \mathbb{R}^{H^l \times W^l \times 2}, l = 6,5,\cdots,2.$ 但是通过修改去减少参数和计算代价来加速推理。为此，首先替换了 PWC-Net 网络中的对偶卷积特征金字塔为 头增强的池化金字塔 (head enhanced pooling pyramid) 来增强高精度分辨率的金字塔特征和减少模型的尺寸。在此基础上，提出了一种新得中心密集扩张相关层(center dense dilated correlation layer)，在保证大的搜索半径得前提下，构造紧凑得代价体。最后，在每个金字塔层使用新的shuffle 块译码器 (shuffle block decoders) 来回归计算光流。模型的结构细节如下所示。</p><p><img src="/p/a2c4/FastFlowNet2.png" style="zoom:60%;"></p><p>Pool: average pooling</p><p>Fconv5_2, Fconv5_3, Fconv5_4: convolutions with group = 3</p><p>Shuffle: channel shuffle operation</p><p>除了 upconv6 和 fconv5_7 的卷积层都后接 LeakyRELU 激活函数</p><h3 id="Head-Enhanced-Pooling-Pyramid"><a href="#Head-Enhanced-Pooling-Pyramid" class="headerlink" title="Head Enhanced Pooling Pyramid"></a>Head Enhanced Pooling Pyramid</h3><p>传统的方法在光流估计上应用图像金字塔来加速优化和处理大尺度位移。SpyNet 转换这种经典的范式并首次引进了基于图像金字塔的池化用于加深模型。因为原始图像对光影变换时敏感的，因此固定的池化金字塔对噪声，例如阴影和反射等是不足的。PWC-Net， LiteFlowNet,使用可学习的特征金字塔替代图像金字塔，带来了很大的改进。具体地说，在减少空间尺寸的同时逐步扩张特征通道数来提取鲁棒的匹配特征。</p><p>低分辨率下的较大的通道数会导致大量的参数，对于由粗到细的方案来说可能是冗余的，因为低层的金字塔特征可能只会对估计粗糙的流域有用。因此，模型结合了高层的特征金字塔结构和低层的池化金字塔兼顾两个优势。另一方面，高分辨率下的金字塔特征在PWC-Net中相比较浅，因为每个金字塔层只包含两个卷积核大小为 $3 \times 3$ 的卷积层，因此其感受野较小。因此模型花费了一点额外代价在高层添加了一个额外的卷积层来增强金字塔特征。通过平衡不同尺度下的计算，文章提出了HEPP，和 FlowNetC, PWC-Net 和 LiteFlowNet 一样， HEPP会生成 6个金字塔层从 $1/2$ 分辨率(第一层) 到 $1/64$ 分辨率(第六层)，缩放因子为 2。</p><h3 id="Center-Dense-Dilated-Correlation"><a href="#Center-Dense-Dilated-Correlation" class="headerlink" title="Center Dense Dilated Correlation"></a>Center Dense Dilated Correlation</h3><p>现代的光流估计架构中的一个重要的步骤就是通过基于卷积层的内积来计算特征一致性。对于金字塔 $l$ 层的两个特征 $f^l_1, f^l_2$ ，类似很多由粗到细的残差方法，首先使用了基于 warping 的双线性插值，根据 $2\times$前面的流场的上采样的结果 $up_2(F^{l+1})$ 对第二个特征 $f^l_2$ 进行 warp。warp 的目标特征 $f_{warp}^l$ 可以极大的减少由于大尺度运动带来的位移，这将有益于减少搜索区域和简化任务为估计相对较小的残差流。最近的工作 PWC-Net，LiteFlowNet 通过在局部方形区域内相关源特征和对应的warped后的目标特征构建代价体，可公式化为：</p><script type="math/tex; mode=display">c^l(x,d)=f^l_1(x)\cdot f_{warp}^l(x+d)/N, d\in [-r, r] \times[-r, r]</script><p>$x, d$ 代表空间和偏移坐标，$N$ 为输入特征的长度，$r$ 为搜索半径，$\cdot$ 代表点积。</p><p>已有的工作PWC-Net等已经表明，在构建代价体时增加搜索半径可以在训练和测试中降低 EPE 误差，尤其对于大位移的情况。但是代价体的特征通道时搜索半径的平方级，后续的解码器网络的计算复杂度将会变成四次方。</p><p><img src="/p/a2c4/FastFlowNet3.png" style="zoom:60%;"></p><p>如图 $a$，很多的光流网络设置 $r = 4$，庞大的计算量阻碍了低功耗应用的发展。一种简单的方法就是减小半径  $r$。例如设置 $r = 3$， 如图 $b$。从而使代价体特征从 81 减少到 49. 但是这种办法的代价是牺牲了感知范围和精度。</p><p>受到 DeepLabv3 的 atrous spatial pyramid pooling(ASPP) 的启发，提出了CDDC层在大运动区域内下采样网格点时，在中心周围密集搜索格点，如图 $c$ 所示。</p><p>与 ASPP 使用并行 atrous 卷积来获取多尺度上下文信息不同，提出的 CDDC 旨在减少构建大半径代价体时的计算量。在 FastFlowNet 中，会输出 53 个特征通道，与传统的 $r=3$ 设置类似。动机在于残差流会更关注小运动。实验证明 CDDC 方法比传统的压缩方法更优。</p><h3 id="Shuffle-Block-Decoder"><a href="#Shuffle-Block-Decoder" class="headerlink" title="Shuffle Block Decoder"></a>Shuffle Block Decoder</h3><p>在构建代价体后，由粗到细的模型通常会将上下文特征，代价体量和上采样的前一个光流结果 concatenate起来，作为后面解码器的输入。在每一个金字塔层，解码器会占用整个网络的大部分参数和计算量。因此，更好的速度和精度的权衡时至关重要的。</p><p>PWC-Net表明，稠密连接的流解码器在对 FlyingThing3D 数据集进行微调后，可以提高解码器的精度，但代价是增加了模型大小和计算量。LiteFlowNet 使用了顺序连接的流估计器，并且显示出了更好的性能。为了达到两种方案的权衡，FDFlowNet使用了部分全连接结构。这些方法都不能在嵌入式系统中进行实时的推理。</p><p>由于 CDDC 构建的紧致代价体，可以直接将解码器网络的最大通道数从 128 减少到 96个。为了进一步减少计算量和模型的大小，将中间的三个96通道的卷积转换为组卷积，然后进行通道 shuffle 操作，称之为 Shuffle Block。与ShuffleNet 作为骨干网络不同的是，shuffle 译码器用于光流的回归。</p><p>每个解码器网络包含了三个 $group = 3$ 的 shuffle 块，这有效的减少了计算量，但是精度略有下降。</p><h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>由于 FastFlowNet 采用了 和 FlowNet 和 PWC-Net 相同的金字塔结构，因此采用了同样的多尺度 $L2$ 损失函数用于训练。</p><script type="math/tex; mode=display">L_{epe}=\sum_{l = 2}^6\alpha_l\sum|F^l(x)-F^l_{gt}(x)|_2</script><p>这里 $|\cdot|_2$ 计算预测光流和真实光流之间的 $L2$ 范数。</p><p>在有真实场景结构的数据集上进行微调时，例如 KITTI 数据集，使用了如下的鲁棒损失函数:</p><script type="math/tex; mode=display">L_{robust}=\sum_{l=2}^6\alpha_l\sum(|F^l(x)-F^l_{gt}(x)|+\epsilon)^q</script><p>这里的 $|\cdot|$ 表示 $L1$ 范数，$\epsilon = 0.01$ 表示一个很小的常数，$q \lt 1$ 使的对大的异常值更加鲁棒。为了与以前的方法(FlowNet, SPyNet, PWC-Net, LiteFlowNet)公平对比，将公式(2)(3)中的权重设置为$\alpha_6=0.32,\alpha_5=0.08,\alpha_4=0.02,\alpha_3=0.01,\alpha_2=0.005$.</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Implements-Details"><a href="#Implements-Details" class="headerlink" title="Implements Details"></a>Implements Details</h3><p>为了将 FastFlowNet与其他网络进行对比，遵循了 FlowNet2 中提出的两阶段训练策略。真实的光流值除以20，并且下采样作为不同层的监督信号。由于最终的预测的分辨率为 $1/4$ ,因此使用了双线性插值来获得全分辨率的光流。在训练和调试阶段，使用了和 FlowNet 同样的数据增强方式，包括镜像翻转，平移，旋转，缩放，挤压和颜色抖动。实验在PyTorch环境下实现，并且在装有 4 张 Nvidia GTX 1080 Ti GPU卡的机器上进行。为了比较不同的光流模型在移动设备上的性能，进一步在嵌入式的Jetson TX2 GPU上测试了推理时间。</p><p>首先在 FlyingChairs 数据集上训练，使用 $S_{short}$ 学习计划。初始学习率为 $1e^{-4}$，并在30w, 40w, 50w次迭代的时候衰减一半。在数据增强阶段随机裁剪出 $320 \times 448$ 的 patch，并采用 $batch-size = 8$ 。模型在 FlyingThings3D 数据集上进行微调，并采用 $S_{fine}$ 学习计划。学习率初始化为 $1e^{-5}$, 并且在 20w, 30w, 40w迭代的时候衰减一半。随机切割尺寸为 $384 \times 768$，并且 $batch-size = 4$。 使用 $Adam$ 优化器和多尺度的 $L2$ 损失函数。在 Sintel 和 KIITI 的训练集结果如下所示。</p><p><img src="/p/a2c4/FastFlowNet4.png" style="zoom:60%;"></p><h3 id="Ablation-study"><a href="#Ablation-study" class="headerlink" title="Ablation study"></a>Ablation study</h3><p>暂时略，需要时再补充</p><h3 id="MPI-Sintel"><a href="#MPI-Sintel" class="headerlink" title="MPI Sintel"></a>MPI Sintel</h3>]]></content>
      
      
      <categories>
          
          <category> 光流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双帧光流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing345-牛站</title>
      <link href="/p/ccd6.html"/>
      <url>/p/ccd6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="345-牛站"><a href="#345-牛站" class="headerlink" title="345.牛站"></a><a href="https://www.acwing.com/problem/content/347/">345.牛站</a></h2><p><img src="/p/ccd6/AcWing-345-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>变种Flyod+快速幂思想（倍增），还需要提前做离散化。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> res[N][N];</span><br><span class="line"><span class="keyword">int</span> k, n, m, s, e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[][N], <span class="keyword">int</span> a[][N], <span class="keyword">int</span> b[][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(temp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k] + b[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c, temp, <span class="built_in"><span class="keyword">sizeof</span></span>(temp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qmi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res[i][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, g);</span><br><span class="line">        <span class="built_in">mul</span>(g, g, g);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; m &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s)) mp[s] = ++n;</span><br><span class="line">    <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(e)) mp[e] = ++n;</span><br><span class="line">    s = mp[s], e = mp[e];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(a)) mp[a] = ++n;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(b)) mp[b] = ++n;</span><br><span class="line">        a = mp[a], b = mp[b];</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qmi</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res[s][e] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 快速幂 </tag>
            
            <tag> 离散化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing1133-第二短路</title>
      <link href="/p/1ed1.html"/>
      <url>/p/1ed1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1133-第二短路"><a href="#1133-第二短路" class="headerlink" title="1133. 第二短路"></a><a href="https://www.acwing.com/problem/content/description/1135/">1133. 第二短路</a></h2><p><img src="/p/1ed1/AcWing-1133-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 求最短路的过程中维护次短路，需要注意 “严格” 的问题。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, type, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; node.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> v = p.v, type = p.type, dis = p.dis;</span><br><span class="line">        <span class="keyword">if</span>(st[v][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[v][type] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[v]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j][<span class="number">0</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = dis + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] &gt; dis + w[i] &amp;&amp; dist[j][<span class="number">0</span>] &lt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dis + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing383-观光</title>
      <link href="/p/ef51.html"/>
      <url>/p/ef51.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="383-观光"><a href="#383-观光" class="headerlink" title="383. 观光"></a><a href="https://www.acwing.com/problem/content/385/">383. 观光</a></h2><p><img src="/p/ef51/AcWing-383-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>仿照第二短路的解法而已，额外添加了计数功能而已，代码很好理解。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ver, type, dist;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> node&amp; nod) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; nod.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> t, n, m, S, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    </span><br><span class="line">    dist[S][<span class="number">0</span>] = <span class="number">0</span>, cnt[S][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        node tt = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> ver = tt.ver, type = tt.type, dis = tt.dist;</span><br><span class="line">        <span class="keyword">int</span> count = cnt[ver][type];</span><br><span class="line">        <span class="keyword">if</span>(st[ver][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver][type] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j][<span class="number">0</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>], cnt[j][<span class="number">1</span>] = cnt[j][<span class="number">0</span>];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = dis + w[i], cnt[j][<span class="number">0</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">0</span>] == dis + w[i]) cnt[j][<span class="number">0</span>] += count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dis + w[i], cnt[j][<span class="number">1</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] == dis + w[i]) cnt[j][<span class="number">1</span>] += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = cnt[T][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(dist[T][<span class="number">0</span>] + <span class="number">1</span> == dist[T][<span class="number">1</span>]) res += cnt[T][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SCV</title>
      <link href="/p/1f41.html"/>
      <url>/p/1f41.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/zacjiang/scv">代码已开源</a></p><p>RAFT outperforms other approaches by first calculating all-pairs similarity and then performing iterations at a high resolution.The price is that it inurs significantly larger computation burden.(FastFlowNet)</p><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>SOTA的光流估计网络需要高分辨率下的稠密的Correlation Volume来衡量逐像素的位移，虽然稠密的Correlation Volume有助于准确的光流估计，但是繁重的计算和内存使用也不利于模型的训练和部署。这篇论文说明了稠密的Correlation Volume表示是冗余的，只需要其中的一小部分元素就可以实现精确的光流估计。在此基础上，论文提出了一个可以替代的位移表示方法—Sparse Correlation Volume，通过直接计算fmap1在fmap2上最接近的k个匹配来构建，并存储在一个稀疏的数据结构中。实验说明了该方法可以显著降低计算成本和内存占用，并且依然保持较高的精度。</p><h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>基于直觉：img1的某一个特征向量只会与img2的某一部分特征向量高度相关，因此在稠密的Correlation Volume表示中，会有大量的冗余，对于相关度较小的特征并不会优化预测结果。如下图所示。</p><p><img src="/p/1f41/SCV1.png" style="zoom:60%;"></p><p>论文提出了Sparse Correlation Volume 表示，只有每个像素的top-k的相关值会被存储在稀疏数据结构中，就是个键值对—（{value, coordinates}）。</p><h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>记 $I_1, I_2: \mathbb{Z}^2 \rightarrow \mathbb{R}^3$ 为两张RGB图像，待解决的问题就是估计稠密的流场 $f:\mathbb{Z}^2\rightarrow\mathbb{R}^2$，映射每个像素x到其位移向量$f(x)$。</p><p>现在的深度学习光流估计方法，首先会对图像对进行特征提取得到图像的feature map $F_1,F_2:\mathbb{Z}^2\rightarrow\mathbb{R}^c$，这里的 $c$ 为通道数，Correlation Volume $C : \mathbb{Z}^4 \rightarrow R$ 由特征向量直接的点积得到。</p><script type="math/tex; mode=display">C(x,d)=F_1(x)\cdot F_2(x + d).</script><p>输出为一个四维的张量，可以表示为集合:</p><script type="math/tex; mode=display">\mathcal{C}=\{C(x,d)|x\in \mathcal{X}, d \in \mathcal{D}\}.</script><p>这里， $\mathcal{X} = [0, h<br>) \times[0, w) \cap \mathbb{Z}^2$ 为 feature map $F_1$ 的域， $|\mathcal{X}| = hw$ ，其中的 $h$, $w$ 分别为 $F_1$的 $height$ 和 $width$。$d$ 为 $x$ 方向或者 $y$  方向上的最大位移量，并且有 $|\mathcal{D}| = (2d+1)^2$，因此，Correlation Volume $\mathcal{C}$ 中含有 $hw(2d+1)^2$的元素。</p><p>为了降低Correlation Volume的尺寸，以前的方法使用了由粗到细的策略，然后对有限的d进行warping操作，为了精确处理大位移的问题，RAFT构建了全局的Correlation Volume，当然，位移的范围d受到feature map的大小限制。RAFT的Correlation Volume包含了 $N^2$ 的元素，这里的 $N = hw$。论文中将空间复杂度从 $O(N^2)$  降低到了 $O(Nk)$，具体 如下图所示。</p><p><img src="/p/1f41/SCV2.png" style="zoom:60%;"></p><h3 id="Sparse-Correlation-Volume"><a href="#Sparse-Correlation-Volume" class="headerlink" title="Sparse Correlation Volume"></a>Sparse Correlation Volume</h3><p>对于 $x\in \mathcal{X}$, 定义集合 $S_x^{(k)}$包含 $k$个产生最大相关值的位移:</p><script type="math/tex; mode=display">S_x^{(k)} = {\arg \max}_{S \subset \mathcal{D},|S|=k}\sum_{d\in S}C(x,d)</script><p>则Correlation Volume可以表示为一个四维的稀疏张量:</p><script type="math/tex; mode=display">\tilde{\mathcal{C}}=\{C(x,d)|d \in S_x^{(k)},x \in \symcal{X}\}.</script><p>这样的稀疏Correlation Volume则只包含 $hwk$ 个元素，而原来的则包含 $h^2w^2$ 个元素， 常数 $k$ 通常为一个比较小的数，例如8。网络结构如下所示。</p><p><img src="/p/1f41/SCV3.png" style="zoom:60%;"></p><h3 id="k-Nearest-Neighbours"><a href="#k-Nearest-Neighbours" class="headerlink" title="k-Nearest Neighbours"></a>k-Nearest Neighbours</h3><p>使用了两个共享权重的提取网络从输入的图像中获取 1/4 分辨率的特征图。特征提取网络包含了 6 个 residual blocks，特征通道数为 256。为了构建稀疏Correlation Volume，使用了一个 KNN 模块(论文中有参考文献)去计算对于 $F_1$的每个特征向量的最大的 $k$ 个相关得分的索引集合。稀疏Correlation Volume通过 $F_1$ 的每个特征向量与 $F_2$ 由索引得到的前 $k$ 个特征向量的点积。在back-propagation阶段，梯度也仅会传到由 KNN 模块选择到的 k 个特征向量。</p><h3 id="Displacements-Updates"><a href="#Displacements-Updates" class="headerlink" title="Displacements Updates"></a>Displacements Updates</h3><p>采用了全局的迭代精化方法，估计残差流可以有效的减少搜索空间并且可以比直接回归预测到更好的结果。与直接预测光流场 $f$ 不同，残差流 $\Delta f_{i+ 1}$ 是每一步预测并且用来更新当前的光流估计结果 $f_{i + 1} = f_i + \Delta f_{i + 1}$。</p><p>在每一步，对于 $F_1$ 的一个像素 $x$，将会根据当前的光流预计结果映射到 $F_2$ 中的 $x_i = x + f_i$。稀疏Correlation Volume可以看成初始光流$f_0 = 0(i = 0)$。当坐标$x_i$更新到$x_{i+1}=x_i+\Delta f_i$， $\tilde{\mathcal{C}}$中对应的位移也会同样更新。可以通过在每一步中从 $d_i$ 中减去 k 最近的 $\Delta f_i$ 来shift稀疏Correlation Volume张量的坐标，$C_i(x,d_i)=C_{i+1}(x,d_i - \Delta f_i)$。  如下图所示。并且设定为$d_i-\Delta f_i$为浮点值。需要注意的是，内积只会在最开始的时候计算一次，因为在每一步中，只有相关坐标发生变化，相关值不会发生变化。</p><p><img src="/p/1f41/SCV4.png" style="zoom:60%;"></p><h3 id="Multi-scale-Displacement-Encoder"><a href="#Multi-scale-Displacement-Encoder" class="headerlink" title="Multi-scale Displacement Encoder"></a>Multi-scale Displacement Encoder</h3><p>在多个分辨率下以固定的半径创建多尺度的稀疏张量和采样位移，粗糙的分辨率将会提供更大的文本背景，而精细的分辨率则可以提供更精确的位移。然后将每一个 level 的稀疏张量转换为稠密张量并 concatenate 形成一个 2D 张量.如下图所示。</p><p><img src="/p/1f41/SCV5.png" style="zoom:60%;"></p><p>在每一次迭代时，对于每个像素 $x$，从 $top-k$ 个相关位置$S_x^{(k)}$ 开始 ，因此集合 $\{(d,C(<br>x,d)|d\in S_x^{(k)}\}$ 记录了对于 $X$的 $top - k$ 个相关值及其位置，这通过 $kNN$ 算法得到。</p><p>构建了一个5层的稀疏Correlation Volume金字塔通过以（1，2，4，8，16）除坐标(意思就多分辨率的图像？)，并且表示在level l 的 比例化位移，通过当前的流 $\Delta f_i$ 更新的结果为 $d^l=(d_i-\Delta f_i)/2^{l-1}$。</p><p>此外，在level l的相关值表示为 $C^{l}(x,d^l)=C(x,d)$ 对于 $d\in S_x^{(k)}$。在每一个level，通过常数半径 $r$ 限制了位移范围，并且定义level l的窗口相关值集合为:</p><script type="math/tex; mode=display">\{(d^l,C^l(x,d^l)) \mid ||d^l||_{\infty} \leq r, d\in S_x^{(k)}\}.</script><p>因为坐标 $d^l$ 不一定是整数，所以需要重采样到整数坐标以稠密化 correlations的稀疏张量。文中提出了一种叫做”bilinear splatting“的方法，相关值将会被 bilinear splat到四个最近的整数网格中。例如， 在位置 $d^l$ 的相关值 $C^l(x,d^l)$将会被传递到四个邻近整数点的每一个，用 $[d^l]=(d_x,d_y)$ 表示，根据下式:</p><script type="math/tex; mode=display">C^l(x,[d^l])=(1-|d_x^l-d_x|)(1-|d_y^l-d_y|)C^l(x,d^l)</script><p>这些值将会累加对于(5)中的集合，每一个 level 的稀疏张量也会传换成稠密张量，reshaped 并 concatenate 成一个 2D 稠密张量维度为 $5(2r + 1)^2$，这里 5 为金字塔的层数。 </p><p>这个方法不含可学习参数，仅仅是稠密到稀疏张量的转换，并且比稀疏卷积容易。</p><h3 id="GRU-Update-Block"><a href="#GRU-Update-Block" class="headerlink" title="GRU Update Block"></a>GRU Update Block</h3><p>concatenate 2D 运动张量，上下文特征和当前的光流估计结果，并将结果传到GRU单元中，GRU单元将会不断更新估计残差流 $\Delta f_{i+1}$，这个将会在下一步中用来 shift Correlation Volume的坐标。</p><h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h3><h4 id="Network-details"><a href="#Network-details" class="headerlink" title="Network details"></a>Network details</h4><p>首先提取 1/4 分辨率的256通道的特征图，特征提取网络包含了 6 个residual blocks。当特征图传到 $kNN$ 时，设定了 $k = 8$。也就是说，对于每个特征向量，将会返回可以得到最大内积的 $top-8$ 个特征向量的坐标。GRU 单元将当前的光流估计和上下文特性图作为输入，上下文特征图由128通道的独立网络获取。GRU 单元将会更新128维度的隐藏层特征向量。在训练阶段，GRU 将会迭代8次（RAFT 迭代12次）。</p><h4 id="Training-schedule"><a href="#Training-schedule" class="headerlink" title="Training schedule"></a>Training schedule</h4><p>(1, 2) pre-train</p><p>(3, 4, 5) fine-tune</p><div class="table-container"><table><thead><tr><th style="text-align:center">次序</th><th style="text-align:center">数据集</th><th style="text-align:center">batch-size</th><th style="text-align:center">迭代次数</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">FlyingChairs</td><td style="text-align:center">6</td><td style="text-align:center">120k</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">FlyingThings</td><td style="text-align:center">4</td><td style="text-align:center">120k</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">Sintel</td><td style="text-align:center">4</td><td style="text-align:center">120k</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">KITTI</td><td style="text-align:center">4</td><td style="text-align:center">50k</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">HD1K</td><td style="text-align:center">4</td><td style="text-align:center">50k</td></tr></tbody></table></div><p>Training: 2 $\times$ 2080Ti GPU</p><p>Ablation experiment: 1 $\times$ Tesla P100 GPU</p><h4 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h4><p>与 RAFT 一样，使用了循环网络结构预测一系列的残差流 $\Delta f_i$, 每一个阶段的光流预测结果可以表示为 $f_{i+1}=f_i+\Delta f_{i+ 1}$，初始值 $f_0 = 0, \Delta f_0 = 0$。</p><p>损失函数针对于光流预测的序列结果，对于给定的真值光流 $f_{gt}$，对于每一阶段的预测结果 $f_i$,损失函数定义为:</p><script type="math/tex; mode=display">L = \sum_{i = 1}^N\gamma^{N - i}||f_i-f_{gt}||_1</script><p>权重因子: $\gamma = 0.8$（pre-train on Flyingchairs + FlyingThings), $\gamma = 0.85$ (fine-tune on Sintel and KITTI)</p><p>总阶段数: $N = 8$</p><h4 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h4><p>使用了 <strong>faiss</strong> 库在 GPU 上跑 $kNN$，具体参考论文以及对应的参考文献。非常的amazing。</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>定量分析结果如下表所示。</p><p><img src="/p/1f41/SCV6.png" style="zoom:60%;"></p><p>Sintel Clean数据集从RAFT的 1.94 改进到了 1.72 。同时测试了RAFT的 warm-start 策略（用前一帧的光流估计结果初始化当前的光流估计结果）。这个策略没有改进本文的模型，仍然落后于RAFT(warm-start)。在 Sintel 数据集上，模型和 SOTA 相差不大，只比 RAFT 和 DICL 差了一点。同时测试了预训练模型 (C+T) 在 Sintel 和 KITTI-15 上性能，在Sintel Clean 达到了最好的性能，在 Sintel final 和 KITTI-15 上仅次于RAFT。</p><p>在 Sintel Clean 数据上的改进可以归功于较大的 Correlation Volume(1/4 分辨率 vs 1/8 分辨率)。量化结果如下图所示,很好的说明了在高分辨率下构建 Correlation Volume 和 进行光流预测的优势。 </p><p><img src="/p/1f41/SCV7.png" style="zoom:60%;"></p><p>在Sintel Final 和 KITTI-15 数据上，存在比较大的运动模糊和特征缺失区域，因此 $k= 8$ 与稠密 Correlation Volume 相比就显得很小而不能达到同样的效果。后面的消融实验中也对 $k$ 做了分析。但是可以说明，尽管在所有的数据集上没有超过RAFT, 但是可以说明稀疏的方法，尽管只有很少的相关值，仍然可以得到不错的效果。对于每个像素，只需要存储 $k = 8$ 个相关值，但是 RAFT 却需要存储 $h\times w$ 个相关值，限制了向更高分辨率 scale 的能力。</p><h3 id="Ablation"><a href="#Ablation" class="headerlink" title="Ablation"></a>Ablation</h3><p>消融实验仍然是为了说明 $top-k$ 个相关值对于 full correlation volume来说是足够的。在 $1/8$ 分辨率下，更大的 $k$ 可以带来更好的结果，即便 $k = 1$ 与不会彻底失败。</p><p>同时比较了 $1/4$ 分辨率和 $1/8$ 分辨率，可以看出 $1/4$ 分辨可以达到更好效果，除了在 KITTI-15的 EPE 指标上。</p><p>同时对 RAFT 的原生实现进行了实验，保留了 Correlation Volume 中的前 $k$ 个，而对其他的设为 0，依次修改 $k = \{1,8,32,128\}$。在表中，RELU 代表设置负值为0，只保留相关值中的正值。同时训练了原始代码，用 Dense 标记。可以看出更大的 $k$ 可以得到更好的结果，$k = \{32,128\}$可以达到与 Dense 相近的结果。这验证了文章的假设，稠密的 Correlation Volume 会有很大的冗余，有一个较大的 $k$ 值的稀疏 Correlation Volume同样可以达到很好的效果。</p><p>具体结果在 <strong>Results</strong>的表中。</p><h3 id="Memory-Consumption"><a href="#Memory-Consumption" class="headerlink" title="Memory Consumption"></a>Memory Consumption</h3><p>稀疏 Correlation Volume 并不会引进新的学习参数，因此参数个数和 RAFT 是一样的。对于输入图片为 $436 \times 1024$ 大小的图片，在分辨率为 $1/4$ 和 $1/8$ 下的稀疏 Correlation Volume 的尺寸和大小如下表所示。</p><p><img src="/p/1f41/SCV8.png" style="zoom:60%;"></p><p>从 $1/8$ 分辨率下的特征图构建 Correlation Volume并不会带来内存的显著节省，这是因为 $kNN$ 库的常数 2GB消耗，Correlation Volume的内存消耗并不是瓶颈问题。</p><p>但是从 $1/4$ 分辨率下构建可以看出很清晰的优势，对原图片进行 $400\times 720$ 的随机切割，并且 $batch-size =1,2$ 可以看出该方法与 RAFT 相比可以将近 50% 的内存。</p><p><img src="/p/1f41/SCV9.png" style="zoom:60%;"></p><h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>简单的说就是，对于fine-strcture 的运动可以看出很大的改进，但是由于 EPE指标是考虑全局的，这是面向大区域的大尺度运动的偏差。这个方法的劣势在于对特征缺失或者模糊的区域。这些区域的特征因为模糊就需要很多的匹配，但是 $top-k$ 可能就不够充分去包含正确的匹配，并且会给出不正确的运动预测结果。一个失败的例子如下图所示。</p><p><img src="/p/1f41/SCV10.png" style="zoom:60%;"></p><h2 id="Related-Work-amp-amp-Conclusion"><a href="#Related-Work-amp-amp-Conclusion" class="headerlink" title="Related Work &amp;&amp; Conclusion"></a>Related Work &amp;&amp; Conclusion</h2><p>不做赘述.</p>]]></content>
      
      
      <categories>
          
          <category> 光流 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双帧光流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-1334</title>
      <link href="/p/9c7.html"/>
      <url>/p/9c7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1334-阈值距离内邻居最少的城市"><a href="#1334-阈值距离内邻居最少的城市" class="headerlink" title="1334. 阈值距离内邻居最少的城市"></a><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></h2><p><img src="/p/9c7/LeetCode-1334-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>Flyod</strong> 求所有点对之间的最短路，然后 $O(n^2)$ 暴力求解每个点的情况，与全局的 <strong>minCount</strong>对比并更新结果即可。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheCity</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            dp[a][b] = dp[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx, mincnt = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; dp[i][j] &lt;= distanceThreshold)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mincnt)&#123;</span><br><span class="line">                mincnt = cnt;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-882</title>
      <link href="/p/f53f.html"/>
      <url>/p/f53f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="882-细分图中的可到达结点"><a href="#882-细分图中的可到达结点" class="headerlink" title="882. 细分图中的可到达结点"></a><a href="https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph/">882. 细分图中的可到达结点</a></h2><p><img src="/p/f53f/LeetCode-882-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 求最短路, 可以分出 c 个点，等价于两点之间的路径长为 c + 1</p><p>求出最短路后，对每一条边进行遍历，则 $a \rightarrow b$中除了端点 $a$ 还可以遍历到 $min(c, maxMoves - dist[a])$ 个点(如果 $dist[a] &lt; maxMoves$)，记为 $x$ , 而 $b\rightarrow a$除了端点 $b$ 还可以遍历到 $min(c, maxMoves - dist[b])$ 个点(如果 $dist[b] &lt; maxMoves$), 记为 $y$，则 无向边 $a \leftrightarrow b$，除了端点外还可以访问到 $min(x + y, c)$ 个点，对于原始的 $n$ 个顶点，若 $dist[j] \leq maxMove$，则 $j$ 可以访问到。累加所有即可。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; w;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; st;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reachableNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> maxMoves, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        w.<span class="built_in">resize</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        dist.<span class="built_in">resize</span>(n, inf);</span><br><span class="line">        st.<span class="built_in">resize</span>(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            w[a][b] = w[b][a] = c + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                    t =j;</span><br><span class="line">            &#125;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + w[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += (dist[i] &lt;= maxMoves);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[a] &lt; maxMoves) t += <span class="built_in">min</span>(c, maxMoves - dist[a]);</span><br><span class="line">            <span class="keyword">if</span>(dist[b] &lt; maxMoves) t += <span class="built_in">min</span>(c, maxMoves - dist[b]);</span><br><span class="line">            res += <span class="built_in">min</span>(t, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-787</title>
      <link href="/p/f5cf.html"/>
      <url>/p/f5cf.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h2><p><img src="/p/f5cf/LeetCode-787-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>等价于长度最大为 $k + 1$ 的最短路，<strong>bellman-ford</strong>很明显。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist, backup;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dist.<span class="built_in">resize</span>(n, inf);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            backup = dist;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> edge : flights)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = edge[<span class="number">0</span>], b = edge[<span class="number">1</span>], c = edge[<span class="number">2</span>];</span><br><span class="line">                dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[dst] == inf ? - <span class="number">1</span>: dist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode-743</title>
      <link href="/p/36cb.html"/>
      <url>/p/36cb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h2><p><img src="/p/36cb/LeetCode-743-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 一下，求出所有点的最短路，然后求最短路的最大值即可(不连通的情况特判一下)。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">6010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> h[N], ne[M], e[M], w[M], idx, n, dist[N], s;</span><br><span class="line">    <span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> x = p.first, y = p.second;</span><br><span class="line">            <span class="keyword">if</span>(st[y]) <span class="keyword">continue</span>;</span><br><span class="line">            st[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[y]; ~i; i = ne[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; x + w[i])&#123;</span><br><span class="line">                    dist[j] = x + w[i];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> _N, <span class="keyword">int</span> _K)</span> </span>&#123;</span><br><span class="line">        n = _N, s = _K;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> time : times)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = time[<span class="number">0</span>], b = time[<span class="number">1</span>], c =time[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, dist[i]);</span><br><span class="line">        <span class="keyword">if</span>(res == inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing341-最优贸易</title>
      <link href="/p/8fc3.html"/>
      <url>/p/8fc3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="341-最优贸易"><a href="#341-最优贸易" class="headerlink" title="341. 最优贸易"></a><a href="https://www.acwing.com/problem/content/343/">341. 最优贸易</a></h2><p><img src="/p/8fc3/AcWing341-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求出：</p><ul><li>从 1 到 i 的过程中，买入的最低价格 dmin[i]</li><li>从 i 到 n 的过程中，卖出的最高价格 dmax[i]</li></ul><p>等价于求出 $\{dmax[i] - dmin[i]\}, i \in 1,2,\cdots ,n$</p><p>只能使用SPFA，因为环的存在</p><p>为了保证若1能到i，i必须也能到n，所以分开计算而不是使用一个数组。</p><p>为了方便，dmin用正向边，dmax用反边求解。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], rh[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dmin[N], dmax[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">int</span> *h, <span class="keyword">bool</span> flag, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dmin));</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    st[s] = <span class="literal">true</span>;</span><br><span class="line">    d[s] = p[s];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; d[j] &gt; <span class="built_in">min</span>(d[t], p[j]) || !flag &amp;&amp; d[j] &lt; <span class="built_in">max</span>(d[t], p[j]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) d[j] = <span class="built_in">min</span>(d[t], p[j]);</span><br><span class="line">                <span class="keyword">else</span> d[j] = <span class="built_in">max</span>(d[t], p[j]);</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rh));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b);</span><br><span class="line">        <span class="built_in">add</span>(rh, b, a);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(h, b, a);</span><br><span class="line">            <span class="built_in">add</span>(rh, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(dmin, h, <span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">spfa</span>(dmax, rh, <span class="literal">false</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, dmax[i] - dmin[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
            <tag> DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AcWing342-道路与航线</title>
      <link href="/p/7e5e.html"/>
      <url>/p/7e5e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="342-道路与航线"><a href="#342-道路与航线" class="headerlink" title="342. 道路与航线"></a><a href="https://www.acwing.com/problem/content/344/">342. 道路与航线</a></h2><p><img src="/p/7e5e/Acwing342-2.png" alt></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据道路可以把图看成很多个团，那么航线就是连接团的有向边，从S到某个T的最短路径，可以看成S经过若干个团(且必须经过)后达到T所在的团的起点 $T_s$ 的最短路+ $dis_{T_s\rightarrow T}$</p><p>需要预处理出所有的团，可以根据点获得团，也可以根据团找到所有的点</p><p>然后对团做拓扑排序，依次处理每个团，在处理团内的点$v_x$时，对于它的某一个邻点$v_y$，如果$v_x$和$v_y$不是同一个团，则$v_y$所在的团就可以入队了，否则，可以更新$dist_{v_y}$(如果可以的话)。</p><p>由于每个团内部都是道路结点，因此可以团内使用dijkstra算法。</p><p>如果不采用以上算法的话，也可以使用spfa,不过需要有一些优化算法，这里不作赘述。</p><h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25010</span>, M = <span class="number">150010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> id[N], din[N], dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; block[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n, mr, mp, s, bcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> bidx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> bidx)</span></span>&#123;</span><br><span class="line">    id[u] = bidx;</span><br><span class="line">    block[bidx].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!id[j]) <span class="built_in">dfs</span>(j, bidx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(din[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : block[t])&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;dist[p], p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = p.first, y = p.second;</span><br><span class="line">        <span class="keyword">if</span>(st[y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[y]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; x + w[i])&#123;</span><br><span class="line">                dist[j] = x + w[i];</span><br><span class="line">                <span class="keyword">if</span>(id[j] == id[y]) pq.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[j] != id[y] &amp;&amp; --din[id[j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0xff</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="comment">// 输入道路节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mr; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定团</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!id[i]) <span class="built_in">dfs</span>(i, ++bcnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入航线</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mp; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        din[id[b]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对团做拓扑排序 &amp; dist计算</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &gt; inf / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> AcWing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 拓扑排序 </tag>
            
            <tag> DFS/BFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Internal Covariate Shift &amp; Normalization</title>
      <link href="/p/6d2e.html"/>
      <url>/p/6d2e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/33173246">参考链接1</a></p><p><a href="https://blog.csdn.net/sinat_33741547/article/details/87158830">参考链接2</a></p><h2 id="Interal-Covariate-Shift"><a href="#Interal-Covariate-Shift" class="headerlink" title="Interal Covariate Shift"></a>Interal Covariate Shift</h2><blockquote><p>The term <strong>interal covariate shift</strong> comes from the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a>.</p><p>The authors’ precise definition is:</p><blockquote><p>We define Internal Covariate Shift as the change in the distribution of network activations due to the change in network parameters during training.</p></blockquote><p>In neural networks, the output of the first layer feeds into the second layer, the output of the second layer feeds into the third, and so on. When the parameters of a layer change, so does the distribution of inputs to subsequent layers.</p><p>These shifts in input distributions can be problematic for neural networks, especially deep neural networks that could have a large number of layers.</p><p><a href="https://machinelearning.wtf/terms/batch-normalization/">Batch normalization</a> is a method intended to mitigate internal covariate shift for neural networks</p></blockquote><p>简单的说，Interal Covariate Shift(后面简称ICS)是在网络训练过程中，由于前面层中的网络参数不断更新而导致的网络输入的分布不均匀的现象。网络层的序列化意味着后续网络的输入为前面网络的输入，而由于网络参数的更新，对于原始相同的输入，其经过每一层后的输出都会变化。</p><p>机器学习的一个重要假设就是数据的<strong>独立同分布(Independent and identically distributed，后面简称为iid)</strong>，<del>虽然这并不可能</del>。即使做不到idd，实际上很多机器学习的算法，例如<strong>逻辑回归</strong>，<strong>神经网络</strong>以然可以在非iid的数据上训练得到不错的数据，但很明显，iid可以简化模型训练，加快训练和提升预测能力。对这个概念的理解可以参考统计机器学习中的<strong>Covariate Shift</strong>，从概率的角度上就是，条件概率相同，但边缘概率不同，<del>甚至更难理解了。</del>再赘述一句理解的话，网络加深，网络参数不断更新，经过多次线性或者非线性变化，对于其中的某一层(不要抬杠的选第一层)，它得到的输入都不一样的，即便在第一层输入相同的数据，但是最终的分类标签却还是一致的，那么这些数据就不再是iid了。</p><p>这会导致一些问题：</p><ul><li>前面的网络需要不断的适应新的输入数据，降低学习率</li><li>后面的网络的输入的变化可能导致前面的网络陷入饱和区，训练过早停止</li><li>既然每层的更新是会直接或间接影响到其他层的，那么每一层的学习策略就不能那么“随意”，应该非常的”谨慎“，实际上，这种”谨慎“也不是那么可控的。</li></ul><h2 id="Whitening"><a href="#Whitening" class="headerlink" title="Whitening"></a>Whitening</h2><p>为了得到iid的数据，因此在数据送入模型之前，会经过数据预处理阶段，因此白化的目的就在于得到iid的数据。</p><ul><li>去除特征之间的相关性—&gt; 独立；</li><li>使得所有特征具有相同的均值和方差 —&gt; 同分布</li></ul><p>PCA就是一种典型的方法。<a href="http://ufldl.stanford.edu/tutorial/unsupervised/PCAWhitening/">PCA Whitening</a></p><h2 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h2><p>但是，白化的计算成本太高，于是有了normalization方法，可以简化计算过程，又可以使数据尽可能保留原始的数据表达能力。normalization这种方式，实际上并不是直接去解决ICS问题，更多的是面向梯度消失等问题，去加速网络收敛的。而且，均值方差相等与同分布不是一个概念。</p><h3 id="Normalization-Framework"><a href="#Normalization-Framework" class="headerlink" title="Normalization Framework"></a>Normalization Framework</h3><script type="math/tex; mode=display">\hat{x} = f(g*\frac{x-\mu}{\sigma} + b) \notag</script><p>通常的变换框架如上所示，实际上就是做了个shift和缩放转换到(0,1)正态分布，随后再进行reshift和rescale，最终转换成了 ($b$, $g^2$) 的分布。这里的reshift和rescale参数是可以学习的，而不是固定的(0,1)，很显然，因为输入范围本身就不可能确定为(0,1)，可学习的re参数也更符合底层的学习能力。</p><p>与白化相比，实际差距还是很大的。</p><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><img src="https://pic1.zhimg.com/80/v2-13bb64b6122e98421ea3528539c1bffc_720w.jpg" alt></p><p>其规范化针对单个神经元进行，利用网络训练时一个 mini-batch 的数据来计算该神经元 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> 的均值和方差,因而称为 Batch Normalization。</p><p><img src="/p/6d2e/ICSN1.png" style="zoom:50%;"></p><p>BN 可以看做一种纵向的规范化。由于 BN 是针对单个维度定义的，因此标准公式中的计算均为 element-wise 的。</p><p>BN 独立地规范化每一个输入维度 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> ，但规范化的参数是一个 mini-batch 的一阶统计量和二阶统计量。这就要求 每一个 mini-batch 的统计量是整体统计量的近似估计，或者说每一个 mini-batch 彼此之间，以及和整体数据，都应该是近似同分布的。分布差距较小的 mini-batch 可以看做是为规范化操作和模型训练引入了噪声，可以增加模型的鲁棒性；但如果每个 mini-batch的原始分布差别很大，那么不同 mini-batch 的数据将会进行不一样的数据变换，这就增加了模型训练的难度。</p><p>因此，BN 比较适用的场景是：每个 mini-batch 比较大，数据分布比较接近。在进行训练之前，要做好充分的 shuffle. 否则效果会差很多。</p><p>另外，由于 BN 需要在运行过程中统计每个 mini-batch 的一阶统计量和二阶统计量，因此不适用于动态的网络结构 和 RNN 网络。</p><h3 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h3><p><img src="https://pic1.zhimg.com/80/v2-2f1ad5749e4432d11e777cf24b655da8_720w.jpg" alt></p><p>LN 针对单个训练样本进行，不依赖于其他数据，因此可以避免 BN 中受 mini-batch 数据分布影响的问题，可以用于小mini-batch场景、动态网络场景和 RNN，特别是自然语言处理领域。此外，LN 不需要保存 mini-batch 的均值和方差，节省了额外的存储空间。</p><p>但是，BN 的转换是针对单个神经元可训练的——不同神经元的输入经过再平移和再缩放后分布在不同的区间，而 LN 对于一整层的神经元训练得到同一个转换——所有的输入都在同一个区间范围内。如果不同输入特征不属于相似的类别（比如颜色和大小），那么 LN 的处理可能会降低模型的表达能力。</p><h3 id="Instance-Normalization"><a href="#Instance-Normalization" class="headerlink" title="Instance Normalization"></a>Instance Normalization</h3><p><img src="/p/6d2e/ICSN2.png" style="zoom:50%;"></p><p>IN适用于生成模型中，比如图片风格迁移。因为图片生成的结果主要依赖于某个图像实例，更适合对单个像素有更高要求的场景。</p><h3 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h3><p><img src="/p/6d2e/ICSN3.png" style="zoom:50%;"></p><p>Kaiming He的论文中以图片的形式说明了四个的区别，Group介于IN和LN之间。</p><p>WN和CN跳过。</p><p>Normalizaiton的有效性可以参考文前的参考链接。</p>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> Normalization </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ &amp; STL</title>
      <link href="/p/d937.html"/>
      <url>/p/d937.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-amp-STL-等相关整理"><a href="#C-amp-STL-等相关整理" class="headerlink" title="C++ &amp; STL 等相关整理"></a>C++ &amp; STL 等相关整理</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> ... = ...;</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br></pre></td></tr></table></figure><p>在语法的别名声明，using的使用类似于typedef，但用法更为精妙。</p><h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a>stoi</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> wstring&amp; str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>stoi()的输入要不为空，否则可以使用atoi(().c.str())</p><h4 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a><a href="https://www.cplusplus.com/reference/sstream/">sstream</a></h4><p>istringstream类用于执行C++风格的字符串流的输入操作，支持&gt;&gt;;</p><p>ostringstream类用于执行C++风格的字符串流的输出操作，支持&lt;&lt;；</p><p>stringstream类同时可以支持C++风格的串流的输入输出操作，同时支持&gt;&gt;和&lt;&lt;；</p><p>即 stringstream = istringstream + ostringstream。</p><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html">不错的博客链接</a></p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> syntax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora+Gitee 图床</title>
      <link href="/p/377e.html"/>
      <url>/p/377e.html</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="c2f6eb897c6897d6f5a2777268a36b524acb76fb396ee010884624c2f72b57cf">6313153f3df6eb6824c31dfc042073d9ccfefb92f71156eeed8cf0d6e89f9af1cd917535561d8f7748a723ec5e29befbd4bd7c9480eb6ba12c94adfe891e68aa2376551a2485a887db394b3da1830e8ca8bca6ee66097e06472db890ea93692948fad949a522269b58509224655e29d8c3fd5e5ef12dffc08e694dcacaeb304bbfdc9a3f2d300af5e4c2d73670a83f2eb307d462f4941db179b3dd8dfdff505f4f9d01f855be7e4d3df50ed64a3d579245c2cfae34d3468458fb55b29180c5e1ba43ae523b8d5ddfec1c34f226a4eb60c3764edd53b6709484fedcc923468f2eada4bf783f87289abf833b2ddb558ca5ae584df78052f9b4d1b41492b99a9d7e9b90ebe2b1613bff16c3d6b9bc2167cea0890b1375b4d2ae3070a54a60cd9c17ca98bcbf10416090e789a9384fde250d125dcf89146c61db5834ae6302880b2d5a0c90bb3c58d3833dac246e4f983274db975a398c350d869b4d33173261ad3138e7b0ac7c190e25e139f7f3b108b1a3db0f5d3495d5a53e616c3f168e3ca87fc5ae2443bd22cacaa8760cbe878f8a0a80304d87e800c9e75a41cdd5eb423eee9787cb3dce3ccc99675fc897d40a658c8f29d29121da1b157b2df098f58bdc94e9f8c74e7537cf77e8539bb7d4451105d245dd3fe5113f638cfcfc1abdbe477c86a5ebc51beb76c6d8e72839a19d9783532201a439d5214d414484f973a816e58988467fff68714db982f967457377be0d444d6a0de22e7cfa55be62ca4ee3dc5e6edc75b8cc84217a28e49d209e27343a39e76cb8ac360f0c285cdb096a5514fe4e18a3c79423a1515cf7e6bb1c9d66971a7a2a94fbe6e9d5e477147ea7c958c1d9e3ea403c95f35a868765fce7495b506ff269e1dc79f23e8637024572d7cb5aac36aeb792d92064c97e8e87793dfb65662410442cf6cbf231c3a697ab923a8da8124c80e21488f417db05008e3316f01cccfec1404f0d5176ded4d8db0af79f0b0547e2421ddf3b0e61b22795d8d33919c08807f90534a9746df32aa06c640a0a25852ba5e78d0a07540c04aa4d2ddf486a5076a93feb58029c22a8f7d52fc6eb54973f7879b848d03db98374f01fbbe55416ecf5b58dcc6d0e296a09acdc7e2beb0bc48114fb69577e6fb1269b5e2b5e43bbc17ec43b3b59dc6107cc3982a6450685be9bf7060f822fefa0fffa6977ca32cc032cc710fe5142fb840854e356082090d9e6b588eb7f4b510400ae17e59a34cce3ee2e3c6511f9f0cfca7b093ddbbdbe1ad9df861b7935537f2a19663e8f029c37e8dc6df06ce1f569bf3a27ebbe44b1b9545dce92bacdfe7c31b53af23ad119260ed0584b944f42aa32f54559495c9051274001dcb59debbfdd63f4b44f95ff2e6cd72117eb31cd3d57c2e6ee3c0581986013f61a660543f70f6f045e42446ef8a28a8f9ee960e36ee227a5fa15675808b78d5a04777a2677e68b7698d965cde6c2ef70d0a69e7fe99b00d0ab8cc1c6309555b8eea7970dea27d46ed4bb40163eec232ec63e1bb33ace76416de008df4f7758549d9a3983a31f9adc3c4484b26e368e536ed4f78c812f871c8fbb6f04d6676e885e916f55d4ef0ed04440fb3adb75d1bea7ac39c34740f7dd8820f20fa8d3ca8ce5ab13988d747e6ac4e72963e9cbba0aa9bd25d5c466b6dbb5b2476536e9984b9e13113a3842c23e57f75faf645722783140e16253f98a9e23875c0d5d59f33a3af3d5b664bbee23740e6c6b2cdc8a8be015b674146ae82582e25b539f1857bf52374b84e4c98f5caa99c3096090859848fb58d30a5290f1f5b21b268e8c0ba9cdcbff14d5f9b4d3d6e198e72776ecb6bdcc47b6126a5f4a878fad11c0699811d9bdda501d428ef4130ea46c034f22299f68b8388cc62a0fab58f726e2ff8052abd7976701043f56e258675036ae13663c88ad2caaece150b83e86c1b69b326179726c85532ba215925afb6fab972e3e9486cb52929dbfe2da9706373a7ba81164785872fd0ff847d5ba956a37db82585993d08c227ef1cfdc720cae86932714926d9a687db8ced69ff23edfa6382d8f698b0e258871cc63d1982af48bd8a85b5cdd9fd74d1ed9557390051dd4e5e87ada1f7a6fb13998461f81ce9dadeab6b9345adc6f0ce6022c2009e97fdd892832e3397c6b0e2351533a938554f91800f38533d8b3ff409a6adc540eec14755e713cb99a93ad7af2308b381a56d129c8d7686aef93d39dd9e2e546ecbbea1dc1769deb3720f1a2fe2da03bc08ac0ae545cb2799ab0a7ca73bc9cfed7e5fdbfe77180d868a79c09e58f6c2ad86c3dba4b6fbe5490f6048fc4861880b24df28d9908ac1c1a74de6cf85313cf3383f824b4f70224b05e4301984e2dadfa775d35ba5b73ec318c164aaaeb98049f1670c47f4e838d22848483da9ba5cc6353b794172f86cff91b085282be1787945294ec2439349ef891af93ae1d96bcc644c86b4e994192e38322936d36c7159cd85d7a4b167429f6e0186fd9ef3a3415ff1b2d60c88ced0398d320a102958b8668f25ade756992fdb7dc4457b9d121611280e5ad858253f9c837a0feb2594fe4e0f45dc004f465ff70aa987d6b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode 240</title>
      <link href="/p/9a99.html"/>
      <url>/p/9a99.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-240-搜索二维矩阵II"><a href="#LeetCode-240-搜索二维矩阵II" class="headerlink" title="LeetCode 240 搜索二维矩阵II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">LeetCode 240 搜索二维矩阵II</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</strong></p><blockquote><p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p></blockquote><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p><blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt></p><p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br>输出：true</p></blockquote><p><strong>示例 2：</strong></p><blockquote><p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt></p><p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br>输出：false</p></blockquote><h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>提示：</strong></p><blockquote><ul><li>m == matrix.length</li><li>n == matrix[i].length</li><li>1 &lt;= n, m &lt;= 300</li><li>$-10^9 \leq$ matrix[i][j] $\leq 10^9$</li><li>每行的所有元素从左到右升序排列</li><li>每列的所有元素从上到下升序排列</li><li>$-10^9 \leq$ target $\leq 10^9$</li></ul></blockquote><span id="more"></span><h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>从右上角建根，可以看成抽象的二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; m &amp;&amp; r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
