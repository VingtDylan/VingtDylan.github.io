<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>LeetCode-1334</title>
    <url>/p/9c7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1334-阈值距离内邻居最少的城市"><a href="#1334-阈值距离内邻居最少的城市" class="headerlink" title="1334. 阈值距离内邻居最少的城市"></a><a href="https://leetcode-cn.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/">1334. 阈值距离内邻居最少的城市</a></h2><p><img src="/p/9c7/LeetCode-1334-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>Flyod</strong> 求所有点对之间的最短路，然后 $O(n^2)$ 暴力求解每个点的情况，与全局的 <strong>minCount</strong>对比并更新结果即可。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dp;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTheCity</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> distanceThreshold)</span> </span>&#123;</span><br><span class="line">        dp.<span class="built_in">resize</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) dp[i][i] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            dp[a][b] = dp[b][a] = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][k] + dp[k][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx, mincnt = inf;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; dp[i][j] &lt;= distanceThreshold)&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt;= mincnt)&#123;</span><br><span class="line">                mincnt = cnt;</span><br><span class="line">                idx = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode 240</title>
    <url>/p/9a99.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="LeetCode-240-搜索二维矩阵II"><a href="#LeetCode-240-搜索二维矩阵II" class="headerlink" title="LeetCode 240 搜索二维矩阵II"></a><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii/">LeetCode 240 搜索二维矩阵II</a></h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><strong>编写一个高效的算法来搜索 m x n 矩阵 matrix 中的一个目标值 target 。该矩阵具有以下特性：</strong></p>
<blockquote>
<p>每行的元素从左到右升序排列。<br>每列的元素从上到下升序排列。</p>
</blockquote>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p>
<blockquote>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid2.jpg" alt></p>
<p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 5<br>输出：true</p>
</blockquote>
<p><strong>示例 2：</strong></p>
<blockquote>
<p><img src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2020/11/25/searchgrid.jpg" alt></p>
<p>输入：matrix = [[1,4,7,11,15],[2,5,8,12,19],[3,6,9,16,22],[10,13,14,17,24],[18,21,23,26,30]], target = 20<br>输出：false</p>
</blockquote>
<h2 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h2><p><strong>提示：</strong></p>
<blockquote>
<ul>
<li>m == matrix.length</li>
<li>n == matrix[i].length</li>
<li>1 &lt;= n, m &lt;= 300</li>
<li>$-10^9 \leq$ matrix[i][j] $\leq 10^9$</li>
<li>每行的所有元素从左到右升序排列</li>
<li>每列的所有元素从上到下升序排列</li>
<li>$-10^9 \leq$ target $\leq 10^9$</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h2><p>从右上角建根，可以看成抽象的二叉树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchMatrix</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>(), n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; m &amp;&amp; r &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] == target) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(matrix[l][r] &gt; target) r--;</span><br><span class="line">            <span class="keyword">else</span> l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-743</title>
    <url>/p/36cb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h2><p><img src="/p/36cb/LeetCode-743-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 一下，求出所有点的最短路，然后求最短路的最大值即可(不连通的情况特判一下)。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> N = <span class="number">110</span>, M = <span class="number">6010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">int</span> h[N], ne[M], e[M], w[M], idx, n, dist[N], s;</span><br><span class="line">    <span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">        priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; q;</span><br><span class="line">        dist[s] = <span class="number">0</span>;</span><br><span class="line">        q.<span class="built_in">push</span>(&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">auto</span> p = q.<span class="built_in">top</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">int</span> x = p.first, y = p.second;</span><br><span class="line">            <span class="keyword">if</span>(st[y]) <span class="keyword">continue</span>;</span><br><span class="line">            st[y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = h[y]; ~i; i = ne[i])&#123;</span><br><span class="line">                <span class="keyword">int</span> j = e[i];</span><br><span class="line">                <span class="keyword">if</span>(dist[j] &gt; x + w[i])&#123;</span><br><span class="line">                    dist[j] = x + w[i];</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">networkDelayTime</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; times, <span class="keyword">int</span> _N, <span class="keyword">int</span> _K)</span> </span>&#123;</span><br><span class="line">        n = _N, s = _K;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> time : times)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = time[<span class="number">0</span>], b = time[<span class="number">1</span>], c =time[<span class="number">2</span>];</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dijkstra</span>();</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, dist[i]);</span><br><span class="line">        <span class="keyword">if</span>(res == inf) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-787</title>
    <url>/p/f5cf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="743-网络延迟时间"><a href="#743-网络延迟时间" class="headerlink" title="743. 网络延迟时间"></a><a href="https://leetcode-cn.com/problems/network-delay-time/">743. 网络延迟时间</a></h2><p><img src="/p/f5cf/LeetCode-787-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>等价于长度最大为 $k + 1$ 的最短路，<strong>bellman-ford</strong>很明显。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist, backup;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        dist.<span class="built_in">resize</span>(n, inf);</span><br><span class="line">        dist[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            backup = dist;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> edge : flights)&#123;</span><br><span class="line">                <span class="keyword">int</span> a = edge[<span class="number">0</span>], b = edge[<span class="number">1</span>], c = edge[<span class="number">2</span>];</span><br><span class="line">                dist[b] = <span class="built_in">min</span>(dist[b], backup[a] + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dist[dst] == inf ? - <span class="number">1</span>: dist[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode-882</title>
    <url>/p/f53f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="882-细分图中的可到达结点"><a href="#882-细分图中的可到达结点" class="headerlink" title="882. 细分图中的可到达结点"></a><a href="https://leetcode-cn.com/problems/reachable-nodes-in-subdivided-graph/">882. 细分图中的可到达结点</a></h2><p><img src="/p/f53f/LeetCode-882-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 求最短路, 可以分出 c 个点，等价于两点之间的路径长为 c + 1</p>
<p>求出最短路后，对每一条边进行遍历，则 $a \rightarrow b$中除了端点 $a$ 还可以遍历到 $min(c, maxMoves - dist[a])$ 个点(如果 $dist[a] &lt; maxMoves$)，记为 $x$ , 而 $b\rightarrow a$除了端点 $b$ 还可以遍历到 $min(c, maxMoves - dist[b])$ 个点(如果 $dist[b] &lt; maxMoves$), 记为 $y$，则 无向边 $a \leftrightarrow b$，除了端点外还可以访问到 $min(x + y, c)$ 个点，对于原始的 $n$ 个顶点，若 $dist[j] \leq maxMove$，则 $j$ 可以访问到。累加所有即可。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; w;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; dist;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; st;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reachableNodes</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges, <span class="keyword">int</span> maxMoves, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        w.<span class="built_in">resize</span>(n, vector&lt;<span class="keyword">int</span>&gt;(n, inf));</span><br><span class="line">        dist.<span class="built_in">resize</span>(n, inf);</span><br><span class="line">        st.<span class="built_in">resize</span>(n, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            w[a][b] = w[b][a] = c + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[t] &gt; dist[j]))</span><br><span class="line">                    t =j;</span><br><span class="line">            &#125;</span><br><span class="line">            st[t] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dist[j] = <span class="built_in">min</span>(dist[j], dist[t] + w[t][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) res += (dist[i] &lt;= maxMoves);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> e : edges)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = e[<span class="number">0</span>], b = e[<span class="number">1</span>], c = e[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">int</span> t = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(dist[a] &lt; maxMoves) t += <span class="built_in">min</span>(c, maxMoves - dist[a]);</span><br><span class="line">            <span class="keyword">if</span>(dist[b] &lt; maxMoves) t += <span class="built_in">min</span>(c, maxMoves - dist[b]);</span><br><span class="line">            res += <span class="built_in">min</span>(t, c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>最短路</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing1133-第二短路</title>
    <url>/p/1ed1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1133-第二短路"><a href="#1133-第二短路" class="headerlink" title="1133. 第二短路"></a><a href="https://www.acwing.com/problem/content/description/1135/">1133. 第二短路</a></h2><p><img src="/p/1ed1/AcWing-1133-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>dijkstra</strong> 求最短路的过程中维护次短路，需要注意 “严格” 的问题。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v, type, dis;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> Node&amp; node) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dis &gt; node.dis;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5010</span>, M = <span class="number">200010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], w[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> n, r;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    dist[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    priority_queue&lt;Node, vector&lt;Node&gt;, greater&lt;Node&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> v = p.v, type = p.type, dis = p.dis;</span><br><span class="line">        <span class="keyword">if</span>(st[v][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[v][type] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[v]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j][<span class="number">0</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = dis + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] &gt; dis + w[i] &amp;&amp; dist[j][<span class="number">0</span>] &lt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dis + w[i];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dist[n][<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; r;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing1146-新的开始</title>
    <url>/p/d1bf.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1146-新的开始"><a href="#1146-新的开始" class="headerlink" title="1146. 新的开始"></a><a href="https://www.acwing.com/problem/content/1148/">1146. 新的开始</a></h2><p><img src="/p/d1bf/AcWing-1146-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>建立超级源点，添加所有点与源点的边，边权为该点的挖井费用，然后基本的最小生成树。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">310</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">prim</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t == <span class="number">-1</span> || dist[j] &lt; dist[t]))&#123;</span><br><span class="line">                t = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        st[t] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i) res += dist[t];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dist[j] = <span class="built_in">min</span>(dist[j], g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> w;</span><br><span class="line">        cin &gt;&gt; w;</span><br><span class="line">        g[<span class="number">0</span>][i] = g[i][<span class="number">0</span>] = w;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            cin &gt;&gt; g[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">prim</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing1148-秘密的奶牛运输</title>
    <url>/p/bdf0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://oi-wiki.org/graph/mst/#_8">复习一手原理(知识点)</a></p>
<p>OIwiki上的拓展知识点好多，我是废物。</p>
<h2 id="1148-秘密的牛奶运输"><a href="#1148-秘密的牛奶运输" class="headerlink" title="1148. 秘密的牛奶运输"></a><a href="https://www.acwing.com/problem/content/1150/">1148. 秘密的牛奶运输</a></h2><p><img src="/p/bdf0/AcWing-1148-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>Oiwiki上学一下知识点就行了，区分一下严格和非严格的处理细节。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>图论</tag>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing341-最优贸易</title>
    <url>/p/8fc3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="341-最优贸易"><a href="#341-最优贸易" class="headerlink" title="341. 最优贸易"></a><a href="https://www.acwing.com/problem/content/343/">341. 最优贸易</a></h2><p><img src="/p/8fc3/AcWing341-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>求出：</p>
<ul>
<li>从 1 到 i 的过程中，买入的最低价格 dmin[i]</li>
<li>从 i 到 n 的过程中，卖出的最高价格 dmax[i]</li>
</ul>
<p>等价于求出 $\{dmax[i] - dmin[i]\}, i \in 1,2,\cdots ,n$</p>
<p>只能使用SPFA，因为环的存在</p>
<p>为了保证若1能到i，i必须也能到n，所以分开计算而不是使用一个数组。</p>
<p>为了方便，dmin用正向边，dmax用反边求解。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>, M = <span class="number">2000010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], rh[N], e[M], ne[M], idx;</span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> dmin[N], dmax[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> *h, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    e[idx] = b, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">spfa</span><span class="params">(<span class="keyword">int</span> *d, <span class="keyword">int</span> *h, <span class="keyword">bool</span> flag, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="keyword">if</span>(flag) <span class="built_in">memset</span>(d, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dmin));</span><br><span class="line">    q.<span class="built_in">push</span>(s);</span><br><span class="line">    st[s] = <span class="literal">true</span>;</span><br><span class="line">    d[s] = p[s];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        st[t] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[t]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(flag &amp;&amp; d[j] &gt; <span class="built_in">min</span>(d[t], p[j]) || !flag &amp;&amp; d[j] &lt; <span class="built_in">max</span>(d[t], p[j]))&#123;</span><br><span class="line">                <span class="keyword">if</span>(flag) d[j] = <span class="built_in">min</span>(d[t], p[j]);</span><br><span class="line">                <span class="keyword">else</span> d[j] = <span class="built_in">max</span>(d[t], p[j]);</span><br><span class="line">                <span class="keyword">if</span>(!st[j])&#123;</span><br><span class="line">                    st[j] = <span class="literal">true</span>;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="built_in">memset</span>(rh, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(rh));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) cin &gt;&gt; p[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(h, a, b);</span><br><span class="line">        <span class="built_in">add</span>(rh, b, a);</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">add</span>(h, b, a);</span><br><span class="line">            <span class="built_in">add</span>(rh, a, b);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">spfa</span>(dmin, h, <span class="literal">true</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">spfa</span>(dmax, rh, <span class="literal">false</span>, n);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res = <span class="built_in">max</span>(res, dmax[i] - dmin[i]);</span><br><span class="line">    cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
        <tag>DP</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing342-道路与航线</title>
    <url>/p/7e5e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="342-道路与航线"><a href="#342-道路与航线" class="headerlink" title="342. 道路与航线"></a><a href="https://www.acwing.com/problem/content/344/">342. 道路与航线</a></h2><p><img src="/p/7e5e/Acwing342-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>根据道路可以把图看成很多个团，那么航线就是连接团的有向边，从S到某个T的最短路径，可以看成S经过若干个团(且必须经过)后达到T所在的团的起点 $T_s$ 的最短路+ $dis_{T_s\rightarrow T}$</p>
<p>需要预处理出所有的团，可以根据点获得团，也可以根据团找到所有的点</p>
<p>然后对团做拓扑排序，依次处理每个团，在处理团内的点$v_x$时，对于它的某一个邻点$v_y$，如果$v_x$和$v_y$不是同一个团，则$v_y$所在的团就可以入队了，否则，可以更新$dist_{v_y}$(如果可以的话)。</p>
<p>由于每个团内部都是道路结点，因此可以团内使用dijkstra算法。</p>
<p>如果不采用以上算法的话，也可以使用spfa,不过需要有一些优化算法，这里不作赘述。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> pii = pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25010</span>, M = <span class="number">150010</span>, inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> id[N], din[N], dist[N];</span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; block[N];</span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"><span class="keyword">int</span> n, mr, mp, s, bcnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> bidx)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> bidx)</span></span>&#123;</span><br><span class="line">    id[u] = bidx;</span><br><span class="line">    block[bidx].<span class="built_in">push_back</span>(u);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = h[u]; ~i; i = ne[i])&#123;</span><br><span class="line">        <span class="keyword">int</span> j = e[i];</span><br><span class="line">        <span class="keyword">if</span>(!id[j]) <span class="built_in">dfs</span>(j, bidx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">topsort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    dist[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bcnt; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(din[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">int</span> t = q.<span class="built_in">front</span>(); </span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">dijkstra</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> t)</span></span>&#123;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;pii&gt;&gt; pq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p : block[t])&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(&#123;dist[p], p&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(pq.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">auto</span> p = pq.<span class="built_in">top</span>(); pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> x = p.first, y = p.second;</span><br><span class="line">        <span class="keyword">if</span>(st[y]) <span class="keyword">continue</span>;</span><br><span class="line">        st[y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[y]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j] &gt; x + w[i])&#123;</span><br><span class="line">                dist[j] = x + w[i];</span><br><span class="line">                <span class="keyword">if</span>(id[j] == id[y]) pq.<span class="built_in">push</span>(&#123;dist[j], j&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(id[j] != id[y] &amp;&amp; --din[id[j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(id[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; mr &gt;&gt; mp &gt;&gt; s;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(h, <span class="number">0xff</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">    <span class="comment">// 输入道路节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mr; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        <span class="built_in">add</span>(b, a, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 确定团</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!id[i]) <span class="built_in">dfs</span>(i, ++bcnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输入航线</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mp; i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        din[id[b]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对团做拓扑排序 &amp; dist计算</span></span><br><span class="line">    <span class="built_in">topsort</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(dist[i] &gt; inf / <span class="number">2</span>) <span class="built_in">puts</span>(<span class="string">&quot;NO PATH&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; dist[i] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
        <tag>拓扑排序</tag>
        <tag>DFS/BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing345-牛站</title>
    <url>/p/ccd6.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="345-牛站"><a href="#345-牛站" class="headerlink" title="345.牛站"></a><a href="https://www.acwing.com/problem/content/347/">345.牛站</a></h2><p><img src="/p/ccd6/AcWing-345-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>变种Flyod+快速幂思想（倍增），还需要提前做离散化。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">210</span>;</span><br><span class="line"><span class="keyword">int</span> g[N][N];</span><br><span class="line"><span class="keyword">int</span> res[N][N];</span><br><span class="line"><span class="keyword">int</span> k, n, m, s, e;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> c[][N], <span class="keyword">int</span> a[][N], <span class="keyword">int</span> b[][N])</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> temp[N][N];</span><br><span class="line">    <span class="built_in">memset</span>(temp, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(temp));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">                temp[i][j] = <span class="built_in">min</span>(temp[i][j], a[i][k] + b[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(c, temp, <span class="built_in"><span class="keyword">sizeof</span></span>(temp));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qmi</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(res));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) res[i][i] = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(k)&#123;</span><br><span class="line">        <span class="keyword">if</span>(k &amp; <span class="number">1</span>) <span class="built_in">mul</span>(res, res, g);</span><br><span class="line">        <span class="built_in">mul</span>(g, g, g);</span><br><span class="line">        k &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; k &gt;&gt; m &gt;&gt; s &gt;&gt; e;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">memset</span>(g, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(g));</span><br><span class="line">    map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">    <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(s)) mp[s] = ++n;</span><br><span class="line">    <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(e)) mp[e] = ++n;</span><br><span class="line">    s = mp[s], e = mp[e];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (m -- )&#123;</span><br><span class="line">        <span class="keyword">int</span> a, b, c;</span><br><span class="line">        cin &gt;&gt; c &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(a)) mp[a] = ++n;</span><br><span class="line">        <span class="keyword">if</span>(!mp.<span class="built_in">count</span>(b)) mp[b] = ++n;</span><br><span class="line">        a = mp[a], b = mp[b];</span><br><span class="line">        g[a][b] = g[b][a] = <span class="built_in">min</span>(g[a][b], c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">qmi</span>();</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; res[s][e] &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>快速幂</tag>
        <tag>离散化</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing346-走廊泼水节</title>
    <url>/p/9c3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="346-走廊泼水节"><a href="#346-走廊泼水节" class="headerlink" title="346. 走廊泼水节"></a><a href="https://www.acwing.com/problem/content/348/">346. 走廊泼水节</a></h2><p><img src="/p/9c3/AcWing-346-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看代码就能理解该题思路，核心思想就是按照边权顺序生成完全图，新增的边权设置决定唯一性，证明略。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6010</span>;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b, w;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Edge&amp; e) <span class="keyword">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> w &lt; e.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;e[N];</span><br><span class="line"><span class="keyword">int</span> p[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> p[x] == x ? p[x] : p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span>(T--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, w;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; w;</span><br><span class="line">            e[i] = &#123;a, b, w&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(e, e + n - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i, s[i] = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = <span class="built_in">find</span>(e[i].a), b = <span class="built_in">find</span>(e[i].b), w = e[i].w;</span><br><span class="line">            <span class="keyword">if</span>(a != b)&#123;</span><br><span class="line">                res += (s[a] * s[b] - <span class="number">1</span>) * (w + <span class="number">1</span>);</span><br><span class="line">                s[b] += s[a];</span><br><span class="line">                p[a] = b;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; res &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最小生成树</tag>
      </tags>
  </entry>
  <entry>
    <title>AcWing383-观光</title>
    <url>/p/ef51.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="383-观光"><a href="#383-观光" class="headerlink" title="383. 观光"></a><a href="https://www.acwing.com/problem/content/385/">383. 观光</a></h2><p><img src="/p/ef51/AcWing-383-2.png" alt></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>仿照第二短路的解法而已，额外添加了计数功能而已，代码很好理解。</p>
<h2 id="AC-code"><a href="#AC-code" class="headerlink" title="AC code"></a>AC code</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> ver, type, dist;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &gt; (<span class="keyword">const</span> node&amp; nod) <span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dist &gt; nod.dist;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1010</span>, M = <span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> h[N], e[M], ne[M], w[M], idx;</span><br><span class="line"><span class="keyword">int</span> dist[N][<span class="number">2</span>], cnt[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> st[N][<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> t, n, m, S, T;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">    e[idx] = b, w[idx] = c, ne[idx] = h[a], h[a] = idx++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(st));</span><br><span class="line">    <span class="built_in">memset</span>(dist, <span class="number">0x3f</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dist));</span><br><span class="line">    <span class="built_in">memset</span>(cnt, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(cnt));</span><br><span class="line">    </span><br><span class="line">    dist[S][<span class="number">0</span>] = <span class="number">0</span>, cnt[S][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    priority_queue&lt;node, vector&lt;node&gt;, greater&lt;node&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;S, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;</span><br><span class="line">        node tt = q.<span class="built_in">top</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">int</span> ver = tt.ver, type = tt.type, dis = tt.dist;</span><br><span class="line">        <span class="keyword">int</span> count = cnt[ver][type];</span><br><span class="line">        <span class="keyword">if</span>(st[ver][type]) <span class="keyword">continue</span>;</span><br><span class="line">        st[ver][type] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = h[ver]; ~i; i = ne[i])&#123;</span><br><span class="line">            <span class="keyword">int</span> j = e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j][<span class="number">0</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dist[j][<span class="number">0</span>], cnt[j][<span class="number">1</span>] = cnt[j][<span class="number">0</span>];</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">                dist[j][<span class="number">0</span>] = dis + w[i], cnt[j][<span class="number">0</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">0</span>, dist[j][<span class="number">0</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">0</span>] == dis + w[i]) cnt[j][<span class="number">0</span>] += count;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] &gt; dis + w[i])&#123;</span><br><span class="line">                dist[j][<span class="number">1</span>] = dis + w[i], cnt[j][<span class="number">1</span>] = count;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;j, <span class="number">1</span>, dist[j][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(dist[j][<span class="number">1</span>] == dis + w[i]) cnt[j][<span class="number">1</span>] += count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = cnt[T][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span>(dist[T][<span class="number">0</span>] + <span class="number">1</span> == dist[T][<span class="number">1</span>]) res += cnt[T][<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">        <span class="built_in">memset</span>(h, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(h));</span><br><span class="line">        idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> a, b, c;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">            <span class="built_in">add</span>(a, b, c);</span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; S &gt;&gt; T;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">dijkstra</span>() &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AcWing</category>
      </categories>
      <tags>
        <tag>最短路</tag>
        <tag>图论</tag>
      </tags>
  </entry>
  <entry>
    <title>MobileNets v1</title>
    <url>/p/9d20.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用于移动视觉应用的高效卷积网络</p>
<p>文献中引用的一些压缩方法，例如 production quantizationm, hashing, pruning, vector quantization 和 huffman coding 感觉值得了解一下(乘积量化，哈希，剪枝，矢量量化，哈夫曼编码)。至于SqueezeNets 等可以单独学习一下。Distillation(蒸馏)啥的也需要学学，还有Low Bit Networks(低比特网络)。啥也不会。。。orz</p>
<p>此外一些觉得不错的讲解，视频等等:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=kSGhpsme2mo">https://www.youtube.com/watch?v=kSGhpsme2mo</a></li>
<li><a href="https://yinguobing.com/separable-convolution/">https://yinguobing.com/separable-convolution/</a></li>
</ul>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>提出了一类可以i用于移动和嵌入式视觉应用的高校模型，称为 <strong>MobileNets</strong>。MobileNets基于流线型架构，使用<strong>深度可分离卷积</strong>构建轻量级深度神经网络。引入了两个简单的全局超参数，可以有效的权衡延迟(<strong>latency</strong>)和准确性(<strong>accuracy</strong>)。这些超参数允许模型构建者根据问题的约束条件为他们的应用选择合适的模型尺寸。在 ImageNet 分类上，进行了大量的资源和精度权衡实验，并与其他流行的模型进行对比，模型都表现出了很强的性能。最后，在广泛的应用和示例中演示了 MobileNets 的有效性，包括目标检测，细粒度分类，人脸属性和大规模地理定位。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>自从AlexNet 在 ImageNet 挑战赛(ILSVRC 2012) 上获胜，推广了深度卷积网络以来，卷积神经网络就在计算机视觉中变得无处不在，为了达到更高的精度，整体的趋势就是构建更深的，更复杂的网络。然而，这些提高准确性的改进方法并不一定会在模型规模和运行速度等方面变得高效。在许多现实世界的应用中，例如机器人，自动驾驶汽车，增强现实等，则需要子啊有限计算能力的平台上及时完成识别任务。</p>
<p>本文描述了一种高效的网络架构和一组两个超参数，以建立规模较小，低延迟的模型，可以很容易的匹配移动和嵌入式视觉应用程序的设计需求。第二节回顾了构建小型模型的前期工作。第三节描述了 MobileNets 架构和两个定义更小和更高效 MobileNets 的超参数：宽度乘法因子( width multiplier )和分辨率乘法因子( resolution multiplier )。第四节描述了在ImageNet 上的实验以及各种不同应用和使用案例。第五节以总结和结论结尾。 </p>
<h2 id="Prior-Work"><a href="#Prior-Work" class="headerlink" title="Prior Work"></a>Prior Work</h2><p>在最近的工作中，人们开始对构建小型高效神经网络感兴趣。这些不同的方法可以分为 <strong>压缩预训练模型</strong> 和 <strong>直接训练小网络</strong> 两种。本文提出了一类网络架构，它允许模型开发人员为他们的应用程序专门选择符合资源限制(延迟，网络规模)的小型网络。 MobileNets 主要专注于优化延迟，但也产生小型网络。许多关于小型网络的的论文只关于规模但是没有考虑到运行速度。</p>
<p>MobileNets 主要由深度可分离网络构建，最初在一个博士论文中，后来在 Inception 模型中使用用于减少前几层的计算。Flattened Networks 构建了一个完全分解的卷积网络，展示了极端分解网路的潜力。与本文无关的是，Factorized Networks 引入了一个类似的分解网络以及使用了拓扑连接。随后，在Xception Networks 演示了如何拓展深度可分离过滤器以超越 Inception V3网络。另一个小型网络是 SqueezeNet，它使用了瓶颈方法(bottleneck approach)去设计小型网络。其他简化计算的网络包括 Structured Transform Networks 和 Deep Fried ConvNets。（吓得我都不敢翻译了）</p>
<p>另一种获取小型网络的方法就是缩小，分解，或者压缩预训练模型。基于 production quantization, hashing, pruning, vector quantization 和 huffman coding 的压缩方法都有文献提及(乘积量化，哈希，剪枝，矢量量化，哈夫曼编码)。此外，还有一些分解方法来加速预训练网络的速度。另一种训练预训练网络的方法是 distillation (蒸馏)，它使用较大的网络来训练较小的网络，是本文方法的补充，在第四节的一些用例中也会涉及。另一种新型的方法是 low bit networks(低比特网络)。</p>
<h2 id="MobileNet-Architecture"><a href="#MobileNet-Architecture" class="headerlink" title="MobileNet Architecture"></a>MobileNet Architecture</h2><p>首先描述构建 MobileNets 的核心层，这些核心层由深度可分离过滤器组成。然后描述了 MobileNets 的网络结构，并对两种模型进行描述，即使用宽度乘法因子和分辨率乘法因子的缩小超参数的模型。</p>
<h3 id="Depthwise-Separable-Convolution"><a href="#Depthwise-Separable-Convolution" class="headerlink" title="Depthwise Separable Convolution"></a>Depthwise Separable Convolution</h3><p>模型基于深度可分离卷积，是一种分解卷积的形式，它将标准的卷积分解为深度卷积和一个 $1\times1$ 的称为点态卷积的卷积。对于 MobileNets， 深度卷积对每个输入通道应用一个滤波器。然后点态卷积会进行一个 $1 \times 1$ 卷积将深度卷积的结果结合起来。一个标准的卷积在一步之内过滤和将输入结合生成一组输出。而深度可分离卷积则将其分为两层，一层用于过滤和一层用于合并。这种分解可以显著减少运算量和模型大小。下图为标准卷积分解为深度卷积和 $1\times1$ 点态卷积的过程。</p>
<p><img src="/p/9d20/MobileNets2.png" style="zoom:60%;"></p>
<p>标准的卷积层将一个 $D_F \times D_F \times M$ 的特征图 $F$ 作为输入，并输出一个 $D_F\times D_F \times N$ 的特征图 $G$， 这里的 $D_F$代表特征图的空间宽度和高度，$M, N$ 为通道数，需要注意的是，很显然，这里的$D_F$只是代指，输入和输出的高度和宽度并不可能完全一样，这里只是为了方便分析。</p>
<p>标准的卷积层用卷积核 $K$ 参数化，大小为 $D_K\times D_K\times M\times N$，这里的$D_K$ 为卷积核的空间维度，假设为方形的卷积核，$M，N$ 分别为输入输出的通道数。</p>
<p>对于标准的卷积（假定步长为一并含有填充）的输出特征图则可以计算为:</p>
<script type="math/tex; mode=display">
G_{k,l,n}=\sum_{i,j,m}K_{i,j,m,n}\cdot F_{k+i-1,l+j-1,m}</script><p>因此标准的计算代价为：</p>
<script type="math/tex; mode=display">
D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F</script><p>即依赖于输入的卷积核大小，输入输出通道数，输出的特征图大小。</p>
<p>MobileNets 处理这里的每一项和之间的联系。首先使用深度可分离卷积来打断输出通道数和卷积核大小之间的关系。</p>
<p>标准的卷积操作在卷积核的基础上对特征进行过滤，并结合特征产生新的表示。滤波和组合步骤可以通过分解卷积分为两个步骤，这种分解叫做深度可分离卷积并且可以后续减少计算代价。</p>
<p>深度可分离卷积由于两层构成：深度卷积和点态卷积。使用深度卷积对每个输入通道(输入深度)应用一个简单的滤波器。点态卷积，一个简单的$1\times 1$ 卷积，用来创建深度卷积层输出的线性组合。MobileNets 对这两层都使用了batchnorm 和 ReLU非线性激活函数。</p>
<p>对每一个输入通道（输出通道）使用一个滤波器进行深度卷积可以表达为：</p>
<script type="math/tex; mode=display">
\hat{G}_{k,l,m}=\sum_{i,j}\hat{K}_{i,j,m}\cdot F_{k+i-1,l+j-1,m}</script><p>这里 $\hat{K}$ 为深度卷积核，大小为 $D_K \times D_K \times M$ , $\hat{K}$ 第 $m_{th}$ 个滤波器应用在 $F$ 的 $m_{th}$通道，并产生输出特征图 $\hat{G}$ 的第 $m_{th}$ 个通道。</p>
<p>深度卷积的计算代价为:</p>
<script type="math/tex; mode=display">
D_K \cdot D_K \cdot M \cdot D_F \cdot D_F</script><p>深度卷积相比标准卷积则非常有效。但是只是对输入的通道进行了滤波，并没有将滤波后的结果结合以产生新的特征。因此需要一个额外的层来计算深度卷积的输出的线性组合，这通过一个 $1 \times 1$ 的卷积来实现以生成新的特征。</p>
<p>深度可分离卷积的代价为：</p>
<script type="math/tex; mode=display">
D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F</script><p>即深度卷积$1\times1$点态卷积的代价总和。</p>
<p>通过将卷积表达为两个步骤（滤波和组合）可以得到计算代价的减少：</p>
<script type="math/tex; mode=display">
\begin{align}
 &\frac{D_K \cdot D_K \cdot M \cdot D_F \cdot D_F + M \cdot N \cdot D_F \cdot D_F}{D_K \cdot D_K \cdot M \cdot N \cdot D_F \cdot D_F} \notag \\ 
=&\frac{1}{N} + \frac{1}{D_K^2} \notag
\end{align}</script><p>MobileNets 使用了$3 \times 3$ 深度可分离卷积比标准卷积减少 8 到 9倍的计算量，并且精确度只有一点点的下降。</p>
<p>空间维度上的额外分解并没有减少太多的额外计算，因为深度卷积减少了很多的计算量。</p>
<h3 id="Network-Structure-and-Training"><a href="#Network-Structure-and-Training" class="headerlink" title="Network Structure and Training"></a>Network Structure and Training</h3><p>MobileNets 架构是构建在深度可分离卷积的基础上，除了第一层使用仍是全卷积。通过这样定义网络，可以更容易的探索网络拓扑结构来找到一个好的网络。MobileNets体系结构如下所示。所有层后面都有一个 batchnorm 和 ReLU 非线性激活函数，除了最终的全连接层没有非线性函数以外，全连接需要送入 softmax 层来进行分类。</p>
<p><img src="/p/9d20/MobileNets3.png" style="zoom:60%;"></p>
<p>下图对比了标准卷积配有 batchnorm 和 ReLU 非线性激活函数和深度可分离卷积。</p>
<p><img src="/p/9d20/MobileNets4.png" style="zoom:60%;"></p>
<p>下采样通过跨步卷积来处理。在全连接层之前，使用均值池化层将空间分辨率降低到1。将深度卷积和点态卷积看成独立的层，MobileNets 则有28层。</p>
<p>使用少量的 Multi-Adds 定义网络是不够的，还需要保证这些操作可以有效的实现。例如非结构化的稀疏矩阵操作通常并不会比稠密矩阵快，除非达到非常高的稀疏级别。模型结构几乎将所有的计算都放在了稠密的 $1\times 1$ 卷积中，这可以通过GEMM实现。通常卷积是由GEMM实现的，但是需要在内存中进行一个称为 im2col 的操作来将其映射到 GEMM。例如，在Caffe库中，$1\times 1$卷积并不需要预先安排内存而可以直接使用 GEMM实现，这是最优化的数学线性代数算法之一。MobileNets 使用了将近 95% 的时间用于 $1\times1$卷积计算，也有 75% 的参数如下所示。几乎所有的额外参数都在全连接层。</p>
<p><img src="/p/9d20/MobileNets5.png" style="zoom:60%;"></p>
<p>MobileNets 模型在 TensorFlow中使用 RMSprop训练，并采用了类似于 Inception V3的异步梯度下降。然而，与训练大型模型相反，模型使用较少的正则化和数据增强技术，因为小模型有较少的过拟合问题。在训练 MobileNets 时，不使用 side head和label smoothing并且限制在 large Inception training 中使用的切割尺寸，来减少图像失真。此外，还发现，在深度滤波器层中需要使用小的甚至没有权重衰减(L2 正则化)，因为他们的参数太少。对于后面的ImageNet基准测试，不管模型的大小，都是用相同的训练参数进行训练。</p>
<h3 id="WidthMultiplier-Thinner-Models"><a href="#WidthMultiplier-Thinner-Models" class="headerlink" title="WidthMultiplier : Thinner Models"></a>WidthMultiplier : Thinner Models</h3><p>尽管基本的MobileNets 体系结构已经很小，并且延迟很低，但是很多时候一个特定的用例可能会要求模型更小更快。为了构建更小的，计算成本更小的模型，引入了一个简单的参数 $\alpha$，称为宽度乘法因子。宽度乘法因子 $\alpha$ 的作用是让网络的每一层均匀的变小。对于一个给定的层和一个宽度乘法因子 $\alpha$，那么输入的通道数将会变成 $\alpha M$，输出的通道数将会变为 $\alpha N$。</p>
<p>那么深度可分离卷积的计算代价将会变成：</p>
<script type="math/tex; mode=display">
D_K \cdot D_K \cdot \alpha M \cdot D_F \cdot D_F + \alpha M \cdot \alpha N \cdot D_F \cdot D_F</script><p>这里的 $\alpha \in (0,1]$,通常设置为 1, 0.75, 0.5, 0.25。$\alpha = 1$ 为基线的 MobileNet，$\alpha &lt; 1$ 则为削减的 MobileNet。宽度乘法因子可以近似 $\alpha^2$二次降低计算成本和参数量。宽度乘法因子可以应用于任何模型结构以定义一个新的更小的模型。具有合理的精度，延迟和大小权衡。它可以用于定义新的需要从头训练的简化结构。</p>
<h3 id="Resolution-Multiplier-Reduced-Representation"><a href="#Resolution-Multiplier-Reduced-Representation" class="headerlink" title="Resolution Multiplier: Reduced Representation"></a>Resolution Multiplier: Reduced Representation</h3><p>第二个用于减少神经网络计算代价的超参数为分辨率乘法因子 $\rho$。将其应用于输入图像上，则每一层的内部表示都会随后以相同的乘法因子缩小。因此，只需要隐式的设置输入分辨率为 $\rho$  即可。</p>
<p>现在可以将网络的核心层的代价表达为具有宽度乘法因子 $\alpha$ 和分辨率乘法因子 $\rho$ 的深度可分离网络：</p>
<script type="math/tex; mode=display">
D_K \cdot D_K \cdot \alpha M \cdot \rho D_F \cdot \rho D_F + \alpha M \cdot \alpha N \cdot \rho D_F \cdot \rho D_F</script><p>这里 $\rho\in (0,1]$。通常隐式设置以使得网络的输入分辨率为 224, 192, 160, 128。$\rho = 1$ 为基线的 MobileNet。$\rho &lt; 1$ 为削减的 MobileNet。分辨率乘法因子将可以使计算代价以 $\rho^2$ 减少。</p>
<p><img src="/p/9d20/MobileNets6.png" style="zoom:60%;"></p>
<p>上表显示了结构收缩方法依次应用各个层后的计算量和参数量。输入特征图大小为 $14\times 14 \times 512$, 核大小为 $3 \times 3 \times 512 \times 512$。</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><p>首先说明深度卷积的效果，以及通过减少网络宽度而不是层的数量来进行网路压缩。然后展示了基于两个超参数：宽度乘法因子和分辨率乘法因子削减网络的权衡，然后研究了应用于不同应用程序的从MobileNets。</p>
<h3 id="Model-Choices"><a href="#Model-Choices" class="headerlink" title="Model Choices"></a>Model Choices</h3><p>首先展示了带有深度卷积网络的模型和使用完全卷积的模型的对比结果。如下表，可以看出，使用深度可分离卷积相比使用完全卷积只会在 ImageNet 上减少 1%的精确度，但是会极大的减少 Multi-adds 和参数。 </p>
<p><img src="/p/9d20/MobileNets7.png" style="zoom:60%;"></p>
<p>然后展示带有 宽度乘法因子的 thinner 模型与层数较少的浅模型的对比。为了使 MobileNets 模型更浅，Table1.中的五层独立滤波器(大小为$14 \times 14 \times 512$)被移除。下表展示了在相似的计算量和参数数量下，使MobileNets 更thinner比使其更浅的性能好 3%。</p>
<p>后面的具体实验结果建议直接看论文的图表。</p>
]]></content>
      <categories>
        <category>轻量化模型</category>
      </categories>
      <tags>
        <tag>MobileNets</tag>
      </tags>
  </entry>
  <entry>
    <title>MobileNets v2</title>
    <url>/p/cd8f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>MobileNetV2-反向残差和线性瓶颈</p>
<p>MobileNetV1 中解读了深度可分离卷积，这里不做赘述。在 MobileNetV2 中增加了两个概念(idea) : Linear Bottleneck 和 Inverted Residuals。</p>
<p>不错的解读:</p>
<ul>
<li><a href="https://blog.csdn.net/flyfish1986/article/details/97017017">https://blog.csdn.net/flyfish1986/article/details/97017017</a></li>
<li><a href="https://www.cnblogs.com/hejunlin1992/p/9395345.html">https://www.cnblogs.com/hejunlin1992/p/9395345.html</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33075914">https://zhuanlan.zhihu.com/p/33075914</a></li>
<li><a href="https://www.zhihu.com/question/265709710">https://www.zhihu.com/question/265709710</a></li>
<li><a href="https://yinguobing.com/bottlenecks-block-in-mobilenetv2/">https://yinguobing.com/bottlenecks-block-in-mobilenetv2/</a></li>
</ul>
<h2 id="Preliminaries-discussion-and-intuition"><a href="#Preliminaries-discussion-and-intuition" class="headerlink" title="Preliminaries, discussion and intuition"></a>Preliminaries, discussion and intuition</h2><h3 id="Depthwise-Separable-Convolutions"><a href="#Depthwise-Separable-Convolutions" class="headerlink" title="Depthwise Separable Convolutions"></a>Depthwise Separable Convolutions</h3><p>深度可分离卷积是许多高校神经网络架构的关键构建模块，本文也使用了这个。深度可分离卷积的基本思想就是用分解后的卷积算子替换原先的完整卷积，将卷积分成了两个独立的层。第一层为深度卷积，就是对每个输入通道进行了一个轻量化的滤波。第二个是$1\times 1$卷积，即点态卷积，用来将输入通道进行线性组合。</p>
<p>标准的卷积输入张量 $L_i(h_i\times w_i\times d_i)$, 通过应用卷积核 $K \in R^{k\times k \times d_i \times d_j}$ 产生一个 $h_i \times w_i\times d_j$ 的输出张量$L_j$，标准的卷积层的计算代价为 $h_i\times w_i \times d_i \times d_j \times k \times k$，</p>
<p>深度可分离卷积是标准卷积的直接替换，他和常规卷积性能相近，但代价只有 $h_i \times w_i \times d_i (k^2 + d_j)$，即两部分的代价和。与传统卷积层相比它有效的减少将近 $k^2$ 的代价。MobileNetV2 使用了 $k=3$ 的深度可分离卷积使得卷积代价是标准卷积的 $1/8\sim1/9$，精度只会有一点的降低。</p>
<p>这一方面可以在 MobileNets1中查阅。</p>
<h3 id="Linear-Bottlenecks"><a href="#Linear-Bottlenecks" class="headerlink" title="Linear Bottlenecks"></a>Linear Bottlenecks</h3><p>对于一个 $n$ 层的深度神经网络，每一层 $L_i$ 都有一个维度为 $h_i \times w_i \times d_i$的激活张量，(这部分主要说明这个激活张量的一些基本性质)，这可以看成一个含有 $h_i\times w_i$ 个 $d_i$ 维“像素”的容器。非正式地说，对于来自真是图像的输入集，可以说层激活体(对于任意层 $L_i$ )形成了一个<strong>“兴趣流形”</strong>。长期以来，一直假设神经网络中感兴趣的流形可以嵌入到低纬度的子空间中。换句话说，对于深度卷积层钟的所有独立的 $d$通道像素，编码在这些值中的信息实际上位于某些流形中，而这些流形则又可以嵌入到一个低维子空间中。</p>
<p>这种事实，可以通过简单地减少层的维数来获知和利用，并从而减少操作空间的维数。 MobileNetV1 利用了这一点，并通过一个宽度乘法因子有效的在计算量和精度之间进行权衡，并将其纳入其他网络中以及 ShuffleNet 中。根据这种直觉，宽度乘法因子允许人们减少激活体空间的维度，直到兴趣流体跨越整个空间。(意思就是说，假设激活体维度为 $M$, 实际上主要信息只需要 $m$ 维就可以，因此可以不断降低 $M$ 直到 $m$？)但是这种直觉似乎有点问题，因为深度神经网络中实际上都是使用的非线性的坐标变换。例如 <strong>ReLU</strong>。例如在 $1D$ 空间中对线使用 ReLU，则会产生一条射线。在 $n$ 维空间内使用，则会产生一个具有 $n$ 节点的分段线性曲线。</p>
<p>很容易的看出，如果有一层的变换 $ReLU(Bx)$ 的输出中含有一个非零体 $S$，那么 映射到 $S$ 内部中的点是通过一个线性变换获得的，也就是说，对于整个维度的输出空间，对应的输入空间的部分，是与线性变换控制的。(不好表达文章的意思，意思是说，对于输出 $M$ 维的中的非零体 $M^{\prime}$, 输入中的 $m$维，只有其中经过线性变换的 $m^{\prime}$ 部分有关，也就是说，线性变换 $B$ 决定了相关的输入，不然的话，非线性例如 <strong>ReLU</strong>，就会把一部分信息丢掉，比如 <strong>Relu</strong> 中 x &lt; 0)。换句话说，深度网络仅对非零体部分具有线性分类器的能力。</p>
<p>另一方面，当使用 <strong>ReLU</strong> 塌缩通道时，它不可避免地会导致这个通道的信息丢失。然而，如果有很多通道的时候，激活流形中可能有一个结构，其他通道的信息存储在其中。如果输入流形可以嵌入到激活空间的显著低维子空间中，那么 <strong>ReLU</strong> 变换将会在将所需的复杂性引入可表达函数集的同时保留信息。</p>
<p>总结来说，兴趣流形位于高维的激活空间中的低维子空间中：</p>
<ul>
<li>如果兴趣流形在 <strong>ReLU</strong> 后保持非零，那么它对应线性变换。</li>
<li>只有输入流形位于输入空间的低维子空间中时，<strong>ReLU</strong> 才能保留输入流形的完整信息。</li>
</ul>
<p>这对优化现有的神经网络架构进行了提示：假设兴趣流形是低维的，那么就可以通过在卷积块中添加 Linear bottleneck 层来获取它。实验表明使用线性层是重要的，这可以防止非线性破坏太多的信息(后续的实验证明了缺失会降低性能，还有一些工作，例如论文中提到的CIFAR数据集)。后面会使用 bottleneck convolutions，把输入瓶颈的大小和内部尺寸的大小的比例称为膨胀比。</p>
<h3 id="Inverted-residuals"><a href="#Inverted-residuals" class="headerlink" title="Inverted residuals"></a>Inverted residuals</h3><p>bottleneck 块类似 residual 块，每个块包含一个输入，后面是一些 bottleneck，然后是深度残差网络中的扩展块。因为 bottleneck 中包含了所有必要的信息，而扩展层仅仅作为一个实现细节伴随非线性的张量变换，因此在 bottleneck 中使用了 shortcurts。</p>
<h4 id="Running-time-and-parameter-count-for-bottleneck-convolution"><a href="#Running-time-and-parameter-count-for-bottleneck-convolution" class="headerlink" title="Running time and parameter count for bottleneck convolution"></a>Running time and parameter count for bottleneck convolution</h4><p>基本实现结构如下所示：</p>
<p><img src="/p/cd8f/MobileNetsv2-2.png" style="zoom:60%;"></p>
<p>对于一个大小为 $h\times w$ 的块，扩展因子为 $t$，核大小为 $k$， 输入通道数为 $d^{\prime}$, 输出通道数为 $d^{\prime\prime}$。总共的乘加计算为 $h \cdot w \cdot d^{\prime} \cdot t(d^{\prime} + k^2 + d^{\prime\prime})$。表达式中有一个额外的项，因为有一个额外的 $1\times 1$卷积，但是网络的性质允许使用更小的输入和输出维度。不同分辨率下的 MobileNetV1， MobileNetV2, ShuffleNet 对比如下。</p>
<p><img src="/p/cd8f/MobileNetsv2-3.png" style="zoom:80%;"></p>
<h3 id="Information-flow-interpretation"><a href="#Information-flow-interpretation" class="headerlink" title="Information flow interpretation"></a>Information flow interpretation</h3><h2 id="Model-Architecture"><a href="#Model-Architecture" class="headerlink" title="Model Architecture"></a>Model Architecture</h2>]]></content>
      <categories>
        <category>轻量化模型</category>
      </categories>
      <tags>
        <tag>MobileNets</tag>
      </tags>
  </entry>
  <entry>
    <title>SqueezeNet</title>
    <url>/p/92ec.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>个人觉得没啥卵用。。。</p>
<h2 id="。。。"><a href="#。。。" class="headerlink" title="。。。"></a>。。。</h2><h2 id="SqueezeNet-Preserving-accuracy-with-few-parameters"><a href="#SqueezeNet-Preserving-accuracy-with-few-parameters" class="headerlink" title="SqueezeNet: Preserving accuracy with few parameters"></a>SqueezeNet: Preserving accuracy with few parameters</h2><h3 id="Architectural-Design-Strategies"><a href="#Architectural-Design-Strategies" class="headerlink" title="Architectural Design Strategies"></a>Architectural Design Strategies</h3><p>主要目标是构建参数较少的 CNN 模型架构，但是仍保持不错的精度。为此，使用了三个主要策略。</p>
<ul>
<li><p>策略 $1$ : 使用 $1 \times 1$ 过滤器替换 $3 \times 3$ 过滤器。给定一定数量的卷积滤波器预算，这大部分的滤波器将使用 $1\times 1$ 大小，因为 $1\times 1$ 滤波器将比 $3 \times 3$ 滤波器减少了九倍的参数。</p>
</li>
<li><p>策略 $2$ : 减少输入到 $3 \times 3$ 滤波器的输入通道数。对于一个只包含 $3\times 3$ 滤波器的卷积层，这一层的参数总数等于</p>
<p>(number of channels)  <em> (number of filters) </em> (3 * 3)。因此，为了保持 CNN 中较少的参数总数，不仅要减少$3\times 3$滤波器的个数，还需要减少输入的通道数。后面使用 squeeze layers 来减少输入到滤波器的输入通道数。</p>
</li>
<li><p>策略 $3$ : 在网络的后期进行下采样，使卷积层有较大的激活图。在卷积网络中，每个卷积层产生一个输出激活映射，其空间分辨率至少为 $1\times 1$，并且通常大于 $1 \times 1$。这些激活映射图的宽和高由 (1) 输入数据的大小，(2) 在CNN中选择用哪些层来做下采样。常见的是，通过在 CNN 结构的一些卷积层或者池化层设置步长 (stride &gt; 1)。如果网络前面的层有较大的步长，那么大部分的激活层就会很小。相反地，如果网络中大部分的层的步长为 $1$, 并且步长大于 $1$ 的层都集中在网络末端，那么网络中的大部分层就会有大的激活图。在其他条件不变得情况下，直觉上看，大的激活图将会导致更高的分类精度。</p>
</li>
</ul>
<p>策略$1,2$ 是明智得减少 CNN 中得参数数量，并试图保持准确率。策略 3 是在有限的参数预算下最大化准确性。</p>
<h3 id="The-Fire-Module"><a href="#The-Fire-Module" class="headerlink" title="The Fire Module"></a>The Fire Module</h3><p>定义 Fire 模块。一个 Fire 模块包含一个 squeeze convolution layer，然后被送到一个 expand layer, 或者扩展层包含了 $1\times1$ 和 $3\times 3$ 两种卷积核。如下图所示。</p>
<p><img src="/p/92ec/SqueezeNet2.png" style="zoom:50%;"></p>
<p>在 Fire 模块中提供了三个可调的维度(超参数)： $s_{1x1},e_{1x1},e_{3x3}$。 $s_{1x1}$是 squeeze layer中的 $1\times1$ 滤波器个数，$e_{1x1}$ 是 expand 层中的 $1\times1$ 滤波器个数，$e_{3x3}$ 是 expand 层中的 $3\times3$ 滤波器个数。在使用 Fire 模块时，设定了 $s_{1x1} \lt (e_{1x1},e_{3x3})$， 因此 squeeze layer 将有助于减少输入到 $3\times 3$ 的输入通道数。</p>
<h3 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h3>]]></content>
      <categories>
        <category>轻量化模型</category>
      </categories>
      <tags>
        <tag>SqueezeNet</tag>
      </tags>
  </entry>
  <entry>
    <title>C++ &amp; STL</title>
    <url>/p/d937.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="C-amp-STL-等相关整理"><a href="#C-amp-STL-等相关整理" class="headerlink" title="C++ &amp; STL 等相关整理"></a>C++ &amp; STL 等相关整理</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="using"><a href="#using" class="headerlink" title="using"></a>using</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> ... = ...;</span><br><span class="line"><span class="comment">// example</span></span><br><span class="line"><span class="keyword">using</span> ll = <span class="keyword">long</span> <span class="keyword">long</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br></pre></td></tr></table></figure>
<p>在语法的别名声明，using的使用类似于typedef，但用法更为精妙。</p>
<h3 id="string"><a href="#string" class="headerlink" title="string"></a>string</h3><h4 id="stoi"><a href="#stoi" class="headerlink" title="stoi"></a>stoi</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> string&amp;  str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stoi</span> <span class="params">(<span class="keyword">const</span> wstring&amp; str, <span class="keyword">size_t</span>* idx = <span class="number">0</span>, <span class="keyword">int</span> base = <span class="number">10</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>stoi()的输入要不为空，否则可以使用atoi(().c.str())</p>
<h4 id="sstream"><a href="#sstream" class="headerlink" title="sstream"></a><a href="https://www.cplusplus.com/reference/sstream/">sstream</a></h4><p>istringstream类用于执行C++风格的字符串流的输入操作，支持&gt;&gt;;</p>
<p>ostringstream类用于执行C++风格的字符串流的输出操作，支持&lt;&lt;；</p>
<p>stringstream类同时可以支持C++风格的串流的输入输出操作，同时支持&gt;&gt;和&lt;&lt;；</p>
<p>即 stringstream = istringstream + ostringstream。</p>
<h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><p><a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/22/2603525.html">不错的博客链接</a></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>syntax</tag>
      </tags>
  </entry>
  <entry>
    <title>Internal Covariate Shift &amp; Normalization</title>
    <url>/p/6d2e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://zhuanlan.zhihu.com/p/33173246">参考链接1</a></p>
<p><a href="https://blog.csdn.net/sinat_33741547/article/details/87158830">参考链接2</a></p>
<h2 id="Interal-Covariate-Shift"><a href="#Interal-Covariate-Shift" class="headerlink" title="Interal Covariate Shift"></a>Interal Covariate Shift</h2><blockquote>
<p>The term <strong>interal covariate shift</strong> comes from the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a>.</p>
<p>The authors’ precise definition is:</p>
<blockquote>
<p>We define Internal Covariate Shift as the change in the distribution of network activations due to the change in network parameters during training.</p>
</blockquote>
<p>In neural networks, the output of the first layer feeds into the second layer, the output of the second layer feeds into the third, and so on. When the parameters of a layer change, so does the distribution of inputs to subsequent layers.</p>
<p>These shifts in input distributions can be problematic for neural networks, especially deep neural networks that could have a large number of layers.</p>
<p><a href="https://machinelearning.wtf/terms/batch-normalization/">Batch normalization</a> is a method intended to mitigate internal covariate shift for neural networks</p>
</blockquote>
<p>简单的说，Interal Covariate Shift(后面简称ICS)是在网络训练过程中，由于前面层中的网络参数不断更新而导致的网络输入的分布不均匀的现象。网络层的序列化意味着后续网络的输入为前面网络的输入，而由于网络参数的更新，对于原始相同的输入，其经过每一层后的输出都会变化。</p>
<p>机器学习的一个重要假设就是数据的<strong>独立同分布(Independent and identically distributed，后面简称为iid)</strong>，<del>虽然这并不可能</del>。即使做不到idd，实际上很多机器学习的算法，例如<strong>逻辑回归</strong>，<strong>神经网络</strong>以然可以在非iid的数据上训练得到不错的数据，但很明显，iid可以简化模型训练，加快训练和提升预测能力。对这个概念的理解可以参考统计机器学习中的<strong>Covariate Shift</strong>，从概率的角度上就是，条件概率相同，但边缘概率不同，<del>甚至更难理解了。</del>再赘述一句理解的话，网络加深，网络参数不断更新，经过多次线性或者非线性变化，对于其中的某一层(不要抬杠的选第一层)，它得到的输入都不一样的，即便在第一层输入相同的数据，但是最终的分类标签却还是一致的，那么这些数据就不再是iid了。</p>
<p>这会导致一些问题：</p>
<ul>
<li>前面的网络需要不断的适应新的输入数据，降低学习率</li>
<li>后面的网络的输入的变化可能导致前面的网络陷入饱和区，训练过早停止</li>
<li>既然每层的更新是会直接或间接影响到其他层的，那么每一层的学习策略就不能那么“随意”，应该非常的”谨慎“，实际上，这种”谨慎“也不是那么可控的。</li>
</ul>
<h2 id="Whitening"><a href="#Whitening" class="headerlink" title="Whitening"></a>Whitening</h2><p>为了得到iid的数据，因此在数据送入模型之前，会经过数据预处理阶段，因此白化的目的就在于得到iid的数据。</p>
<ul>
<li>去除特征之间的相关性—&gt; 独立；</li>
<li>使得所有特征具有相同的均值和方差 —&gt; 同分布</li>
</ul>
<p>PCA就是一种典型的方法。<a href="http://ufldl.stanford.edu/tutorial/unsupervised/PCAWhitening/">PCA Whitening</a></p>
<h2 id="Normalization"><a href="#Normalization" class="headerlink" title="Normalization"></a>Normalization</h2><p>但是，白化的计算成本太高，于是有了normalization方法，可以简化计算过程，又可以使数据尽可能保留原始的数据表达能力。normalization这种方式，实际上并不是直接去解决ICS问题，更多的是面向梯度消失等问题，去加速网络收敛的。而且，均值方差相等与同分布不是一个概念。</p>
<h3 id="Normalization-Framework"><a href="#Normalization-Framework" class="headerlink" title="Normalization Framework"></a>Normalization Framework</h3><script type="math/tex; mode=display">
\hat{x} = f(g*\frac{x-\mu}{\sigma} + b) \notag</script><p>通常的变换框架如上所示，实际上就是做了个shift和缩放转换到(0,1)正态分布，随后再进行reshift和rescale，最终转换成了 ($b$, $g^2$) 的分布。这里的reshift和rescale参数是可以学习的，而不是固定的(0,1)，很显然，因为输入范围本身就不可能确定为(0,1)，可学习的re参数也更符合底层的学习能力。</p>
<p>与白化相比，实际差距还是很大的。</p>
<h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><img src="https://pic1.zhimg.com/80/v2-13bb64b6122e98421ea3528539c1bffc_720w.jpg" alt></p>
<p>其规范化针对单个神经元进行，利用网络训练时一个 mini-batch 的数据来计算该神经元 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> 的均值和方差,因而称为 Batch Normalization。</p>
<p><img src="/p/6d2e/ICSN1.png" style="zoom:50%;"></p>
<p>BN 可以看做一种纵向的规范化。由于 BN 是针对单个维度定义的，因此标准公式中的计算均为 element-wise 的。</p>
<p>BN 独立地规范化每一个输入维度 <img src="https://www.zhihu.com/equation?tex=x_i" alt="[公式]"> ，但规范化的参数是一个 mini-batch 的一阶统计量和二阶统计量。这就要求 每一个 mini-batch 的统计量是整体统计量的近似估计，或者说每一个 mini-batch 彼此之间，以及和整体数据，都应该是近似同分布的。分布差距较小的 mini-batch 可以看做是为规范化操作和模型训练引入了噪声，可以增加模型的鲁棒性；但如果每个 mini-batch的原始分布差别很大，那么不同 mini-batch 的数据将会进行不一样的数据变换，这就增加了模型训练的难度。</p>
<p>因此，BN 比较适用的场景是：每个 mini-batch 比较大，数据分布比较接近。在进行训练之前，要做好充分的 shuffle. 否则效果会差很多。</p>
<p>另外，由于 BN 需要在运行过程中统计每个 mini-batch 的一阶统计量和二阶统计量，因此不适用于动态的网络结构 和 RNN 网络。</p>
<h3 id="Layer-Normalization"><a href="#Layer-Normalization" class="headerlink" title="Layer Normalization"></a>Layer Normalization</h3><p><img src="https://pic1.zhimg.com/80/v2-2f1ad5749e4432d11e777cf24b655da8_720w.jpg" alt></p>
<p>LN 针对单个训练样本进行，不依赖于其他数据，因此可以避免 BN 中受 mini-batch 数据分布影响的问题，可以用于小mini-batch场景、动态网络场景和 RNN，特别是自然语言处理领域。此外，LN 不需要保存 mini-batch 的均值和方差，节省了额外的存储空间。</p>
<p>但是，BN 的转换是针对单个神经元可训练的——不同神经元的输入经过再平移和再缩放后分布在不同的区间，而 LN 对于一整层的神经元训练得到同一个转换——所有的输入都在同一个区间范围内。如果不同输入特征不属于相似的类别（比如颜色和大小），那么 LN 的处理可能会降低模型的表达能力。</p>
<h3 id="Instance-Normalization"><a href="#Instance-Normalization" class="headerlink" title="Instance Normalization"></a>Instance Normalization</h3><p><img src="/p/6d2e/ICSN2.png" style="zoom:50%;"></p>
<p>IN适用于生成模型中，比如图片风格迁移。因为图片生成的结果主要依赖于某个图像实例，更适合对单个像素有更高要求的场景。</p>
<h3 id="Group-Normalization"><a href="#Group-Normalization" class="headerlink" title="Group Normalization"></a>Group Normalization</h3><p><img src="/p/6d2e/ICSN3.png" style="zoom:50%;"></p>
<p>Kaiming He的论文中以图片的形式说明了四个的区别，Group介于IN和LN之间。</p>
<p>WN和CN跳过。</p>
<p>Normalizaiton的有效性可以参考文前的参考链接。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>Normalization</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora+Gitee 图床</title>
    <url>/p/377e.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="c2f6eb897c6897d6f5a2777268a36b524acb76fb396ee010884624c2f72b57cf">6313153f3df6eb6824c31dfc042073d9ccfefb92f71156eeed8cf0d6e89f9af1cd917535561d8f7748a723ec5e29befbd4bd7c9480eb6ba12c94adfe891e68aa2376551a2485a887db394b3da1830e8ca8bca6ee66097e06472db890ea93692948fad949a522269b58509224655e29d8c3fd5e5ef12dffc08e694dcacaeb304bbfdc9a3f2d300af5e4c2d73670a83f2eb307d462f4941db179b3dd8dfdff505f4f9d01f855be7e4d3df50ed64a3d579245c2cfae34d3468458fb55b29180c5e1ba43ae523b8d5ddfec1c34f226a4eb60c3764edd53b6709484fedcc923468f2eada4bf783f87289abf833b2ddb558ca5ae584df78052f9b4d1b41492b99a9d7e9b90ebe2b1613bff16c3d6b9bc2167cea0890b1375b4d2ae3070a54a60cd9c17ca98bcbf10416090e789a9384fde250d125dcf89146c61db5834ae6302880b2d5a0c90bb3c58d3833dac246e4f983274db975a398c350d869b4d33173261ad3138e7b0ac7c190e25e139f7f3b108b1a3db0f5d3495d5a53e616c3f168e3ca87fc5ae2443bd22cacaa8760cbe878f8a0a80304d87e800c9e75a41cdd5eb423eee9787cb3dce3ccc99675fc897d40a658c8f29d29121da1b157b2df098f58bdc94e9f8c74e7537cf77e8539bb7d4451105d245dd3fe5113f638cfcfc1abdbe477c86a5ebc51beb76c6d8e72839a19d9783532201a439d5214d414484f973a816e58988467fff68714db982f967457377be0d444d6a0de22e7cfa55be62ca4ee3dc5e6edc75b8cc84217a28e49d209e27343a39e76cb8ac360f0c285cdb096a5514fe4e18a3c79423a1515cf7e6bb1c9d66971a7a2a94fbe6e9d5e477147ea7c958c1d9e3ea403c95f35a868765fce7495b506ff269e1dc79f23e8637024572d7cb5aac36aeb792d92064c97e8e87793dfb65662410442cf6cbf231c3a697ab923a8da8124c80e21488f417db05008e3316f01cccfec1404f0d5176ded4d8db0af79f0b0547e2421ddf3b0e61b22795d8d33919c08807f90534a9746df32aa06c640a0a25852ba5e78d0a07540c04aa4d2ddf486a5076a93feb58029c22a8f7d52fc6eb54973f7879b848d03db98374f01fbbe55416ecf5b58dcc6d0e296a09acdc7e2beb0bc48114fb69577e6fb1269b5e2b5e43bbc17ec43b3b59dc6107cc3982a6450685be9bf7060f822fefa0fffa6977ca32cc032cc710fe5142fb840854e356082090d9e6b588eb7f4b510400ae17e59a34cce3ee2e3c6511f9f0cfca7b093ddbbdbe1ad9df861b7935537f2a19663e8f029c37e8dc6df06ce1f569bf3a27ebbe44b1b9545dce92bacdfe7c31b53af23ad119260ed0584b944f42aa32f54559495c9051274001dcb59debbfdd63f4b44f95ff2e6cd72117eb31cd3d57c2e6ee3c0581986013f61a660543f70f6f045e42446ef8a28a8f9ee960e36ee227a5fa15675808b78d5a04777a2677e68b7698d965cde6c2ef70d0a69e7fe99b00d0ab8cc1c6309555b8eea7970dea27d46ed4bb40163eec232ec63e1bb33ace76416de008df4f7758549d9a3983a31f9adc3c4484b26e368e536ed4f78c812f871c8fbb6f04d6676e885e916f55d4ef0ed04440fb3adb75d1bea7ac39c34740f7dd8820f20fa8d3ca8ce5ab13988d747e6ac4e72963e9cbba0aa9bd25d5c466b6dbb5b2476536e9984b9e13113a3842c23e57f75faf645722783140e16253f98a9e23875c0d5d59f33a3af3d5b664bbee23740e6c6b2cdc8a8be015b674146ae82582e25b539f1857bf52374b84e4c98f5caa99c3096090859848fb58d30a5290f1f5b21b268e8c0ba9cdcbff14d5f9b4d3d6e198e72776ecb6bdcc47b6126a5f4a878fad11c0699811d9bdda501d428ef4130ea46c034f22299f68b8388cc62a0fab58f726e2ff8052abd7976701043f56e258675036ae13663c88ad2caaece150b83e86c1b69b326179726c85532ba215925afb6fab972e3e9486cb52929dbfe2da9706373a7ba81164785872fd0ff847d5ba956a37db82585993d08c227ef1cfdc720cae86932714926d9a687db8ced69ff23edfa6382d8f698b0e258871cc63d1982af48bd8a85b5cdd9fd74d1ed9557390051dd4e5e87ada1f7a6fb13998461f81ce9dadeab6b9345adc6f0ce6022c2009e97fdd892832e3397c6b0e2351533a938554f91800f38533d8b3ff409a6adc540eec14755e713cb99a93ad7af2308b381a56d129c8d7686aef93d39dd9e2e546ecbbea1dc1769deb3720f1a2fe2da03bc08ac0ae545cb2799ab0a7ca73bc9cfed7e5fdbfe77180d868a79c09e58f6c2ad86c3dba4b6fbe5490f6048fc4861880b24df28d9908ac1c1a74de6cf85313cf3383f824b4f70224b05e4301984e2dadfa775d35ba5b73ec318c164aaaeb98049f1670c47f4e838d22848483da9ba5cc6353b794172f86cff91b085282be1787945294ec2439349ef891af93ae1d96bcc644c86b4e994192e38322936d36c7159cd85d7a4b167429f6e0186fd9ef3a3415ff1b2d60c88ced0398d320a102958b8668f25ade756992fdb7dc4457b9d121611280e5ad858253f9c837a0feb2594fe4e0f45dc004f465ff70aa987d6b</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      <categories>
        <category>配置</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Devon</title>
    <url>/p/5a3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>用于学习光流的可形变体网络</p>
<h2 id><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
      <categories>
        <category>光流</category>
      </categories>
      <tags>
        <tag>双帧光流</tag>
      </tags>
  </entry>
  <entry>
    <title>FastFlowNet</title>
    <url>/p/a2c4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>代码开源了个寂寞，不过无所谓，只是看看他做了什么而已。<a href="https://github.com/ltkong218/FastFlowNet">官方链接</a></p>
<p>非常 amazing 的地方在于 FastFlowNet 只包含 1.37M 的参数，并且 fps 很不错。</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>FastFlowNet 仍然使用了广泛应用的 coarse-to-fine 策略，此外还有以下几个创新点。</p>
<ul>
<li><p>使用了一个 head enhanced pooling pyramid (HEPP) 特征提取器，在减少参数的同时增强了高分辨率的金字塔特征。</p>
</li>
<li><p>引入了一个 center dense dilated correlation (CDDC)层 用于构建紧凑的代价体，并且可以保持较大的搜索半径下减少计算量。</p>
</li>
<li><p>在每个金字塔层中植入了一个有效的 shuffle block decoder (SBD) 用于加速光流估计，不过边缘精度有所下降。但是相比同样精度的网络，只需要 $1/10$ 的计算量。</p>
</li>
</ul>
<p>FastFlowNet 只含有1.37M 个参数，对于一个分辨率为 $1024\times436$ 的Sintel图片，在单个 GTX 1080Ti 下可以做到 90 FPS，嵌入JetSon TX2 GPU 可以做到 5.7 FPS。</p>
<h2 id="INTRODUCTION-amp-amp-RELATED-WORK"><a href="#INTRODUCTION-amp-amp-RELATED-WORK" class="headerlink" title="INTRODUCTION&amp;&amp; RELATED WORK"></a>INTRODUCTION&amp;&amp; RELATED WORK</h2><p>这部分说的很牛逼，后面写论文可以参考。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><h3 id="OverView-of-the-Approach"><a href="#OverView-of-the-Approach" class="headerlink" title="OverView of the Approach"></a>OverView of the Approach</h3><p><img src="/p/a2c4/FastFlowNet1.png" style="zoom:80%;"></p>
<p>给定两个时间域相邻的输入图片$I_1,I_2 \in \mathbb{R}^{H \times W \times 3}$, 提出的 FastFlowNet 模型将会利用由粗到细的残差结构来逐渐估计精化后的光流 $F^{l} \in \mathbb{R}^{H^l \times W^l \times 2}, l = 6,5,\cdots,2.$ 但是通过修改去减少参数和计算代价来加速推理。为此，首先替换了 PWC-Net 网络中的对偶卷积特征金字塔为 头增强的池化金字塔 (head enhanced pooling pyramid) 来增强高精度分辨率的金字塔特征和减少模型的尺寸。在此基础上，提出了一种新得中心密集扩张相关层(center dense dilated correlation layer)，在保证大的搜索半径得前提下，构造紧凑得代价体。最后，在每个金字塔层使用新的shuffle 块译码器 (shuffle block decoders) 来回归计算光流。模型的结构细节如下所示。</p>
<p><img src="/p/a2c4/FastFlowNet2.png" style="zoom:60%;"></p>
<p>Pool: average pooling</p>
<p>Fconv5_2, Fconv5_3, Fconv5_4: convolutions with group = 3</p>
<p>Shuffle: channel shuffle operation</p>
<p>除了 upconv6 和 fconv5_7 的卷积层都后接 LeakyRELU 激活函数</p>
<h3 id="Head-Enhanced-Pooling-Pyramid"><a href="#Head-Enhanced-Pooling-Pyramid" class="headerlink" title="Head Enhanced Pooling Pyramid"></a>Head Enhanced Pooling Pyramid</h3><p>传统的方法在光流估计上应用图像金字塔来加速优化和处理大尺度位移。SpyNet 转换这种经典的范式并首次引进了基于图像金字塔的池化用于加深模型。因为原始图像对光影变换时敏感的，因此固定的池化金字塔对噪声，例如阴影和反射等是不足的。PWC-Net， LiteFlowNet,使用可学习的特征金字塔替代图像金字塔，带来了很大的改进。具体地说，在减少空间尺寸的同时逐步扩张特征通道数来提取鲁棒的匹配特征。</p>
<p>低分辨率下的较大的通道数会导致大量的参数，对于由粗到细的方案来说可能是冗余的，因为低层的金字塔特征可能只会对估计粗糙的流域有用。因此，模型结合了高层的特征金字塔结构和低层的池化金字塔兼顾两个优势。另一方面，高分辨率下的金字塔特征在PWC-Net中相比较浅，因为每个金字塔层只包含两个卷积核大小为 $3 \times 3$ 的卷积层，因此其感受野较小。因此模型花费了一点额外代价在高层添加了一个额外的卷积层来增强金字塔特征。通过平衡不同尺度下的计算，文章提出了HEPP，和 FlowNetC, PWC-Net 和 LiteFlowNet 一样， HEPP会生成 6个金字塔层从 $1/2$ 分辨率(第一层) 到 $1/64$ 分辨率(第六层)，缩放因子为 2。</p>
<h3 id="Center-Dense-Dilated-Correlation"><a href="#Center-Dense-Dilated-Correlation" class="headerlink" title="Center Dense Dilated Correlation"></a>Center Dense Dilated Correlation</h3><p>现代的光流估计架构中的一个重要的步骤就是通过基于卷积层的内积来计算特征一致性。对于金字塔 $l$ 层的两个特征 $f^l_1, f^l_2$ ，类似很多由粗到细的残差方法，首先使用了基于 warping 的双线性插值，根据 $2\times$前面的流场的上采样的结果 $up_2(F^{l+1})$ 对第二个特征 $f^l_2$ 进行 warp。warp 的目标特征 $f_{warp}^l$ 可以极大的减少由于大尺度运动带来的位移，这将有益于减少搜索区域和简化任务为估计相对较小的残差流。最近的工作 PWC-Net，LiteFlowNet 通过在局部方形区域内相关源特征和对应的warped后的目标特征构建代价体，可公式化为：</p>
<script type="math/tex; mode=display">
c^l(x,d)=f^l_1(x)\cdot f_{warp}^l(x+d)/N, d\in [-r, r] \times[-r, r]</script><p>$x, d$ 代表空间和偏移坐标，$N$ 为输入特征的长度，$r$ 为搜索半径，$\cdot$ 代表点积。</p>
<p>已有的工作PWC-Net等已经表明，在构建代价体时增加搜索半径可以在训练和测试中降低 EPE 误差，尤其对于大位移的情况。但是代价体的特征通道时搜索半径的平方级，后续的解码器网络的计算复杂度将会变成四次方。</p>
<p><img src="/p/a2c4/FastFlowNet3.png" style="zoom:60%;"></p>
<p>如图 $a$，很多的光流网络设置 $r = 4$，庞大的计算量阻碍了低功耗应用的发展。一种简单的方法就是减小半径  $r$。例如设置 $r = 3$， 如图 $b$。从而使代价体特征从 81 减少到 49. 但是这种办法的代价是牺牲了感知范围和精度。</p>
<p>受到 DeepLabv3 的 atrous spatial pyramid pooling(ASPP) 的启发，提出了CDDC层在大运动区域内下采样网格点时，在中心周围密集搜索格点，如图 $c$ 所示。</p>
<p>与 ASPP 使用并行 atrous 卷积来获取多尺度上下文信息不同，提出的 CDDC 旨在减少构建大半径代价体时的计算量。在 FastFlowNet 中，会输出 53 个特征通道，与传统的 $r=3$ 设置类似。动机在于残差流会更关注小运动。实验证明 CDDC 方法比传统的压缩方法更优。</p>
<h3 id="Shuffle-Block-Decoder"><a href="#Shuffle-Block-Decoder" class="headerlink" title="Shuffle Block Decoder"></a>Shuffle Block Decoder</h3><p>在构建代价体后，由粗到细的模型通常会将上下文特征，代价体量和上采样的前一个光流结果 concatenate起来，作为后面解码器的输入。在每一个金字塔层，解码器会占用整个网络的大部分参数和计算量。因此，更好的速度和精度的权衡时至关重要的。</p>
<p>PWC-Net表明，稠密连接的流解码器在对 FlyingThing3D 数据集进行微调后，可以提高解码器的精度，但代价是增加了模型大小和计算量。LiteFlowNet 使用了顺序连接的流估计器，并且显示出了更好的性能。为了达到两种方案的权衡，FDFlowNet使用了部分全连接结构。这些方法都不能在嵌入式系统中进行实时的推理。</p>
<p>由于 CDDC 构建的紧致代价体，可以直接将解码器网络的最大通道数从 128 减少到 96个。为了进一步减少计算量和模型的大小，将中间的三个96通道的卷积转换为组卷积，然后进行通道 shuffle 操作，称之为 Shuffle Block。与ShuffleNet 作为骨干网络不同的是，shuffle 译码器用于光流的回归。</p>
<p>每个解码器网络包含了三个 $group = 3$ 的 shuffle 块，这有效的减少了计算量，但是精度略有下降。</p>
<h3 id="Loss-Function"><a href="#Loss-Function" class="headerlink" title="Loss Function"></a>Loss Function</h3><p>由于 FastFlowNet 采用了 和 FlowNet 和 PWC-Net 相同的金字塔结构，因此采用了同样的多尺度 $L2$ 损失函数用于训练。</p>
<script type="math/tex; mode=display">
L_{epe}=\sum_{l = 2}^6\alpha_l\sum|F^l(x)-F^l_{gt}(x)|_2</script><p>这里 $|\cdot|_2$ 计算预测光流和真实光流之间的 $L2$ 范数。</p>
<p>在有真实场景结构的数据集上进行微调时，例如 KITTI 数据集，使用了如下的鲁棒损失函数:</p>
<script type="math/tex; mode=display">
L_{robust}=\sum_{l=2}^6\alpha_l\sum(|F^l(x)-F^l_{gt}(x)|+\epsilon)^q</script><p>这里的 $|\cdot|$ 表示 $L1$ 范数，$\epsilon = 0.01$ 表示一个很小的常数，$q \lt 1$ 使的对大的异常值更加鲁棒。为了与以前的方法(FlowNet, SPyNet, PWC-Net, LiteFlowNet)公平对比，将公式(2)(3)中的权重设置为$\alpha_6=0.32,\alpha_5=0.08,\alpha_4=0.02,\alpha_3=0.01,\alpha_2=0.005$.</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Implements-Details"><a href="#Implements-Details" class="headerlink" title="Implements Details"></a>Implements Details</h3><p>为了将 FastFlowNet与其他网络进行对比，遵循了 FlowNet2 中提出的两阶段训练策略。真实的光流值除以20，并且下采样作为不同层的监督信号。由于最终的预测的分辨率为 $1/4$ ,因此使用了双线性插值来获得全分辨率的光流。在训练和调试阶段，使用了和 FlowNet 同样的数据增强方式，包括镜像翻转，平移，旋转，缩放，挤压和颜色抖动。实验在PyTorch环境下实现，并且在装有 4 张 Nvidia GTX 1080 Ti GPU卡的机器上进行。为了比较不同的光流模型在移动设备上的性能，进一步在嵌入式的Jetson TX2 GPU上测试了推理时间。</p>
<p>首先在 FlyingChairs 数据集上训练，使用 $S_{short}$ 学习计划。初始学习率为 $1e^{-4}$，并在30w, 40w, 50w次迭代的时候衰减一半。在数据增强阶段随机裁剪出 $320 \times 448$ 的 patch，并采用 $batch-size = 8$ 。模型在 FlyingThings3D 数据集上进行微调，并采用 $S_{fine}$ 学习计划。学习率初始化为 $1e^{-5}$, 并且在 20w, 30w, 40w迭代的时候衰减一半。随机切割尺寸为 $384 \times 768$，并且 $batch-size = 4$。 使用 $Adam$ 优化器和多尺度的 $L2$ 损失函数。在 Sintel 和 KIITI 的训练集结果如下所示。</p>
<p><img src="/p/a2c4/FastFlowNet4.png" style="zoom:60%;"></p>
<h3 id="Ablation-study"><a href="#Ablation-study" class="headerlink" title="Ablation study"></a>Ablation study</h3><p>暂时略，需要时再补充</p>
<h3 id="MPI-Sintel"><a href="#MPI-Sintel" class="headerlink" title="MPI Sintel"></a>MPI Sintel</h3>]]></content>
      <categories>
        <category>光流</category>
      </categories>
      <tags>
        <tag>双帧光流</tag>
      </tags>
  </entry>
  <entry>
    <title>SCV</title>
    <url>/p/1f41.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><a href="https://github.com/zacjiang/scv">代码已开源</a></p>
<p>RAFT outperforms other approaches by first calculating all-pairs similarity and then performing iterations at a high resolution.The price is that it inurs significantly larger computation burden.(FastFlowNet)</p>
<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>SOTA的光流估计网络需要高分辨率下的稠密的Correlation Volume来衡量逐像素的位移，虽然稠密的Correlation Volume有助于准确的光流估计，但是繁重的计算和内存使用也不利于模型的训练和部署。这篇论文说明了稠密的Correlation Volume表示是冗余的，只需要其中的一小部分元素就可以实现精确的光流估计。在此基础上，论文提出了一个可以替代的位移表示方法—Sparse Correlation Volume，通过直接计算fmap1在fmap2上最接近的k个匹配来构建，并存储在一个稀疏的数据结构中。实验说明了该方法可以显著降低计算成本和内存占用，并且依然保持较高的精度。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>基于直觉：img1的某一个特征向量只会与img2的某一部分特征向量高度相关，因此在稠密的Correlation Volume表示中，会有大量的冗余，对于相关度较小的特征并不会优化预测结果。如下图所示。</p>
<p><img src="/p/1f41/SCV1.png" style="zoom:60%;"></p>
<p>论文提出了Sparse Correlation Volume 表示，只有每个像素的top-k的相关值会被存储在稀疏数据结构中，就是个键值对—（{value, coordinates}）。</p>
<h2 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h2><p>记 $I_1, I_2: \mathbb{Z}^2 \rightarrow \mathbb{R}^3$ 为两张RGB图像，待解决的问题就是估计稠密的流场 $f:\mathbb{Z}^2\rightarrow\mathbb{R}^2$，映射每个像素x到其位移向量$f(x)$。</p>
<p>现在的深度学习光流估计方法，首先会对图像对进行特征提取得到图像的feature map $F_1,F_2:\mathbb{Z}^2\rightarrow\mathbb{R}^c$，这里的 $c$ 为通道数，Correlation Volume $C : \mathbb{Z}^4 \rightarrow R$ 由特征向量直接的点积得到。</p>
<script type="math/tex; mode=display">
C(x,d)=F_1(x)\cdot F_2(x + d).</script><p>输出为一个四维的张量，可以表示为集合:</p>
<script type="math/tex; mode=display">
\mathcal{C}=\{C(x,d)|x\in \mathcal{X}, d \in \mathcal{D}\}.</script><p>这里， $\mathcal{X} = [0, h<br>) \times[0, w) \cap \mathbb{Z}^2$ 为 feature map $F_1$ 的域， $|\mathcal{X}| = hw$ ，其中的 $h$, $w$ 分别为 $F_1$的 $height$ 和 $width$。$d$ 为 $x$ 方向或者 $y$  方向上的最大位移量，并且有 $|\mathcal{D}| = (2d+1)^2$，因此，Correlation Volume $\mathcal{C}$ 中含有 $hw(2d+1)^2$的元素。</p>
<p>为了降低Correlation Volume的尺寸，以前的方法使用了由粗到细的策略，然后对有限的d进行warping操作，为了精确处理大位移的问题，RAFT构建了全局的Correlation Volume，当然，位移的范围d受到feature map的大小限制。RAFT的Correlation Volume包含了 $N^2$ 的元素，这里的 $N = hw$。论文中将空间复杂度从 $O(N^2)$  降低到了 $O(Nk)$，具体 如下图所示。</p>
<p><img src="/p/1f41/SCV2.png" style="zoom:60%;"></p>
<h3 id="Sparse-Correlation-Volume"><a href="#Sparse-Correlation-Volume" class="headerlink" title="Sparse Correlation Volume"></a>Sparse Correlation Volume</h3><p>对于 $x\in \mathcal{X}$, 定义集合 $S_x^{(k)}$包含 $k$个产生最大相关值的位移:</p>
<script type="math/tex; mode=display">
S_x^{(k)} = {\arg \max}_{S \subset \mathcal{D},|S|=k}\sum_{d\in S}C(x,d)</script><p>则Correlation Volume可以表示为一个四维的稀疏张量:</p>
<script type="math/tex; mode=display">
\tilde{\mathcal{C}}=\{C(x,d)|d \in S_x^{(k)},x \in \symcal{X}\}.</script><p>这样的稀疏Correlation Volume则只包含 $hwk$ 个元素，而原来的则包含 $h^2w^2$ 个元素， 常数 $k$ 通常为一个比较小的数，例如8。网络结构如下所示。</p>
<p><img src="/p/1f41/SCV3.png" style="zoom:60%;"></p>
<h3 id="k-Nearest-Neighbours"><a href="#k-Nearest-Neighbours" class="headerlink" title="k-Nearest Neighbours"></a>k-Nearest Neighbours</h3><p>使用了两个共享权重的提取网络从输入的图像中获取 1/4 分辨率的特征图。特征提取网络包含了 6 个 residual blocks，特征通道数为 256。为了构建稀疏Correlation Volume，使用了一个 KNN 模块(论文中有参考文献)去计算对于 $F_1$的每个特征向量的最大的 $k$ 个相关得分的索引集合。稀疏Correlation Volume通过 $F_1$ 的每个特征向量与 $F_2$ 由索引得到的前 $k$ 个特征向量的点积。在back-propagation阶段，梯度也仅会传到由 KNN 模块选择到的 k 个特征向量。</p>
<h3 id="Displacements-Updates"><a href="#Displacements-Updates" class="headerlink" title="Displacements Updates"></a>Displacements Updates</h3><p>采用了全局的迭代精化方法，估计残差流可以有效的减少搜索空间并且可以比直接回归预测到更好的结果。与直接预测光流场 $f$ 不同，残差流 $\Delta f_{i+ 1}$ 是每一步预测并且用来更新当前的光流估计结果 $f_{i + 1} = f_i + \Delta f_{i + 1}$。</p>
<p>在每一步，对于 $F_1$ 的一个像素 $x$，将会根据当前的光流预计结果映射到 $F_2$ 中的 $x_i = x + f_i$。稀疏Correlation Volume可以看成初始光流$f_0 = 0(i = 0)$。当坐标$x_i$更新到$x_{i+1}=x_i+\Delta f_i$， $\tilde{\mathcal{C}}$中对应的位移也会同样更新。可以通过在每一步中从 $d_i$ 中减去 k 最近的 $\Delta f_i$ 来shift稀疏Correlation Volume张量的坐标，$C_i(x,d_i)=C_{i+1}(x,d_i - \Delta f_i)$。  如下图所示。并且设定为$d_i-\Delta f_i$为浮点值。需要注意的是，内积只会在最开始的时候计算一次，因为在每一步中，只有相关坐标发生变化，相关值不会发生变化。</p>
<p><img src="/p/1f41/SCV4.png" style="zoom:60%;"></p>
<h3 id="Multi-scale-Displacement-Encoder"><a href="#Multi-scale-Displacement-Encoder" class="headerlink" title="Multi-scale Displacement Encoder"></a>Multi-scale Displacement Encoder</h3><p>在多个分辨率下以固定的半径创建多尺度的稀疏张量和采样位移，粗糙的分辨率将会提供更大的文本背景，而精细的分辨率则可以提供更精确的位移。然后将每一个 level 的稀疏张量转换为稠密张量并 concatenate 形成一个 2D 张量.如下图所示。</p>
<p><img src="/p/1f41/SCV5.png" style="zoom:60%;"></p>
<p>在每一次迭代时，对于每个像素 $x$，从 $top-k$ 个相关位置$S_x^{(k)}$ 开始 ，因此集合 $\{(d,C(<br>x,d)|d\in S_x^{(k)}\}$ 记录了对于 $X$的 $top - k$ 个相关值及其位置，这通过 $kNN$ 算法得到。</p>
<p>构建了一个5层的稀疏Correlation Volume金字塔通过以（1，2，4，8，16）除坐标(意思就多分辨率的图像？)，并且表示在level l 的 比例化位移，通过当前的流 $\Delta f_i$ 更新的结果为 $d^l=(d_i-\Delta f_i)/2^{l-1}$。</p>
<p>此外，在level l的相关值表示为 $C^{l}(x,d^l)=C(x,d)$ 对于 $d\in S_x^{(k)}$。在每一个level，通过常数半径 $r$ 限制了位移范围，并且定义level l的窗口相关值集合为:</p>
<script type="math/tex; mode=display">
\{(d^l,C^l(x,d^l)) \mid ||d^l||_{\infty} \leq r, d\in S_x^{(k)}\}.</script><p>因为坐标 $d^l$ 不一定是整数，所以需要重采样到整数坐标以稠密化 correlations的稀疏张量。文中提出了一种叫做”bilinear splatting“的方法，相关值将会被 bilinear splat到四个最近的整数网格中。例如， 在位置 $d^l$ 的相关值 $C^l(x,d^l)$将会被传递到四个邻近整数点的每一个，用 $[d^l]=(d_x,d_y)$ 表示，根据下式:</p>
<script type="math/tex; mode=display">
C^l(x,[d^l])=(1-|d_x^l-d_x|)(1-|d_y^l-d_y|)C^l(x,d^l)</script><p>这些值将会累加对于(5)中的集合，每一个 level 的稀疏张量也会传换成稠密张量，reshaped 并 concatenate 成一个 2D 稠密张量维度为 $5(2r + 1)^2$，这里 5 为金字塔的层数。 </p>
<p>这个方法不含可学习参数，仅仅是稠密到稀疏张量的转换，并且比稀疏卷积容易。</p>
<h3 id="GRU-Update-Block"><a href="#GRU-Update-Block" class="headerlink" title="GRU Update Block"></a>GRU Update Block</h3><p>concatenate 2D 运动张量，上下文特征和当前的光流估计结果，并将结果传到GRU单元中，GRU单元将会不断更新估计残差流 $\Delta f_{i+1}$，这个将会在下一步中用来 shift Correlation Volume的坐标。</p>
<h2 id="Experiments"><a href="#Experiments" class="headerlink" title="Experiments"></a>Experiments</h2><h3 id="Implementation-details"><a href="#Implementation-details" class="headerlink" title="Implementation details"></a>Implementation details</h3><h4 id="Network-details"><a href="#Network-details" class="headerlink" title="Network details"></a>Network details</h4><p>首先提取 1/4 分辨率的256通道的特征图，特征提取网络包含了 6 个residual blocks。当特征图传到 $kNN$ 时，设定了 $k = 8$。也就是说，对于每个特征向量，将会返回可以得到最大内积的 $top-8$ 个特征向量的坐标。GRU 单元将当前的光流估计和上下文特性图作为输入，上下文特征图由128通道的独立网络获取。GRU 单元将会更新128维度的隐藏层特征向量。在训练阶段，GRU 将会迭代8次（RAFT 迭代12次）。</p>
<h4 id="Training-schedule"><a href="#Training-schedule" class="headerlink" title="Training schedule"></a>Training schedule</h4><p>(1, 2) pre-train</p>
<p>(3, 4, 5) fine-tune</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">次序</th>
<th style="text-align:center">数据集</th>
<th style="text-align:center">batch-size</th>
<th style="text-align:center">迭代次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">FlyingChairs</td>
<td style="text-align:center">6</td>
<td style="text-align:center">120k</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">FlyingThings</td>
<td style="text-align:center">4</td>
<td style="text-align:center">120k</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">Sintel</td>
<td style="text-align:center">4</td>
<td style="text-align:center">120k</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">KITTI</td>
<td style="text-align:center">4</td>
<td style="text-align:center">50k</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">HD1K</td>
<td style="text-align:center">4</td>
<td style="text-align:center">50k</td>
</tr>
</tbody>
</table>
</div>
<p>Training: 2 $\times$ 2080Ti GPU</p>
<p>Ablation experiment: 1 $\times$ Tesla P100 GPU</p>
<h4 id="Loss-function"><a href="#Loss-function" class="headerlink" title="Loss function"></a>Loss function</h4><p>与 RAFT 一样，使用了循环网络结构预测一系列的残差流 $\Delta f_i$, 每一个阶段的光流预测结果可以表示为 $f_{i+1}=f_i+\Delta f_{i+ 1}$，初始值 $f_0 = 0, \Delta f_0 = 0$。</p>
<p>损失函数针对于光流预测的序列结果，对于给定的真值光流 $f_{gt}$，对于每一阶段的预测结果 $f_i$,损失函数定义为:</p>
<script type="math/tex; mode=display">
L = \sum_{i = 1}^N\gamma^{N - i}||f_i-f_{gt}||_1</script><p>权重因子: $\gamma = 0.8$（pre-train on Flyingchairs + FlyingThings), $\gamma = 0.85$ (fine-tune on Sintel and KITTI)</p>
<p>总阶段数: $N = 8$</p>
<h4 id="kNN"><a href="#kNN" class="headerlink" title="kNN"></a>kNN</h4><p>使用了 <strong>faiss</strong> 库在 GPU 上跑 $kNN$，具体参考论文以及对应的参考文献。非常的amazing。</p>
<h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p>定量分析结果如下表所示。</p>
<p><img src="/p/1f41/SCV6.png" style="zoom:60%;"></p>
<p>Sintel Clean数据集从RAFT的 1.94 改进到了 1.72 。同时测试了RAFT的 warm-start 策略（用前一帧的光流估计结果初始化当前的光流估计结果）。这个策略没有改进本文的模型，仍然落后于RAFT(warm-start)。在 Sintel 数据集上，模型和 SOTA 相差不大，只比 RAFT 和 DICL 差了一点。同时测试了预训练模型 (C+T) 在 Sintel 和 KITTI-15 上性能，在Sintel Clean 达到了最好的性能，在 Sintel final 和 KITTI-15 上仅次于RAFT。</p>
<p>在 Sintel Clean 数据上的改进可以归功于较大的 Correlation Volume(1/4 分辨率 vs 1/8 分辨率)。量化结果如下图所示,很好的说明了在高分辨率下构建 Correlation Volume 和 进行光流预测的优势。 </p>
<p><img src="/p/1f41/SCV7.png" style="zoom:60%;"></p>
<p>在Sintel Final 和 KITTI-15 数据上，存在比较大的运动模糊和特征缺失区域，因此 $k= 8$ 与稠密 Correlation Volume 相比就显得很小而不能达到同样的效果。后面的消融实验中也对 $k$ 做了分析。但是可以说明，尽管在所有的数据集上没有超过RAFT, 但是可以说明稀疏的方法，尽管只有很少的相关值，仍然可以得到不错的效果。对于每个像素，只需要存储 $k = 8$ 个相关值，但是 RAFT 却需要存储 $h\times w$ 个相关值，限制了向更高分辨率 scale 的能力。</p>
<h3 id="Ablation"><a href="#Ablation" class="headerlink" title="Ablation"></a>Ablation</h3><p>消融实验仍然是为了说明 $top-k$ 个相关值对于 full correlation volume来说是足够的。在 $1/8$ 分辨率下，更大的 $k$ 可以带来更好的结果，即便 $k = 1$ 与不会彻底失败。</p>
<p>同时比较了 $1/4$ 分辨率和 $1/8$ 分辨率，可以看出 $1/4$ 分辨可以达到更好效果，除了在 KITTI-15的 EPE 指标上。</p>
<p>同时对 RAFT 的原生实现进行了实验，保留了 Correlation Volume 中的前 $k$ 个，而对其他的设为 0，依次修改 $k = \{1,8,32,128\}$。在表中，RELU 代表设置负值为0，只保留相关值中的正值。同时训练了原始代码，用 Dense 标记。可以看出更大的 $k$ 可以得到更好的结果，$k = \{32,128\}$可以达到与 Dense 相近的结果。这验证了文章的假设，稠密的 Correlation Volume 会有很大的冗余，有一个较大的 $k$ 值的稀疏 Correlation Volume同样可以达到很好的效果。</p>
<p>具体结果在 <strong>Results</strong>的表中。</p>
<h3 id="Memory-Consumption"><a href="#Memory-Consumption" class="headerlink" title="Memory Consumption"></a>Memory Consumption</h3><p>稀疏 Correlation Volume 并不会引进新的学习参数，因此参数个数和 RAFT 是一样的。对于输入图片为 $436 \times 1024$ 大小的图片，在分辨率为 $1/4$ 和 $1/8$ 下的稀疏 Correlation Volume 的尺寸和大小如下表所示。</p>
<p><img src="/p/1f41/SCV8.png" style="zoom:60%;"></p>
<p>从 $1/8$ 分辨率下的特征图构建 Correlation Volume并不会带来内存的显著节省，这是因为 $kNN$ 库的常数 2GB消耗，Correlation Volume的内存消耗并不是瓶颈问题。</p>
<p>但是从 $1/4$ 分辨率下构建可以看出很清晰的优势，对原图片进行 $400\times 720$ 的随机切割，并且 $batch-size =1,2$ 可以看出该方法与 RAFT 相比可以将近 50% 的内存。</p>
<p><img src="/p/1f41/SCV9.png" style="zoom:60%;"></p>
<h3 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h3><p>简单的说就是，对于fine-strcture 的运动可以看出很大的改进，但是由于 EPE指标是考虑全局的，这是面向大区域的大尺度运动的偏差。这个方法的劣势在于对特征缺失或者模糊的区域。这些区域的特征因为模糊就需要很多的匹配，但是 $top-k$ 可能就不够充分去包含正确的匹配，并且会给出不正确的运动预测结果。一个失败的例子如下图所示。</p>
<p><img src="/p/1f41/SCV10.png" style="zoom:60%;"></p>
<h2 id="Related-Work-amp-amp-Conclusion"><a href="#Related-Work-amp-amp-Conclusion" class="headerlink" title="Related Work &amp;&amp; Conclusion"></a>Related Work &amp;&amp; Conclusion</h2><p>不做赘述.</p>
]]></content>
      <categories>
        <category>光流</category>
      </categories>
      <tags>
        <tag>双帧光流</tag>
      </tags>
  </entry>
</search>
